Index: Cleanup.bat
===================================================================
--- Cleanup.bat	(revision 0)
+++ Cleanup.bat	(working copy)
@@ -0,0 +1,40 @@
+@echo off
+
+cd multidol
+echo.
+echo Cleaning Multi-DOL Loader
+echo.
+make windows=1 clean
+
+cd ..\kernel\asm
+echo.
+echo Cleaning asm files
+echo.
+make windows=1 clean
+
+cd ..\..\resetstub
+echo.
+echo Cleaning Reset Stub
+echo.
+make clean
+
+cd ..\kernel
+echo.
+echo Cleaning Nintendont Kernel
+echo.
+rm -f *.elf *.o *.bin *.d *.map lwbt/*.d lwbt/*.o
+
+cd ..\loader\source\ppc
+echo.
+echo Cleaning Nintendont HID
+echo.
+
+cd ..\..\..\loader
+echo.
+echo Cleaning Nintendont Loader
+echo.
+make clean
+
+echo Done!
+echo.
+pause
\ No newline at end of file
Index: common/include/CommonConfig.h
===================================================================
--- common/include/CommonConfig.h	(revision 334)
+++ common/include/CommonConfig.h	(working copy)
@@ -5,7 +5,7 @@
 #include "NintendontVersion.h"
 #include "Metadata.h"
 
-#define NIN_CFG_VERSION		0x00000003
+#define NIN_CFG_VERSION		0x00000006
 
 #define NIN_CFG_MAXPAD 4
 
@@ -20,7 +20,10 @@
 	char	CheatPath[255];
 	unsigned int		MaxPads;
 	unsigned int		GameID;
-	unsigned int		MemCardBlocks;
+	unsigned char		MemCardBlocks;
+	signed char			VideoScale;
+	signed char			VideoOffset;
+	unsigned char		Unused;
 } NIN_CFG;
 
 enum ninconfigbitpos
@@ -87,6 +90,8 @@
 	NIN_VID_INDEX_FORCE_PAL60	= (1),
 	NIN_VID_INDEX_FORCE_NTSC	= (2),
 	NIN_VID_INDEX_FORCE_MPAL	= (3),
+	NIN_VID_INDEX_PROG			= (4),
+	NIN_VID_INDEX_PATCH_PAL50	= (5),
 };
 
 enum ninvideomode
@@ -105,7 +110,8 @@
 
 	NIN_VID_FORCE_MASK	= NIN_VID_FORCE_PAL50|NIN_VID_FORCE_PAL60|NIN_VID_FORCE_NTSC|NIN_VID_FORCE_MPAL,
 
-	NIN_VID_PROG		= (1<<4),	//important to prevent blackscreens
+	NIN_VID_PROG		= (1<<NIN_VID_INDEX_PROG),	//important to prevent blackscreens
+	NIN_VID_PATCH_PAL50	= (1<<NIN_VID_INDEX_PATCH_PAL50), //different force behaviour
 };
 
 enum ninlanguage
Index: common/include/CommonConfigStrings.h
===================================================================
--- common/include/CommonConfigStrings.h	(revision 334)
+++ common/include/CommonConfigStrings.h	(working copy)
@@ -13,10 +13,10 @@
 	"Force Widescreen",
 	"Force Progressive",
 	"Auto Boot",
-	"Use HID device",
+	"Disable HDD Ping",
 	"OSReport",
-	"WiiU Widescreen", //Replaces USB
-	"Drive Read LED",
+	"WiiU Widescreen",
+	"Drive Access LED",
 	"Log",
 	
 	"MaxPads",
Index: common/include/Metadata.h
===================================================================
--- common/include/Metadata.h	(revision 334)
+++ common/include/Metadata.h	(working copy)
@@ -3,9 +3,9 @@
 #define __META_DATA_H__
 
 #define META_NAME			"Nintendont"
-#define META_AUTHOR			"crediar"
+#define META_AUTHOR			"FIX94, crediar"
 
-#define META_LONG1			"Commiters: JoostinOnline, Greyrogue, Howard, Cyan, Fix94 \r\n\r\n Project website: https://nintendon-t.googlecode.com/ "
+#define META_LONG1			"Commiters: JoostinOnline, GreyRogue, Howard, Cyan \r\n\r\n Project website: https://github.com/FIX94/Nintendont "
 #define META_LONG2			"Nintendont allows you to run GameCube games on a Wii or Wii U from an SD or HDD device."
 #define META_SHORT			"Gamecube Loader"
 
Index: common/include/NintendontVersion.h
===================================================================
--- common/include/NintendontVersion.h	(revision 334)
+++ common/include/NintendontVersion.h	(working copy)
@@ -3,7 +3,7 @@
 #define __NINTENDONT_VERSION_H__
 
 #define NIN_MAJOR_VERSION			3
-#define NIN_MINOR_VERSION			334
+#define NIN_MINOR_VERSION			400
 
 #define NIN_VERSION		((NIN_MAJOR_VERSION << 16) | NIN_MINOR_VERSION)
 
Index: kernel/asm/__ARHandler.S
===================================================================
--- kernel/asm/__ARHandler.S	(revision 334)
+++ kernel/asm/__ARHandler.S	(working copy)
@@ -15,14 +15,23 @@
 	li		%r7,	0
 	stw		%r7,	AR_DMA_LEN@l(%r3)
 
+	#adjust ARAM address for safety
+	lwz		%r5,	AR_DMA_MEM2@l(%r3)
+	rlwinm	%r5,	%r5,	0,		6,		26 # 0x03ffffe0
+	oris	%r5,	%r5,	0x9000
+
+	add		%r0,	%r5,	%r6
+	#ARAM Max Address to ensure no overwriting 
+	lis		%r7,	0x9100
+	cmplw	%r0,	%r7
+	#Out of Memory Bounds, dont do anything
+	bgt		end
+
+	#adjust MEM1 address for safety
 	lwz		%r4,	AR_DMA_MEM1@l(%r3)
 	rlwinm	%r4,	%r4,	0,		7,		26 # 0x01ffffe0
 	oris	%r4,	%r4,	0x8000
 
-	lwz		%r5,	AR_DMA_MEM2@l(%r3)
-	rlwinm	%r5,	%r5,	0,		8,		26 # 0x00ffffe0
-	oris	%r5,	%r5,	0x9000
-
 	lwz		%r0,	AR_DMA_MODE@l(%r3)
 	cmpwi	%r0,	AR_MRAM_TO_ARAM
 	beq		memcpy32prep
Index: kernel/asm/__DSPHandler.S
===================================================================
--- kernel/asm/__DSPHandler.S	(revision 334)
+++ kernel/asm/__DSPHandler.S	(working copy)
@@ -69,7 +69,7 @@
 	cmplw	%r4,	%r3
 	blt		buf1
 buf2:
-	slwi	%r3,	%r3,	1		#MAXBUF=0x7000
+	slwi	%r3,	%r3,	1		#MAXBUF=0x18800
 buf1:
 	lis		%r6,	AI_ADP_BUF@h
 
Index: kernel/asm/ARStartDMA.S
===================================================================
--- kernel/asm/ARStartDMA.S	(revision 334)
+++ kernel/asm/ARStartDMA.S	(working copy)
@@ -35,12 +35,21 @@
 	cmpwi	%r6,	0
 	beq		FakeTransfer
 
+	#adjust ARAM address for safety
+	rlwinm	%r5,	%r5,	0,		6,		26 # 0x03ffffe0
+	oris	%r5,	%r5,	0x9000
+
+	add		%r0,	%r5,	%r6
+	#ARAM Max Address to ensure no overwriting 
+	lis		%r7,	0x9100
+	cmplw	%r0,	%r7
+	#Out of Memory Bounds, dont do anything
+	bgt		FakeTransfer
+
+	#adjust MEM1 address for safety
 	rlwinm	%r4,	%r4,	0,		7,		26 # 0x01ffffe0
 	oris	%r4,	%r4,	0x8000
 
-	rlwinm	%r5,	%r5,	0,		8,		26 # 0x00ffffe0
-	oris	%r5,	%r5,	0x9000
-
 	cmpwi	%r3,	AR_MRAM_TO_ARAM
 	beq		memcpy32prep		#we dont need to invalidate main mem
 
Index: kernel/asm/ARStartDMA_PM.S
===================================================================
--- kernel/asm/ARStartDMA_PM.S	(revision 334)
+++ kernel/asm/ARStartDMA_PM.S	(working copy)
@@ -18,12 +18,21 @@
 	cmpwi	%r6,	0
 	beq		FakeTransfer
 
+	#adjust ARAM address for safety
+	rlwinm	%r5,	%r5,	0,		6,		26 # 0x03ffffe0
+	oris	%r5,	%r5,	0x9000
+
+	add		%r0,	%r5,	%r6
+	#ARAM Max Address to ensure no overwriting 
+	lis		%r7,	0x9100
+	cmplw	%r0,	%r7
+	#Out of Memory Bounds, dont do anything
+	bgt		FakeTransfer
+
+	#adjust MEM1 address for safety
 	rlwinm	%r4,	%r4,	0,		7,		26 # 0x01ffffe0
 	oris	%r4,	%r4,	0x8000
 
-	rlwinm	%r5,	%r5,	0,		8,		26 # 0x00ffffe0
-	oris	%r5,	%r5,	0x9000
-
 	cmpwi	%r3,	AR_MRAM_TO_ARAM
 	beq		memcpy32prep		#we dont need to invalidate main mem
 
Index: kernel/asm/ARStartDMA_TC.S
===================================================================
--- kernel/asm/ARStartDMA_TC.S	(revision 334)
+++ kernel/asm/ARStartDMA_TC.S	(working copy)
@@ -18,12 +18,21 @@
 	cmpwi	%r6,	0
 	beq		FakeTransfer
 
+	#adjust ARAM address for safety
+	rlwinm	%r5,	%r5,	0,		6,		26 # 0x03ffffe0
+	oris	%r5,	%r5,	0x9000
+
+	add		%r0,	%r5,	%r6
+	#ARAM Max Address to ensure no overwriting 
+	lis		%r7,	0x9100
+	cmplw	%r0,	%r7
+	#Out of Memory Bounds, dont do anything
+	bgt		FakeTransfer
+
+	#adjust MEM1 address for safety
 	rlwinm	%r4,	%r4,	0,		7,		26 # 0x01ffffe0
 	oris	%r4,	%r4,	0x8000
 
-	rlwinm	%r5,	%r5,	0,		8,		26 # 0x00ffffe0
-	oris	%r5,	%r5,	0x9000
-
 	cmpwi	%r3,	AR_MRAM_TO_ARAM
 	beq		memcpy32prep
 
Index: kernel/asm/Makefile
===================================================================
--- kernel/asm/Makefile	(revision 334)
+++ kernel/asm/Makefile	(working copy)
@@ -46,5 +46,5 @@
 
 clean:
 	@echo clean ...
-	@rm -fr $(HFILES) $(BINFILES) $(ELFFILES)
+	@rm -fr *.h *.bin *.elf
 
Index: kernel/BT.c
===================================================================
--- kernel/BT.c	(revision 334)
+++ kernel/BT.c	(working copy)
@@ -48,7 +48,7 @@
 static vu32* IRSensitivity = (u32*)0x132C0490;
 static vu32* SensorBarPosition = (u32*)0x132C0494;
 
-u8 LEDState[] = { 0x10, 0x20, 0x40, 0x80, 0xF0 };
+static const u8 LEDState[] = { 0x10, 0x20, 0x40, 0x80, 0xF0 };
 
 #define CHAN_NOT_SET 4
 
@@ -250,25 +250,25 @@
 		{
 			switch (BTPad[chan].button & ~WM_BUTTON_TWO)
 			{
-				case WM_BUTTON_LEFT:
+				case WM_BUTTON_LEFT: //Abz
 					stat->controller = (stat->controller & ~(C_NSWAP1 | C_NSWAP2 | C_NSWAP3)) | (C_NSWAP1 * 1);
 					break;
-				case WM_BUTTON_RIGHT:
+				case WM_BUTTON_RIGHT: //Howards
 					stat->controller = (stat->controller & ~(C_NSWAP1 | C_NSWAP2 | C_NSWAP3)) | (C_NSWAP1 * 2);
 					break;
-				case WM_BUTTON_UP:
+				case WM_BUTTON_UP: //Race1
 					stat->controller = (stat->controller & ~(C_NSWAP1 | C_NSWAP2 | C_NSWAP3)) | (C_NSWAP1 * 3);
 					break;
-				case WM_BUTTON_DOWN:
+				case WM_BUTTON_DOWN: //Race 2
 					stat->controller = (stat->controller & ~(C_NSWAP1 | C_NSWAP2 | C_NSWAP3)) | (C_NSWAP1 * 4);
 					break;
-				case WM_BUTTON_MINUS:
+				case WM_BUTTON_MINUS: //Troops
 					stat->controller = (stat->controller & ~(C_NSWAP1 | C_NSWAP2 | C_NSWAP3)) | (C_NSWAP1 * 5);
 					break;
-				case WM_BUTTON_ONE:
+				case WM_BUTTON_PLUS: // Naggers
 					stat->controller = (stat->controller & ~(C_NSWAP1 | C_NSWAP2 | C_NSWAP3)) | (C_NSWAP1 * 6);
 					break;
-				case WM_BUTTON_PLUS:
+				case WM_BUTTON_ONE: // Exit
 					stat->controller = (stat->controller & ~(C_NSWAP1 | C_NSWAP2 | C_NSWAP3)) | (C_NSWAP1 * 7);
 					break;
 				case NUN_BUTTON_C:
@@ -346,15 +346,16 @@
 	{
 		if(stat->transferstate == TRANSFER_GET_IDENT)
 		{
-			if((R32((u32)((u8*)buffer+8)) == 0xA4200101) ||	//CLASSIC_CONTROLLER
-			   (R32((u32)((u8*)buffer+8)) == 0x90908f00) ||	//CLASSIC_CONTROLLER_NYKOWING
-			   (R32((u32)((u8*)buffer+8)) == 0x9e9f9c00) ||	//CLASSIC_CONTROLLER_NYKOWING2
-			   (R32((u32)((u8*)buffer+8)) == 0x908f8f00) ||	//CLASSIC_CONTROLLER_NYKOWING3
-			   (R32((u32)((u8*)buffer+8)) == 0xa5a2a300) ||	//CLASSIC_CONTROLLER_GENERIC
-			   (R32((u32)((u8*)buffer+8)) == 0x98999900) ||	//CLASSIC_CONTROLLER_GENERIC2
-			   (R32((u32)((u8*)buffer+8)) == 0xa0a1a000) ||	//CLASSIC_CONTROLLER_GENERIC3
-			   (R32((u32)((u8*)buffer+8)) == 0x8d8d8e00) ||	//CLASSIC_CONTROLLER_GENERIC4
-			   (R32((u32)((u8*)buffer+8)) == 0x93949400))		//CLASSIC_CONTROLLER_GENERIC5
+			const u32 ext_ctrl_id = R32((u32)((u8*)buffer+8));
+			if((ext_ctrl_id == 0xA4200101) ||	//CLASSIC_CONTROLLER
+			   (ext_ctrl_id == 0x90908f00) ||	//CLASSIC_CONTROLLER_NYKOWING
+			   (ext_ctrl_id == 0x9e9f9c00) ||	//CLASSIC_CONTROLLER_NYKOWING2
+			   (ext_ctrl_id == 0x908f8f00) ||	//CLASSIC_CONTROLLER_NYKOWING3
+			   (ext_ctrl_id == 0xa5a2a300) ||	//CLASSIC_CONTROLLER_GENERIC
+			   (ext_ctrl_id == 0x98999900) ||	//CLASSIC_CONTROLLER_GENERIC2
+			   (ext_ctrl_id == 0xa0a1a000) ||	//CLASSIC_CONTROLLER_GENERIC3
+			   (ext_ctrl_id == 0x8d8d8e00) ||	//CLASSIC_CONTROLLER_GENERIC4
+			   (ext_ctrl_id == 0x93949400))		//CLASSIC_CONTROLLER_GENERIC5
 			{
 				if(*((u8*)buffer+6) == 0)
 				{
@@ -376,7 +377,7 @@
 				stat->transferstate = TRANSFER_CALIBRATE;
 				sync_after_write(arg, sizeof(struct BTPadStat));
 			}
-			else if(R32((u32)((u8*)buffer+8)) == 0xA4200000)
+			else if(ext_ctrl_id == 0xA4200000)
 			{
 				stat->controller = C_NUN;
 				//dbgprintf("Connected NUNCHUCK\n");
@@ -579,7 +580,7 @@
 	stat->rumble = 0;
 
 	BTSetControllerState(stat->sock, LEDState[CHAN_NOT_SET]);
-
+	
 	//wiimote extensions need some extra stuff first, start with getting its status
 	if(stat->transfertype == 0x34 || stat->transfertype == 0x37)
 	{
@@ -635,7 +636,7 @@
 	return ERR_OK;
 }
 
-int RegisterBTPad(struct BTPadStat *stat, struct bd_addr *_bdaddr)
+static int RegisterBTPad(struct BTPadStat *stat, struct bd_addr *_bdaddr)
 {
 	stat->bdaddr = *_bdaddr;
 	stat->sock = bte_new();
@@ -761,7 +762,7 @@
 				}
 			}
 		}
-		else if(TimerDiffSeconds(BTPadConnected[i]->timeout) >= 20)
+		else if(TimerDiffSeconds(BTPadConnected[i]->timeout) >= 5)
 		{
 			bte_disconnect(BTPadConnected[i]->sock);
 			break;
Index: kernel/Config.c
===================================================================
--- kernel/Config.c	(revision 334)
+++ kernel/Config.c	(working copy)
@@ -76,6 +76,14 @@
 {
 	return ncfg->GameID;
 }
+inline s8 ConfigGetVideoScale(void)
+{
+	return ncfg->VideoScale;
+}
+inline s8 ConfigGetVideoOffset(void)
+{
+	return ncfg->VideoOffset;
+}
 inline u32 ConfigGetMemcardCode(void)
 {
 	return MEM_CARD_CODE(ncfg->MemCardBlocks);
Index: kernel/Config.h
===================================================================
--- kernel/Config.h	(revision 334)
+++ kernel/Config.h	(working copy)
@@ -49,6 +49,8 @@
 u32 ConfigGetLanguage( void );
 u32 ConfigGetMaxPads(void);
 u32 ConfigGetGameID(void);
+s8 ConfigGetVideoScale(void);
+s8 ConfigGetVideoOffset(void);
 u32 ConfigGetMemcardCode(void);
 u32 ConfigGetMemcardSize(void);
 void ConfigSetMemcardBlocks(u32 MemCardBlocks);
Index: kernel/DI.c
===================================================================
--- kernel/DI.c	(revision 334)
+++ kernel/DI.c	(working copy)
@@ -20,6 +20,7 @@
 */
 #include "global.h"
 #include "DI.h"
+#include "RealDI.h"
 #include "string.h"
 #include "common.h"
 #include "alloc.h"
@@ -58,13 +59,18 @@
 
 static char GamePath[256] ALIGNED(32);
 extern const u8 *DiskDriveInfo;
-extern u32 Region;
 extern u32 FSTMode;
 extern u32 RealDiscCMD;
+extern u32 RealDiscError;
+u32 WaitForRealDisc = 0;
 
 u8 *DI_READ_BUFFER = (u8*)0x12E80000;
 u32 DI_READ_BUFFER_LENGTH = 0x80000;
 
+extern u32 GAME_ID;
+extern u16 GAME_ID6;
+extern u32 TITLE_ID;
+ 
 // Triforce
 extern vu32 TRIGame;
 extern vu32 useipltri;
@@ -77,12 +83,6 @@
 u8 *NetworkCMDBuffer;
 u8 *DIMMMemory = (u8*)0x12B80000;
 
-//No ISO Cache so lets take alot of memory
-u8 *DISC_FRONT_CACHE = (u8*)0x12000000;
-u8 *DISC_DRIVE_BUFFER = (u8*)0x12000800;
-u32 DISC_DRIVE_BUFFER_LENGTH = 0x7FF000;
-u8 *DISC_TMP_CACHE = (u8*)0x127FF800;
-
 void DIRegister(void)
 {
 	DI_MessageHeap = malloca(0x20, 0x20);
@@ -97,24 +97,11 @@
 	free(DI_MessageHeap);
 	DI_MessageHeap = NULL;
 }
-vu32 WaitForWrite = 0, WaitForRead = 0;
+
 bool DiscCheckAsync( void )
 {
 	if(RealDiscCMD)
-	{
-		if(WaitForWrite == 1)
-		{
-			WaitForWrite = 0;
-			while(WaitForRead == 0)
-				udelay(20);
-		}
-		if(WaitForRead == 1 && (read32(DIP_CONTROL) & 1) == 0)
-		{
-			write32(DIP_STATUS, 0x54); //mask and clear interrupts
-			udelay(70);
-			WaitForRead = 0;
-		}
-	}
+		RealDI_Update();
 	return (DI_CallbackMsg.result == 0);
 }
 
@@ -147,106 +134,8 @@
 	sync_after_write((void*)Buffer, Length);
 }
 
-static u32 DVD_OFFSET = UINT_MAX;
-void ClearRealDiscBuffer(void)
-{
-	DVD_OFFSET = UINT_MAX;
-	memset32(DISC_DRIVE_BUFFER, 0, DISC_DRIVE_BUFFER_LENGTH);
-	sync_after_write(DISC_DRIVE_BUFFER, DISC_DRIVE_BUFFER_LENGTH);
-}
-
-u8 *ReadRealDisc(u32 *Length, u32 Offset, bool NeedSync)
-{
-	//dbgprintf("ReadRealDisc(%08x %08x)\r\n", *Length, Offset);
-
-	u32 CachedBlockStart = 0;
-	u32 ReadDiff = 0;
-	if(RealDiscCMD == DIP_CMD_DVDR)
-	{
-		u32 AlignedOffset = ALIGN_BACKWARD(Offset, 0x800);
-		ReadDiff = Offset - AlignedOffset;
-		if(AlignedOffset == DVD_OFFSET)
-		{
-			sync_before_read(DISC_TMP_CACHE, 0x800);
-			//dbgprintf("Using cached offset %08x\r\n", DVD_OFFSET>>11);
-			memcpy(DISC_FRONT_CACHE, DISC_TMP_CACHE, 0x800);
-			CachedBlockStart = 0x800;
-			u32 AlignedLength = ALIGN_FORWARD(*Length + ReadDiff, 0x800);
-			if( AlignedLength > 0 && AlignedLength == CachedBlockStart )
-				return (DISC_FRONT_CACHE + ReadDiff);
-		}
-		//dbgprintf("ReadDiff: %08x\r\n", ReadDiff);
-	}
-	if(NeedSync)
-	{
-		WaitForWrite = 1;
-		while(WaitForWrite == 1)
-			udelay(20);
-	}
-	if (ConfigGetConfig(NIN_CFG_LED))
-		set32(HW_GPIO_OUT, GPIO_SLOT_LED);	//turn on drive light
-
-	if (*Length > DISC_DRIVE_BUFFER_LENGTH - ReadDiff)
-	{
-		*Length = DISC_DRIVE_BUFFER_LENGTH - ReadDiff;
-		//dbgprintf("New Length: %08x\r\n", *Length);
-	}
-	u32 TmpLen = *Length;
-	u32 TmpOffset = Offset;
-	if(RealDiscCMD == DIP_CMD_DVDR)
-	{
-		TmpLen = ALIGN_FORWARD(TmpLen + ReadDiff, 0x800) - CachedBlockStart;
-		TmpOffset = ALIGN_BACKWARD(Offset, 0x800) + CachedBlockStart;
-	}
-
-	write32(DIP_STATUS, 0x54); //mask and clear interrupts
-
-	//Actually read
-	write32(DIP_CMD_0, RealDiscCMD << 24);
-	write32(DIP_CMD_1, RealDiscCMD == DIP_CMD_DVDR ? TmpOffset >> 11 : TmpOffset >> 2);
-	write32(DIP_CMD_2, RealDiscCMD == DIP_CMD_DVDR ? TmpLen >> 11 : TmpLen);
-
-	//dbgprintf("Read %08x %08x\r\n", read32(DIP_CMD_1), read32(DIP_CMD_2));
-	sync_before_read(DISC_DRIVE_BUFFER, TmpLen);
-	write32(DIP_DMA_ADR, (u32)DISC_DRIVE_BUFFER);
-	write32(DIP_DMA_LEN, TmpLen);
-
-	write32( DIP_CONTROL, 3 );
-	udelay(70);
-
-	if(NeedSync)
-	{
-		WaitForRead = 1;
-		while(WaitForRead == 1)
-			udelay(200);
-	}
-	else
-	{
-		while(read32(DIP_CONTROL) & 1)
-			udelay(200);
-		write32(DIP_STATUS, 0x54); //mask and clear interrupts
-		udelay(70);
-	}
-
-	if (ConfigGetConfig(NIN_CFG_LED))
-		clear32(HW_GPIO_OUT, GPIO_SLOT_LED); //turn off drive light
-
-	if(RealDiscCMD == DIP_CMD_DVDR)
-	{
-		u32 LastBlockStart = (read32(DIP_CMD_2) - 1) << 11;
-		DVD_OFFSET = (read32(DIP_CMD_1) << 11) + LastBlockStart;
-		memcpy(DISC_TMP_CACHE, DISC_DRIVE_BUFFER + LastBlockStart, 0x800);
-		sync_after_write(DISC_TMP_CACHE, 0x800);
-		if(CachedBlockStart)
-			return (DISC_FRONT_CACHE + ReadDiff);
-	}
-
-	return DISC_DRIVE_BUFFER + ReadDiff;
-}
-
 void DIinit( bool FirstTime )
 {
-	u8 TmpBuffer[32] __attribute__((aligned(32)));
 	//This debug statement seems to cause crashing.
 	//dbgprintf("DIInit()\r\n");
 
@@ -297,15 +186,11 @@
 		sync_after_write( (void*)DI_BASE, 0x40 );
 	}
 	DI_Handle = IOS_Open( "/dev/mydi", 0 );
-	if(RealDiscCMD)
-	{
-		DiscReadSync((u32)TmpBuffer, 0, 0x20, 0);
-		memcpy((void*)0x0, TmpBuffer, 0x20);
-		sync_after_write((void*)0x0, 0x20);
-		DiscReadSync((u32)TmpBuffer, 0x440, 0x20, 0);
-		memcpy(&Region, TmpBuffer+0x18, sizeof(u32));
-	}
 
+	GAME_ID = read32(0);
+	GAME_ID6 = R16(4);
+	TITLE_ID = (GAME_ID >> 8);
+
 	GCAMKeyA = read32(0);
 	GCAMKeyB = read32(4);
 	GCAMKeyC = read32(8);
@@ -348,23 +233,40 @@
 	/* Update DMA registers when needed */
 	if(read32(DI_CONTROL) & 2)
 	{
-		/* Yes, some games need manual invalidates */
-		write32(DI_INV_ADR, read32(DI_DMA_ADR));
-		write32(DI_INV_LEN, read32(DI_DMA_LEN));
+		if(TITLE_ID == 0x47544B) //Turok Evolution
+		{	/* Manually invalidate data */
+			write32(DI_INV_ADR, read32(DI_DMA_ADR));
+			write32(DI_INV_LEN, read32(DI_DMA_LEN));
+		}
 		write32(DI_DMA_ADR, read32(DI_DMA_ADR) + read32(DI_DMA_LEN));
 	}
-	write32( DI_DMA_LEN, 0 ); // all data handled, clear length
+	write32( DI_CONTROL, read32(DI_CONTROL) & 2 ); // finished command
 	u32 di_status = read32(DI_STATUS);
-	write32( DI_STATUS, di_status | 0x10 ); //set TC
-	write32( DI_CONTROL, read32(DI_CONTROL) & 2 ); // finished command
-	sync_after_write( (void*)DI_BASE, 0x40 );
-	if( di_status & 0x8 ) //TC Interrupt enabled
+	if(RealDiscError == 0)
 	{
-		write32( DI_INT, 0x4 ); // DI IRQ
-		sync_after_write( (void*)DI_INT, 0x20 );
-		write32( HW_IPC_ARMCTRL, (1<<0) | (1<<4) ); //throw irq
-		//dbgprintf("Disc Interrupt\r\n");
+		write32( DI_DMA_LEN, 0 ); // all data handled, clear length
+		write32( DI_STATUS, di_status | 0x10 ); //set TC
+		sync_after_write( (void*)DI_BASE, 0x40 );
+		if( di_status & 0x8 ) //TC Interrupt enabled
+		{
+			write32( DI_INT, 0x4 ); // DI IRQ
+			sync_after_write( (void*)DI_INT, 0x20 );
+			write32( HW_IPC_ARMCTRL, (1<<0) | (1<<4) ); //throw irq
+			//dbgprintf("Disc Interrupt\r\n");
+		}
 	}
+	else
+	{
+		write32( DI_STATUS, di_status | 4 ); //set Error
+		sync_after_write( (void*)DI_BASE, 0x40 );
+		if( di_status & 2 ) //Error Interrupt enabled
+		{
+			write32( DI_INT, 0x4 ); // DI IRQ
+			sync_after_write( (void*)DI_INT, 0x20 );
+			write32( HW_IPC_ARMCTRL, (1<<0) | (1<<4) ); //throw irq
+			//dbgprintf("Disc Interrupt\r\n");
+		}
+	}
 	DI_IRQ = false;
 }
 
@@ -707,18 +609,35 @@
 			} break;
 			case 0xE0:	// Get error status
 			{
-				write32( DI_IMM, 0x00000000 );
+				if(WaitForRealDisc == 0 && RealDiscError == 0)
+					write32( DI_IMM, 0x00000000 );
+				else
+				{	//we just always say disc got removed as error
+					write32(DI_IMM, 0x1023a00);
+					write32(DI_COVER, 1);
+					RealDiscError = 0;
+					WaitForRealDisc = 1;
+				}
 				DIOK = 2;
 			} break;
 			case 0xE3:	// stop Motor
 			{
 				dbgprintf("DIP:DVDLowStopMotor()\r\n");
-				u32 CDiscNumber = (read32(4) << 16 ) >> 24;
-				dbgprintf("DIP:Current disc number:%u\r\n", CDiscNumber + 1 );
+				if(RealDiscCMD == 0)
+				{
+					u32 CDiscNumber = (read32(4) << 16 ) >> 24;
+					dbgprintf("DIP:Current disc number:%u\r\n", CDiscNumber + 1 );
 
-				if (DIChangeDisc( CDiscNumber ^ 1 ))
-					DiscChangeIRQ = 1;
-				
+					if (DIChangeDisc( CDiscNumber ^ 1 ))
+						DiscChangeIRQ = 1;
+				}
+				else
+				{	//we just always say disc got removed as error
+					write32(DI_IMM, 0x1023a00);
+					write32(DI_COVER, 1);
+					RealDiscError = 0;
+					WaitForRealDisc = 1;
+				}
 				DIOK = 2;
 
 			} break;
@@ -790,8 +709,6 @@
 			{
 				#ifdef PATCHALL
 				BTInit();
-				if(ConfigGetConfig(NIN_CFG_HID))
-					HIDEnable();
 				#endif
 				DIOK = 1;
 			} break;
@@ -808,7 +725,8 @@
 	}
 	return;
 }
-extern u32 Pach31A0Backup;
+
+extern u32 Patch31A0Backup;
 u8 *di_src = NULL; char *di_dest = NULL; u32 di_length = 0, di_offset = 0;
 u32 DIReadThread(void *arg)
 {
@@ -879,7 +797,7 @@
 					if(((u32)di_dest + Offset) <= 0x31A0)
 					{
 						u32 pos31A0 = 0x31A0 - ((u32)di_dest + Offset);
-						Pach31A0Backup = read32((u32)di_src + pos31A0);
+						Patch31A0Backup = read32((u32)di_src + pos31A0);
 					}
 					memcpy( di_dest + Offset, di_src, Length > di_length ? di_length : Length );
 				}
@@ -897,6 +815,7 @@
 				break;
 		}
 	}
+	return 0;
 }
 
 void DIFinishAsync()
@@ -941,9 +860,8 @@
 	}
 	else if(di_offset == 0x2440)
 	{
-		u32 gameid = (read32(0) >> 8);
 		u16 company = (read32(0x4) >> 16);
-		if(company == 0x3431 || company == 0x3730 || gameid == 0x474143 || gameid == 0x47434C || gameid == 0x475339)
+		if(company == 0x3431 || company == 0x3730 || TITLE_ID == 0x474143 || TITLE_ID == 0x47434C || TITLE_ID == 0x475339)
 		{	//we can patch the loader in this case, that works for some reason
 			dbgprintf("Game is resetting to original loader, using original\n");
 			PatchState = PATCH_STATE_PATCH;
Index: kernel/DI.h
===================================================================
--- kernel/DI.h	(revision 334)
+++ kernel/DI.h	(working copy)
@@ -33,9 +33,6 @@
 #define		DIP_IMM		(DIP_BASE+0x20)
 #define		DIP_CONFIG	(DIP_BASE+0x24)
 
-#define		DIP_CMD_NORMAL	0xA8
-#define		DIP_CMD_DVDR	0xD0
-
 #define		DMA_READ		3
 #define		IMM_READ		1
 
@@ -72,7 +69,4 @@
 void DIReload(void);
 bool DICheckTGC(u32 Buffer, u32 Length);
 
-void ClearRealDiscBuffer(void);
-u8 *ReadRealDisc(u32 *Length, u32 Offset, bool NeedSync);
-
 #endif
\ No newline at end of file
Index: kernel/diskio.c
===================================================================
--- kernel/diskio.c	(revision 334)
+++ kernel/diskio.c	(working copy)
@@ -1,3 +1,12 @@
+/*-----------------------------------------------------------------------*/
+/* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2016        */
+/*-----------------------------------------------------------------------*/
+/* If a working storage control module is available, it should be        */
+/* attached to the FatFs via a glue function rather than modifying it.   */
+/* This is an example of glue functions to attach various exsisting      */
+/* storage control modules to the FatFs module with a defined API.       */
+/*-----------------------------------------------------------------------*/
+
 #include "diskio.h"
 #include "string.h"
 #include "debug.h"
@@ -8,15 +17,52 @@
 #include "alloc.h"
 #include "common.h"
 
-u32 s_size;
-u32 s_cnt;
+extern bool access_led;
+u32 s_size;	// Sector size.
+u32 s_cnt;	// Sector count.
 
-DRESULT disk_read_sd( BYTE drv, BYTE *buff, DWORD sector, BYTE count )
+
+/*-----------------------------------------------------------------------*/
+/* Get Drive Status                                                      */
+/*-----------------------------------------------------------------------*/
+DSTATUS disk_status (
+	BYTE pdrv		/* Physical drive nmuber to identify the drive */
+)
 {
+	return RES_OK;
+}
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Inidialize a Drive                                                    */
+/*-----------------------------------------------------------------------*/
+
+DSTATUS disk_initialize (
+	BYTE pdrv				/* Physical drive nmuber to identify the drive */
+)
+{
+	/* Nintendont initializes devices outside of FatFS. */
+	return RES_OK;
+}
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Read Sector(s) [SD card]                                              */
+/*-----------------------------------------------------------------------*/
+
+DRESULT disk_read_sd (
+	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
+	BYTE *buff,		/* Data buffer to store read data */
+	DWORD sector,	/* Sector address in LBA */
+	UINT count		/* Number of sectors to read */
+)
+{
 	s32 Retry=10;
 
-	if (ConfigGetConfig(NIN_CFG_LED))
-		set32(HW_GPIO_OUT, GPIO_SLOT_LED);	//turn on drive light
+	//turn on drive led
+	if (access_led) set32(HW_GPIO_OUT, GPIO_SLOT_LED);
 
 	while(1)
 	{
@@ -26,67 +72,118 @@
 		Retry--;
 		if( Retry < 0 )
 		{
-			if (ConfigGetConfig(NIN_CFG_LED))
-				clear32(HW_GPIO_OUT, GPIO_SLOT_LED); //turn off drive light
+			//turn off drive led
+			if (access_led) clear32(HW_GPIO_OUT, GPIO_SLOT_LED);
 			return RES_ERROR;
 		}
 	}
 
-	if (ConfigGetConfig(NIN_CFG_LED))
-		clear32(HW_GPIO_OUT, GPIO_SLOT_LED); //turn off drive light
+	//turn off drive led
+	if (access_led) clear32(HW_GPIO_OUT, GPIO_SLOT_LED);
 
 	return RES_OK;
 }
-// Write Sector(s)
-DRESULT disk_write_sd( BYTE drv, const BYTE *buff, DWORD sector, BYTE count )
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Write Sector(s) [SD card]                                             */
+/*-----------------------------------------------------------------------*/
+
+DRESULT disk_write_sd (
+	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
+	const BYTE *buff,	/* Data to be written */
+	DWORD sector,		/* Sector address in LBA */
+	UINT count			/* Number of sectors to write */
+)
 {
+	//turn on drive led
+	if (access_led) set32(HW_GPIO_OUT, GPIO_SLOT_LED);
+
 	if( sdio_WriteSectors( sector, count, buff ) < 0 )
+	{
+		//turn off drive led
+		if (access_led) clear32(HW_GPIO_OUT, GPIO_SLOT_LED);
 		return RES_ERROR;
+	}
 
+	//turn off drive led
+	if (access_led) clear32(HW_GPIO_OUT, GPIO_SLOT_LED);
+
 	return RES_OK;
 }
 
-DRESULT disk_read_usb(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
+
+
+/*-----------------------------------------------------------------------*/
+/* Read Sector(s) [USB storage]                                          */
+/*-----------------------------------------------------------------------*/
+
+DRESULT disk_read_usb (
+	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
+	BYTE *buff,		/* Data buffer to store read data */
+	DWORD sector,	/* Sector address in LBA */
+	UINT count		/* Number of sectors to read */
+)
 {
-	if (ConfigGetConfig(NIN_CFG_LED))
-		set32(HW_GPIO_OUT, GPIO_SLOT_LED);	//turn on drive light
+	//turn on drive led
+	if (access_led) set32(HW_GPIO_OUT, GPIO_SLOT_LED);
 
 	if(USBStorage_ReadSectors(sector, count, buff) != 1)
 	{
-		if (ConfigGetConfig(NIN_CFG_LED))
-			clear32(HW_GPIO_OUT, GPIO_SLOT_LED); //turn off drive light
+		//turn off drive led
+		if (access_led) clear32(HW_GPIO_OUT, GPIO_SLOT_LED);
 		dbgprintf("USB:Failed to read from USB device... Sector: %d Count: %d dst: %p\r\n", sector, count, buff);
 		return RES_ERROR;
 	}
 
-	if (ConfigGetConfig(NIN_CFG_LED))
-		clear32(HW_GPIO_OUT, GPIO_SLOT_LED); //turn off drive light
+	//turn off drive led
+	if (access_led) clear32(HW_GPIO_OUT, GPIO_SLOT_LED);
 
 	return RES_OK;
 }
 
-DRESULT disk_write_usb(BYTE drv, const BYTE *buff, DWORD sector, BYTE count)
+
+
+/*-----------------------------------------------------------------------*/
+/* Write Sector(s) [USB storage]                                         */
+/*-----------------------------------------------------------------------*/
+
+DRESULT disk_write_usb (
+	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
+	const BYTE *buff,	/* Data to be written */
+	DWORD sector,		/* Sector address in LBA */
+	UINT count			/* Number of sectors to write */
+)
 {
+	//turn on drive led
+	if (access_led) set32(HW_GPIO_OUT, GPIO_SLOT_LED);
+
 	if(USBStorage_WriteSectors(sector, count, buff) != 1)
 	{
+		//turn off drive led
+		if (access_led) clear32(HW_GPIO_OUT, GPIO_SLOT_LED);
+
 		dbgprintf("USB: Failed to write to USB device... Sector: %d Count: %d dst: %p\r\n", sector, count, buff);
 		return RES_ERROR;
 	}
 
-	return RES_OK;
-}
+	//turn off drive led
+	if (access_led) clear32(HW_GPIO_OUT, GPIO_SLOT_LED);
 
-DSTATUS disk_initialize( BYTE drv )
-{
 	return RES_OK;
 }
 
-DSTATUS disk_status( BYTE drv )
-{
-	return RES_OK;
-}
 
-DRESULT disk_ioctl (BYTE pdrv, BYTE cmd, void* buff)
+/*-----------------------------------------------------------------------*/
+/* Miscellaneous Functions                                               */
+/*-----------------------------------------------------------------------*/
+
+DRESULT disk_ioctl (
+	BYTE pdrv,		/* Physical drive nmuber (0..) */
+	BYTE cmd,		/* Control code */
+	void *buff		/* Buffer to send/receive control data */
+)
 {
 	if(cmd == GET_SECTOR_SIZE)
 		*(WORD*)buff = s_size;
@@ -94,8 +191,12 @@
 	return RES_OK;
 }
 
+
+
+// Get the current system time as a FAT timestamp.
 DWORD get_fattime(void)
 {
+	// TODO: Implement this for Nintendont.
 	//rtc_time tm;
 	//DWORD ret;
 
@@ -108,10 +209,16 @@
 	//	| ((DWORD)tm.tm_min << 5)
 	//	| ((DWORD)tm.tm_sec >> 1);
 	//return ret;
-	
+
 	return 0;
 }
 
+
+
+/*-----------------------------------------------------------------------*/
+/* Nintendont: Device type selection.                                    */
+/*-----------------------------------------------------------------------*/
+
 DiskReadFunc disk_read;
 DiskWriteFunc disk_write;
 void SetDiskFunctions(DWORD usb)
Index: kernel/diskio.h
===================================================================
--- kernel/diskio.h	(revision 334)
+++ kernel/diskio.h	(working copy)
@@ -1,24 +1,18 @@
-/*-----------------------------------------------------------------------
-/  Low level disk interface modlue include file  R0.07   (C)ChaN, 2009
-/-----------------------------------------------------------------------
-/ FatFs module is an open source project to implement FAT file system to small
-/ embedded systems. It is opened for education, research and development under
-/ license policy of following trems.
-/
-/  Copyright (C) 2009, ChaN, all right reserved.
-/
-/ * The FatFs module is a free software and there is no warranty.
-/ * You can use, modify and/or redistribute it for personal, non-profit or
-/   commercial use without any restriction under your responsibility.
-/ * Redistributions of source code must retain the above copyright notice.
-/
-/----------------------------------------------------------------------------*/
+/*-----------------------------------------------------------------------/
+/  Low level disk interface modlue include file   (C)ChaN, 2014          /
+/-----------------------------------------------------------------------*/
 // original source: http://elm-chan.org/fsw/ff/00index_e.html
 
-#ifndef _DISKIO
+#ifndef _DISKIO_DEFINED
+#define _DISKIO_DEFINED
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 #include "integer.h"
 
+
 /* Status of Disk Functions */
 typedef BYTE	DSTATUS;
 
@@ -35,18 +29,25 @@
 /*---------------------------------------*/
 /* Prototypes for disk control functions */
 
-void SetDiskFunctions(DWORD);
+DSTATUS disk_initialize (BYTE pdrv);
+DSTATUS disk_status (BYTE pdrv);
+DRESULT disk_ioctl (BYTE pdrv, BYTE cmd, void* buff);
+DWORD get_fattime(void);
 
-typedef DRESULT (*DiskReadFunc)(BYTE, BYTE*, DWORD, BYTE);
-typedef DRESULT (*DiskWriteFunc)(BYTE, const BYTE*, DWORD, BYTE);
-
+/* Nintendont: R/W functions are pointers in order to *
+ * allow support for both SD cards and USB storage.   *
+ * NOTE: This *could* be implemented by using the     *
+ * "Physical Drive Number" (pdrv) parameter.          */
+typedef DRESULT (*DiskReadFunc)(BYTE pdrv, BYTE* buff, DWORD sector, UINT count);
+typedef DRESULT (*DiskWriteFunc)(BYTE pdrv, const BYTE* buff, DWORD sector, UINT count);
 extern DiskReadFunc disk_read;
 extern DiskWriteFunc disk_write;
 
-DSTATUS disk_initialize(BYTE);
-DSTATUS disk_status(BYTE);
-DRESULT disk_ioctl (BYTE pdrv, BYTE cmd, void* buff);
-DWORD get_fattime(void);
+/**
+ * Nintendont: Initialize disk drive functions.
+ * @param usb 1 for USB; 0 for SD.
+ */
+void SetDiskFunctions(DWORD usb);
 
 /* Disk Status Bits (DSTATUS) */
 
@@ -54,6 +55,7 @@
 #define STA_NODISK		0x02	/* No medium in the drive */
 #define STA_PROTECT		0x04	/* Write protected */
 
+
 /* Command code for disk_ioctrl fucntion */
 
 /* Generic command (Used by FatFs) */
@@ -75,6 +77,9 @@
 #define MMC_GET_CID			12	/* Get CID */
 #define MMC_GET_OCR			13	/* Get OCR */
 #define MMC_GET_SDSTAT		14	/* Get SD status */
+#define ISDIO_READ			55	/* Read data form SD iSDIO register */
+#define ISDIO_WRITE			56	/* Write data to SD iSDIO register */
+#define ISDIO_MRITE			57	/* Masked write data to SD iSDIO register */
 
 /* ATA/CF specific ioctl command */
 #define ATA_GET_REV			20	/* Get F/W revision */
@@ -81,5 +86,8 @@
 #define ATA_GET_MODEL		21	/* Get model name */
 #define ATA_GET_SN			22	/* Get serial number */
 
-#define _DISKIO
+#ifdef __cplusplus
+}
 #endif
+
+#endif
Index: kernel/EXI.c
===================================================================
--- kernel/EXI.c	(revision 334)
+++ kernel/EXI.c	(working copy)
@@ -90,7 +90,7 @@
 
 		dbgprintf("Trying to open %s\r\n", MemCardName);
 		ret = f_open_char( &MemCard, MemCardName, FA_READ );
-		if( ret != FR_OK || MemCard.fsize == 0 )
+		if( ret != FR_OK || MemCard.obj.objsize == 0 )
 		{
 #ifdef DEBUG_EXI
 			dbgprintf("EXI: Failed to open %s:%u\r\n", MemCardName, ret );
@@ -104,11 +104,11 @@
 
 		u32 FindBlocks = 0;
 		for (FindBlocks = 0; FindBlocks <= MEM_CARD_MAX; FindBlocks++)
-			if (MEM_CARD_SIZE(FindBlocks) == MemCard.fsize)
+			if (MEM_CARD_SIZE(FindBlocks) == MemCard.obj.objsize)
 				break;
 		if (FindBlocks > MEM_CARD_MAX)
 		{
-			dbgprintf("EXI: Memcard unexpected size %s:%u\r\n", MemCardName, MemCard.fsize );
+			dbgprintf("EXI: Memcard unexpected size %s:%u\r\n", MemCardName, MemCard.obj.objsize );
 			Shutdown();
 		}
 		ConfigSetMemcardBlocks(FindBlocks);
@@ -581,9 +581,9 @@
 		{
 			case IPL_READ_FONT:
 			{
-#ifdef DEBUG_SRAM
-				dbgprintf("EXI: IPLRead( %p, %08X, %u)\r\n", Data, IPLReadOffset, Length );
-#endif
+//#ifdef DEBUG_SRAM
+				dbgprintf("EXI: IPLRead( %p, %08X, %u), No ReadROM Patch?\r\n", Data, IPLReadOffset, Length );
+//#endif
 				EXIReadFontFile(Data, Length);
 			} break;
 			case RTC_READ:
Index: kernel/ff.c
===================================================================
--- kernel/ff.c	(revision 334)
+++ kernel/ff.c	(working copy)
@@ -1,10 +1,10 @@
 /*----------------------------------------------------------------------------/
-/  FatFs - FAT file system module  R0.11                 (C)ChaN, 2015
+/  FatFs - FAT file system module  R0.12                 (C)ChaN, 2016        /
 /-----------------------------------------------------------------------------/
 / FatFs module is a free software that opened under license policy of
 / following conditions.
 /
-/ Copyright (C) 2015, ChaN, all right reserved.
+/ Copyright (C) 2016, ChaN, all right reserved.
 /
 / 1. Redistributions of source code must retain the above copyright notice,
 /    this condition and the following disclaimer.
@@ -26,7 +26,7 @@
 
 ---------------------------------------------------------------------------*/
 
-#if _FATFS != 32020	/* Revision ID */
+#if _FATFS != 88100	/* Revision ID */
 #error Wrong include file (ff.h).
 #endif
 
@@ -57,7 +57,7 @@
 #endif
 
 
-/* Timestamp feature */
+/* Timestamp */
 #if _FS_NORTC == 1
 #if _NORTC_YEAR < 1980 || _NORTC_YEAR > 2107 || _NORTC_MON < 1 || _NORTC_MON > 12 || _NORTC_MDAY < 1 || _NORTC_MDAY > 31
 #error Invalid _FS_NORTC settings
@@ -68,8 +68,8 @@
 #endif
 
 
-/* File access control feature */
-#if _FS_LOCK
+/* File lock controls */
+#if _FS_LOCK != 0
 #if _FS_READONLY
 #error _FS_LOCK must be 0 at read-only configuration
 #endif
@@ -76,7 +76,7 @@
 typedef struct {
 	FATFS *fs;		/* Object ID 1, volume (NULL:blank entry) */
 	DWORD clu;		/* Object ID 2, directory (0:root) */
-	WORD idx;		/* Object ID 3, directory index */
+	DWORD ofs;		/* Object ID 3, directory offset */
 	WORD ctr;		/* Object open counter, 0:none, 0x01..0xFF:read mode open count, 0x100:write mode */
 } FILESEM;
 #endif
@@ -83,7 +83,7 @@
 
 
 
-/* DBCS code ranges and SBCS extend character conversion table */
+/* DBCS code ranges and SBCS upper conversion tables */
 
 #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
 #define _DF1S	0x81	/* DBC 1st byte range 1 start */
@@ -121,156 +121,196 @@
 #define _DS2S	0xA1
 #define _DS2E	0xFE
 
-#elif _CODE_PAGE == 437	/* U.S. (OEM) */
+#elif _CODE_PAGE == 437	/* U.S. */
 #define _DF1S	0
-#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
-				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+#define _EXCVT {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
+				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 
-#elif _CODE_PAGE == 720	/* Arabic (OEM) */
+#elif _CODE_PAGE == 720	/* Arabic */
 #define _DF1S	0
-#define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
-				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
+				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 
-#elif _CODE_PAGE == 737	/* Greek (OEM) */
+#elif _CODE_PAGE == 737	/* Greek */
 #define _DF1S	0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
-				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
+				0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
+				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xEF,0xF5,0xF0,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 
-#elif _CODE_PAGE == 775	/* Baltic (OEM) */
+#elif _CODE_PAGE == 771	/* KBL */
 #define _DF1S	0
-#define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
-				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
+				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDC,0xDE,0xDE, \
+				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFE,0xFF}
 
-#elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
+#elif _CODE_PAGE == 775	/* Baltic */
 #define _DF1S	0
-#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
-				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+#define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F, \
+				0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 
-#elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
+#elif _CODE_PAGE == 850	/* Latin 1 */
 #define _DF1S	0
-#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
-				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
+#define _EXCVT {0x43,0x55,0x45,0x41,0x41,0x41,0x41,0x43,0x45,0x45,0x45,0x49,0x49,0x49,0x41,0x41, \
+				0x45,0x92,0x92,0x4F,0x4F,0x4F,0x55,0x55,0x59,0x4F,0x55,0x4F,0x9C,0x4F,0x9E,0x9F, \
+				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0x41,0x41,0x41,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0x41,0x41,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD1,0xD1,0x45,0x45,0x45,0x49,0x49,0x49,0x49,0xD9,0xDA,0xDB,0xDC,0xDD,0x49,0xDF, \
+				0x4F,0xE1,0x4F,0x4F,0x4F,0x4F,0xE6,0xE8,0xE8,0x55,0x55,0x55,0x59,0x59,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 
-#elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
+#elif _CODE_PAGE == 852	/* Latin 2 */
 #define _DF1S	0
-#define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
-				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
-				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
+#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F, \
+				0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0xAC, \
+				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
 
-#elif _CODE_PAGE == 857	/* Turkish (OEM) */
+#elif _CODE_PAGE == 855	/* Cyrillic */
 #define _DF1S	0
-#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
-				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+#define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F, \
+				0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
+				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
+				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF, \
+				0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
 
-#elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
+#elif _CODE_PAGE == 857	/* Turkish */
 #define _DF1S	0
-#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
-				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x49,0x8E,0x8F, \
+				0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
+				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0x49,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 
-#elif _CODE_PAGE == 862	/* Hebrew (OEM) */
+#elif _CODE_PAGE == 860	/* Portuguese */
 #define _DF1S	0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
-				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+#define _EXCVT {0x80,0x9A,0x90,0x8F,0x8E,0x91,0x86,0x80,0x89,0x89,0x92,0x8B,0x8C,0x98,0x8E,0x8F, \
+				0x90,0x91,0x92,0x8C,0x99,0xA9,0x96,0x9D,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x86,0x8B,0x9F,0x96,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 
-#elif _CODE_PAGE == 866	/* Russian (OEM) */
+#elif _CODE_PAGE == 861	/* Icelandic */
 #define _DF1S	0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
-				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x8B,0x8B,0x8D,0x8E,0x8F, \
+				0x90,0x92,0x92,0x4F,0x99,0x8D,0x55,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
+				0xA4,0xA5,0xA6,0xA7,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 
-#elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
+#elif _CODE_PAGE == 862	/* Hebrew */
 #define _DF1S	0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
-				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
+				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 
-#elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
+#elif _CODE_PAGE == 863	/* Canadian-French */
 #define _DF1S	0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
-				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
+#define _EXCVT {0x43,0x55,0x45,0x41,0x41,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x41,0x8F, \
+				0x45,0x45,0x45,0x4F,0x45,0x49,0x55,0x55,0x98,0x4F,0x55,0x9B,0x9C,0x55,0x55,0x9F, \
+				0xA0,0xA1,0x4F,0x55,0xA4,0xA5,0xA6,0xA7,0x49,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 
-#elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
+#elif _CODE_PAGE == 864	/* Arabic */
 #define _DF1S	0
-#define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
-				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
+#define _EXCVT {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
+				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 
-#elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
+#elif _CODE_PAGE == 865	/* Nordic */
 #define _DF1S	0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
-				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
+#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
+				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
+				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 
-#elif _CODE_PAGE == 1253 /* Greek (Windows) */
+#elif _CODE_PAGE == 866	/* Russian */
 #define _DF1S	0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
-				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
-				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
+				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 
-#elif _CODE_PAGE == 1254 /* Turkish (Windows) */
+#elif _CODE_PAGE == 869	/* Greek 2 */
 #define _DF1S	0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
-				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
+				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x86,0x9C,0x8D,0x8F,0x90, \
+				0x91,0x90,0x92,0x95,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
+				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
+				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xA4,0xA5,0xA6,0xD9,0xDA,0xDB,0xDC,0xA7,0xA8,0xDF, \
+				0xA9,0xAA,0xAC,0xAD,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xCF,0xCF,0xD0,0xEF, \
+				0xF0,0xF1,0xD1,0xD2,0xD3,0xF5,0xD4,0xF7,0xF8,0xF9,0xD5,0x96,0x95,0x98,0xFE,0xFF}
 
-#elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
-#define _DF1S	0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
-				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
-
-#elif _CODE_PAGE == 1256 /* Arabic (Windows) */
-#define _DF1S	0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
-				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
-
-#elif _CODE_PAGE == 1257 /* Baltic (Windows) */
-#define _DF1S	0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
-				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
-
-#elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
-#define _DF1S	0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
-				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
-
 #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
-#if _USE_LFN
-#error Cannot use LFN feature without valid code page.
+#if _USE_LFN != 0
+#error Cannot enable LFN without valid code page.
 #endif
 #define _DF1S	0
 
@@ -285,7 +325,7 @@
 #define IsLower(c)	(((c)>='a')&&((c)<='z'))
 #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
 
-#if _DF1S		/* Code page is DBCS */
+#if _DF1S != 0	/* Code page is DBCS */
 
 #ifdef _DF2S	/* Two 1st byte areas */
 #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
@@ -315,73 +355,122 @@
 #define NS_BODY		0x08	/* Lower case flag (body) */
 #define NS_EXT		0x10	/* Lower case flag (ext) */
 #define NS_DOT		0x20	/* Dot entry */
+#define NS_NONAME	0x80	/* Not followed */
 
 
-/* FAT sub-type boundaries (Differ from specs but correct for real DOS/Windows) */
-#define MIN_FAT16	4086U	/* Minimum number of clusters as FAT16 */
-#define	MIN_FAT32	65526U	/* Minimum number of clusters as FAT32 */
+/* Limits and Boundaries (Differ from specs but correct for real DOS/Windows) */
+#define MIN_FAT16	4086U			/* Minimum number of clusters of FAT16 */
+#define	MIN_FAT32	65526U			/* Minimum number of clusters of FAT32 */
+#define MAX_DIR		0x200000		/* Maximum size of FAT directory */
+#define MAX_DIR_EX	0x10000000		/* Maximum size of exFAT directory */
 
 
 /* FatFs refers the members in the FAT structures as byte array instead of
-/ structure member because the structure is not binary compatible between
+/ structure members because the structure is not binary compatible between
 / different platforms */
 
-#define BS_jmpBoot			0		/* x86 jump instruction (3) */
-#define BS_OEMName			3		/* OEM name (8) */
-#define BPB_BytsPerSec		11		/* Sector size [byte] (2) */
-#define BPB_SecPerClus		13		/* Cluster size [sector] (1) */
-#define BPB_RsvdSecCnt		14		/* Size of reserved area [sector] (2) */
-#define BPB_NumFATs			16		/* Number of FAT copies (1) */
-#define BPB_RootEntCnt		17		/* Number of root directory entries for FAT12/16 (2) */
-#define BPB_TotSec16		19		/* Volume size [sector] (2) */
-#define BPB_Media			21		/* Media descriptor (1) */
-#define BPB_FATSz16			22		/* FAT size [sector] (2) */
-#define BPB_SecPerTrk		24		/* Track size [sector] (2) */
-#define BPB_NumHeads		26		/* Number of heads (2) */
-#define BPB_HiddSec			28		/* Number of special hidden sectors (4) */
-#define BPB_TotSec32		32		/* Volume size [sector] (4) */
-#define BS_DrvNum			36		/* Physical drive number (2) */
-#define BS_BootSig			38		/* Extended boot signature (1) */
-#define BS_VolID			39		/* Volume serial number (4) */
-#define BS_VolLab			43		/* Volume label (8) */
-#define BS_FilSysType		54		/* File system type (1) */
-#define BPB_FATSz32			36		/* FAT size [sector] (4) */
-#define BPB_ExtFlags		40		/* Extended flags (2) */
-#define BPB_FSVer			42		/* File system version (2) */
-#define BPB_RootClus		44		/* Root directory first cluster (4) */
-#define BPB_FSInfo			48		/* Offset of FSINFO sector (2) */
-#define BPB_BkBootSec		50		/* Offset of backup boot sector (2) */
-#define BS_DrvNum32			64		/* Physical drive number (2) */
-#define BS_BootSig32		66		/* Extended boot signature (1) */
-#define BS_VolID32			67		/* Volume serial number (4) */
-#define BS_VolLab32			71		/* Volume label (8) */
-#define BS_FilSysType32		82		/* File system type (1) */
-#define	FSI_LeadSig			0		/* FSI: Leading signature (4) */
-#define	FSI_StrucSig		484		/* FSI: Structure signature (4) */
-#define	FSI_Free_Count		488		/* FSI: Number of free clusters (4) */
-#define	FSI_Nxt_Free		492		/* FSI: Last allocated cluster (4) */
-#define MBR_Table			446		/* MBR: Partition table offset (2) */
+#define BS_jmpBoot			0		/* x86 jump instruction (3-byte) */
+#define BS_OEMName			3		/* OEM name (8-byte) */
+#define BPB_BytsPerSec		11		/* Sector size [byte] (WORD) */
+#define BPB_SecPerClus		13		/* Cluster size [sector] (BYTE) */
+#define BPB_RsvdSecCnt		14		/* Size of reserved area [sector] (WORD) */
+#define BPB_NumFATs			16		/* Number of FATs (BYTE) */
+#define BPB_RootEntCnt		17		/* Size of root directory area for FAT12/16 [entry] (WORD) */
+#define BPB_TotSec16		19		/* Volume size (16-bit) [sector] (WORD) */
+#define BPB_Media			21		/* Media descriptor (BYTE) */
+#define BPB_FATSz16			22		/* FAT size (16-bit) [sector] (WORD) */
+#define BPB_SecPerTrk		24		/* Track size for int13h [sector] (WORD) */
+#define BPB_NumHeads		26		/* Number of heads for int13h (WORD) */
+#define BPB_HiddSec			28		/* Volume offset from top of the drive (DWORD) */
+#define BPB_TotSec32		32		/* Volume size (32-bit) [sector] (DWORD) */
+#define BS_DrvNum			36		/* Physical drive number for int13h (BYTE) */
+#define BS_NTres			37		/* Error flag (BYTE) */
+#define BS_BootSig			38		/* Extended boot signature (BYTE) */
+#define BS_VolID			39		/* Volume serial number (DWORD) */
+#define BS_VolLab			43		/* Volume label string (8-byte) */
+#define BS_FilSysType		54		/* File system type string (8-byte) */
+#define BPB_FATSz32			36		/* FAT size (32-bit) [sector] (DWORD) */
+#define BPB_ExtFlags		40		/* Extended flags (WORD) */
+
+#define BPB_FSVer32			42		/* FAT32: File system version (WORD) */
+#define BPB_RootClus32		44		/* FAT32: Root directory cluster (DWORD) */
+#define BPB_FSInfo32		48		/* FAT32: Offset of FSINFO sector (WORD) */
+#define BPB_BkBootSec32		50		/* FAT32: Offset of backup boot sector (WORD) */
+#define BS_DrvNum32			64		/* FAT32: Physical drive number for int13h (BYTE) */
+#define BS_NTres32			65		/* FAT32: Error flag (BYTE) */
+#define BS_BootSig32		66		/* FAT32: Extended boot signature (BYTE) */
+#define BS_VolID32			67		/* FAT32: Volume serial number (DWORD) */
+#define BS_VolLab32			71		/* FAT32: Volume label string (8-byte) */
+#define BS_FilSysType32		82		/* FAT32: File system type string (8-byte) */
+
+#define BPB_ZeroedEx		11		/* exFAT: Must be zero (35-byte) */
+#define BPB_VolOfsEx		64		/* exFAT: Volume offset from top of the drive [sector] (QWORD) */
+#define BPB_TotSecEx		72		/* exFAT: Volume size [sector] (QWORD) */
+#define BPB_FatOfsEx		80		/* exFAT: FAT offset from top of the volume [sector] (DWORD) */
+#define BPB_FatSzEx			84		/* exFAT: FAT size [sector] (DWORD) */
+#define BPB_DataOfsEx		88		/* exFAT: Data offset from top of the volume [sector] (DWORD) */
+#define BPB_NumClusEx		92		/* exFAT: Number of clusters (DWORD) */
+#define BPB_RootClusEx		96		/* exFAT: Root directory cluster (DWORD) */
+#define BPB_VolIDEx			100		/* exFAT: Volume serial number (DWORD) */
+#define BPB_FSVerEx			104		/* exFAT: File system version (WORD) */
+#define BPB_VolFlagEx		106		/* exFAT: Volume flags (BYTE) */
+#define BPB_ActFatEx		107		/* exFAT: Active FAT flags (BYTE) */
+#define BPB_BytsPerSecEx	108		/* exFAT: Log2 of sector size in byte (BYTE) */
+#define BPB_SecPerClusEx	109		/* exFAT: Log2 of cluster size in sector (BYTE) */
+#define BPB_NumFATsEx		110		/* exFAT: Number of FATs (BYTE) */
+#define BPB_DrvNumEx		111		/* exFAT: Physical drive number for int13h (BYTE) */
+#define BPB_PercInUseEx		112		/* exFAT: Percent in use (BYTE) */
+
+#define	FSI_LeadSig			0		/* FAT32 FSI: Leading signature (DWORD) */
+#define	FSI_StrucSig		484		/* FAT32 FSI: Structure signature (DWORD) */
+#define	FSI_Free_Count		488		/* FAT32 FSI: Number of free clusters (DWORD) */
+#define	FSI_Nxt_Free		492		/* FAT32 FSI: Last allocated cluster (DWORD) */
+
+#define MBR_Table			446		/* MBR: Partition table offset */
 #define	SZ_PTE				16		/* MBR: Size of a partition table entry */
-#define BS_55AA				510		/* Signature word (2) */
 
+#define BS_55AA				510		/* Signature word (WORD) */
+
 #define	DIR_Name			0		/* Short file name (11) */
 #define	DIR_Attr			11		/* Attribute (1) */
 #define	DIR_NTres			12		/* Lower case flag (1) */
-#define DIR_CrtTimeTenth	13		/* Created time sub-second (1) */
+#define DIR_CrtTime10		13		/* Created time sub-second (1) */
 #define	DIR_CrtTime			14		/* Created time (2) */
 #define	DIR_CrtDate			16		/* Created date (2) */
 #define DIR_LstAccDate		18		/* Last accessed date (2) */
-#define	DIR_FstClusHI		20		/* Higher 16-bit of first cluster (2) */
+#define	DIR_FstClusHI		20		/* Higher 16-bit of first cluster (WORD) */
 #define	DIR_WrtTime			22		/* Modified time (2) */
 #define	DIR_WrtDate			24		/* Modified date (2) */
-#define	DIR_FstClusLO		26		/* Lower 16-bit of first cluster (2) */
-#define	DIR_FileSize		28		/* File size (4) */
+#define	DIR_FstClusLO		26		/* Lower 16-bit of first cluster (WORD) */
+#define	DIR_FileSize		28		/* File size (DWORD) */
 #define	LDIR_Ord			0		/* LFN entry order and LLE flag (1) */
 #define	LDIR_Attr			11		/* LFN attribute (1) */
 #define	LDIR_Type			12		/* LFN type (1) */
-#define	LDIR_Chksum			13		/* Sum of corresponding SFN entry */
-#define	LDIR_FstClusLO		26		/* Must be zero (0) */
-#define	SZ_DIRE				32		/* Size of a directory entry */
+#define	LDIR_Chksum			13		/* Checksum of the SFN entry */
+#define	LDIR_FstClusLO		26		/* Must be zero (WORD) */
+#define	XDIR_Type			0		/* Type of exFAT directory entry (BYTE) */
+#define	XDIR_NumLabel		1		/* Number of volume label characters (BYTE) */
+#define	XDIR_Label			2		/* Volume label (11-WORD) */
+#define	XDIR_CaseSum		4		/* Sum of case conversion table (DWORD) */
+#define	XDIR_NumSec			1		/* Number of secondary entries (BYTE) */
+#define	XDIR_SetSum			2		/* Sum of the set of directory entries (WORD) */
+#define	XDIR_Attr			4		/* File attribute (WORD) */
+#define	XDIR_CrtTime		8		/* Created time (4) */
+#define	XDIR_ModTime		12		/* Modified time (4) */
+#define	XDIR_AccTime		16		/* Last accessed time (4) */
+#define	XDIR_CrtTime10		20		/* Created time subsecond (1) */
+#define	XDIR_ModTime10		21		/* Modified time subsecond (1) */
+#define	XDIR_CrtTZ			22		/* Created timezone (1) */
+#define	XDIR_ModTZ			23		/* Modified timezone (1) */
+#define	XDIR_AccTZ			24		/* Last accessed timezone (1) */
+#define	XDIR_GenFlags		33		/* Gneral flags (1) */
+#define	XDIR_NumName		35		/* Number of file name characters (BYTE) */
+#define	XDIR_NameHash		36		/* Hash of file name (WORD) */
+#define XDIR_ValidFileSize	40		/* Valid file size (QWORD) */
+#define	XDIR_FstClus		52		/* First cluster of the File/Directory (DWORD) */
+#define	XDIR_FileSize		56		/* File/Directory size (QWORD) */
+
+#define	SZDIRE				32		/* Size of a directory entry */
 #define	LLEF				0x40	/* Last long entry flag in LDIR_Ord */
 #define	DDEM				0xE5	/* Deleted directory entry mark at DIR_Name[0] */
 #define	RDDEM				0x05	/* Replacement of the character collides with DDEM */
@@ -389,14 +478,17 @@
 
 
 
-/*------------------------------------------------------------*/
-/* Module private work area                                   */
-/*------------------------------------------------------------*/
-/* Remark: Uninitialized variables with static duration are
-/  guaranteed zero/null at start-up. If not, either the linker
-/  or start-up routine being used is out of ANSI-C standard.
-*/
 
+/*--------------------------------------------------------------------------
+
+   Module Private Work Area
+
+---------------------------------------------------------------------------*/
+
+/* Remark: Variables here without initial value shall be guaranteed zero/null
+/  at start-up. If not, either the linker or start-up routine being used is
+/  not compliance with C standard. */
+
 #if _VOLUMES < 1 || _VOLUMES > 9
 #error Wrong _VOLUMES setting
 #endif
@@ -403,42 +495,79 @@
 static FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
 static WORD Fsid;				/* File system mount ID */
 
-#if _FS_RPATH && _VOLUMES >= 2
+#if _FS_RPATH != 0 && _VOLUMES >= 2
 static BYTE CurrVol;			/* Current drive */
 #endif
 
-#if _FS_LOCK
+#if _FS_LOCK != 0
 static FILESEM Files[_FS_LOCK];	/* Open object lock semaphores */
 #endif
 
-#if _USE_LFN == 0			/* Non LFN feature */
-#define	DEFINE_NAMEBUF		BYTE sfn[12]
-#define INIT_BUF(dobj)		(dobj).fn = sfn
-#define	FREE_BUF()
+#if _USE_LFN == 0			/* Non-LFN configuration */
+#define	DEF_NAMBUF			BYTE sfn[12]
+#define INIT_NAMBUF(dobj)	(dobj).fn = sfn
+#define	FREE_NAMBUF()
+#define	DEF_DIRBUF
+#define INIT_DIRBUF(fs)
+#define	FREE_DIRBUF()
 #else
 #if _MAX_LFN < 12 || _MAX_LFN > 255
 #error Wrong _MAX_LFN setting
 #endif
-#if _USE_LFN == 1			/* LFN feature with static working buffer */
-static WCHAR LfnBuf[_MAX_LFN + 1];
-#define	DEFINE_NAMEBUF		BYTE sfn[12]
-#define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
-#define	FREE_BUF()
-#elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
-#define	DEFINE_NAMEBUF		BYTE sfn[12]; WCHAR lbuf[_MAX_LFN + 1]
-#define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
-#define	FREE_BUF()
-#elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
-#define	DEFINE_NAMEBUF		BYTE sfn[12]; WCHAR *lfn
-#define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); (dobj).lfn = lfn; (dobj).fn = sfn; }
-#define	FREE_BUF()			ff_memfree(lfn)
+
+#if _USE_LFN == 1		/* LFN enabled with static working buffer */
+#if _FS_EXFAT
+static BYTE	DirBuf[SZDIRE*19];	/* Directory entry block scratchpad buffer (19 entries in size) */
+#endif
+static WCHAR LfnBuf[_MAX_LFN+1];	/* LFN enabled with static working buffer */
+#define	DEF_NAMBUF		BYTE sfn[12]
+#define INIT_NAMBUF(dj)	{ (dj).fn = sfn; (dj).lfn = LfnBuf; }
+#define	FREE_NAMBUF()
+#define	DEF_DIRBUF
+#define INIT_DIRBUF(fs)
+#define	FREE_DIRBUF()
+
+#elif _USE_LFN == 2 	/* LFN enabled with dynamic working buffer on the stack */
+#if _FS_EXFAT
+#define	DEF_NAMBUF		BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]; BYTE dbuf[SZDIRE*19]
+#define INIT_NAMBUF(dj)	{ (dj).fn = sfn; (dj).lfn = lbuf; (dj).obj.fs->dirbuf = dbuf; }
+#define	FREE_NAMBUF()
+#define	DEF_DIRBUF		BYTE dbuf[SZDIRE*19]
+#define INIT_DIRBUF(fs)	fs->dirbuf = dbuf
+#define	FREE_DIRBUF()
 #else
+#define	DEF_NAMBUF		BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
+#define INIT_NAMBUF(dj)	{ (dj).fn = sfn; (dj).lfn = lbuf; }
+#define	FREE_NAMBUF()
+#define	DEF_DIRBUF
+#define INIT_DIRBUF(fs)
+#define	FREE_DIRBUF()
+#endif
+
+#elif _USE_LFN == 3 	/* LFN enabled with dynamic working buffer on the heap */
+#if _FS_EXFAT
+#define	DEF_NAMBUF		BYTE sfn[12]; WCHAR *lfn
+#define INIT_NAMBUF(dj)	{ lfn = ff_memalloc((_MAX_LFN+1)*2 + SZDIRE*19); if (!lfn) LEAVE_FF((dj).obj.fs, FR_NOT_ENOUGH_CORE); (dj).fn = sfn; (dj).lfn = lfn; (dj).obj.fs->dirbuf = (BYTE*)(lfn+_MAX_LFN+1); }
+#define	FREE_NAMBUF()	ff_memfree(lfn)
+#define	DEF_DIRBUF		BYTE *dirb
+#define INIT_DIRBUF(fs)	{ dirb = ff_memalloc(SZDIRE*19); if (!dirb) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); fs->dirbuf = dirb; }
+#define	FREE_DIRBUF()	ff_memfree(dirb)
+#else
+#define	DEF_NAMBUF		BYTE sfn[12]; WCHAR *lfn
+#define INIT_NAMBUF(dj)	{ lfn = ff_memalloc((_MAX_LFN+1)*2); if (!lfn) LEAVE_FF((dj).obj.fs, FR_NOT_ENOUGH_CORE); (dj).fn = sfn; (dj).lfn = lfn; }
+#define	FREE_NAMBUF()	ff_memfree(lfn)
+#define	DEF_DIRBUF
+#define INIT_DIRBUF(fs)
+#define	FREE_DIRBUF()
+#endif
+
+#else
 #error Wrong _USE_LFN setting
 #endif
 #endif
 
 #ifdef _EXCVT
-static const BYTE ExCvt[] = _EXCVT;	/* Upper conversion table for extended characters */
+static const BYTE ExCvt[] = _EXCVT;	/* Upper conversion table for SBCS extended characters */
 #endif
 
 
@@ -454,6 +583,22 @@
 
 
 /*-----------------------------------------------------------------------*/
+/* Load/Store multi-byte word in the FAT structure                       */
+/*-----------------------------------------------------------------------*/
+
+// Nintendont: Use the old macros from FatFS R0.11a for size and performance reasons.
+#define ld_word(ptr)            (WORD)(((WORD)*((BYTE*)(ptr)+1)<<8)|(WORD)*(BYTE*)(ptr))
+#define ld_dword(ptr)           (DWORD)(((DWORD)*((BYTE*)(ptr)+3)<<24)|((DWORD)*((BYTE*)(ptr)+2)<<16)|((WORD)*((BYTE*)(ptr)+1)<<8)|*(BYTE*)(ptr))
+#define ld_qword(ptr)           (QWORD)ld_dword((BYTE*)(ptr)) |((QWORD)ld_dword((BYTE*)(ptr)+4)<<32)
+#if !_FS_READONLY
+#define st_word(ptr,val)        *(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8)
+#define st_dword(ptr,val)       *(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8); *((BYTE*)(ptr)+2)=(BYTE)((DWORD)(val)>>16); *((BYTE*)(ptr)+3)=(BYTE)((DWORD)(val)>>24)
+#define st_qword(ptr,val)       st_dword((ptr),((val)&0xFFFFFFFFU)); st_dword((((BYTE*)ptr)+4),((val)>>32))
+#endif	/* !_FS_READONLY */
+
+
+
+/*-----------------------------------------------------------------------*/
 /* String functions                                                      */
 /*-----------------------------------------------------------------------*/
 
@@ -463,39 +608,35 @@
 	BYTE *d = (BYTE*)dst;
 	const BYTE *s = (const BYTE*)src;
 
-#if _WORD_ACCESS == 1
-	while (cnt >= sizeof (int)) {
-		*(int*)d = *(int*)s;
-		d += sizeof (int); s += sizeof (int);
-		cnt -= sizeof (int);
+	if (cnt) {
+		do *d++ = *s++; while (--cnt);
 	}
-#endif
-	while (cnt--)
-		*d++ = *s++;
 }
 
-/* Fill memory */
+/* Fill memory block */
 static
 void mem_set (void* dst, int val, UINT cnt) {
 	BYTE *d = (BYTE*)dst;
 
-	while (cnt--)
-		*d++ = (BYTE)val;
+	do *d++ = (BYTE)val; while (--cnt);
 }
 
-/* Compare memory to memory */
+/* Compare memory block */
 static
-int mem_cmp (const void* dst, const void* src, UINT cnt) {
+int mem_cmp (const void* dst, const void* src, UINT cnt) {	/* ZR:same, NZ:different */
 	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
 	int r = 0;
 
-	while (cnt-- && (r = *d++ - *s++) == 0) ;
+	do {
+		r = *d++ - *s++;
+	} while (--cnt && r == 0);
+
 	return r;
 }
 
 /* Check if chr is contained in the string */
 static
-int chk_chr (const char* str, int chr) {
+int chk_chr (const char* str, int chr) {	/* NZ:contained, ZR:not contained */
 	while (*str && *str != chr) str++;
 	return *str;
 }
@@ -522,11 +663,7 @@
 	FRESULT res		/* Result code to be returned */
 )
 {
-	if (fs &&
-		res != FR_NOT_ENABLED &&
-		res != FR_INVALID_DRIVE &&
-		res != FR_INVALID_OBJECT &&
-		res != FR_TIMEOUT) {
+	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 		ff_rel_grant(fs->sobj);
 	}
 }
@@ -538,7 +675,7 @@
 /*-----------------------------------------------------------------------*/
 /* File lock control functions                                           */
 /*-----------------------------------------------------------------------*/
-#if _FS_LOCK
+#if _FS_LOCK != 0
 
 static
 FRESULT chk_lock (	/* Check if the file can be accessed */
@@ -551,15 +688,16 @@
 	/* Search file semaphore table */
 	for (i = be = 0; i < _FS_LOCK; i++) {
 		if (Files[i].fs) {	/* Existing entry */
-			if (Files[i].fs == dp->fs &&	 	/* Check if the object matched with an open object */
-				Files[i].clu == dp->sclust &&
-				Files[i].idx == dp->index) break;
+			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
+				Files[i].clu == dp->obj.sclust &&
+				Files[i].ofs == dp->dptr) break;
 		} else {			/* Blank entry */
 			be = 1;
 		}
 	}
-	if (i == _FS_LOCK)	/* The object is not opened */
+	if (i == _FS_LOCK) {	/* The object is not opened */
 		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
+	}
 
 	/* The object has been opened. Reject any open against writing file and all write mode open */
 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
@@ -586,17 +724,17 @@
 
 
 	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
-		if (Files[i].fs == dp->fs &&
-			Files[i].clu == dp->sclust &&
-			Files[i].idx == dp->index) break;
+		if (Files[i].fs == dp->obj.fs &&
+			Files[i].clu == dp->obj.sclust &&
+			Files[i].ofs == dp->dptr) break;
 	}
 
 	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
 		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
-		Files[i].fs = dp->fs;
-		Files[i].clu = dp->sclust;
-		Files[i].idx = dp->index;
+		Files[i].fs = dp->obj.fs;
+		Files[i].clu = dp->obj.sclust;
+		Files[i].ofs = dp->dptr;
 		Files[i].ctr = 0;
 	}
 
@@ -620,9 +758,9 @@
 	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
 		n = Files[i].ctr;
 		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
-		if (n) n--;					/* Decrement read mode open count */
+		if (n > 0) n--;				/* Decrement read mode open count */
 		Files[i].ctr = n;
-		if (!n) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
+		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 		res = FR_OK;
 	} else {
 		res = FR_INT_ERR;			/* Invalid index nunber */
@@ -652,8 +790,8 @@
 /*-----------------------------------------------------------------------*/
 #if !_FS_READONLY
 static
-FRESULT sync_window (
-	FATFS* fs		/* File system object */
+FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
+	FATFS* fs			/* File system object */
 )
 {
 	DWORD wsect;
@@ -681,9 +819,9 @@
 
 
 static
-FRESULT move_window (
-	FATFS* fs,		/* File system object */
-	DWORD sector	/* Sector number to make appearance in the fs->win[] */
+FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
+	FATFS* fs,			/* File system object */
+	DWORD sector		/* Sector number to make appearance in the fs->win[] */
 )
 {
 	FRESULT res = FR_OK;
@@ -712,7 +850,7 @@
 /*-----------------------------------------------------------------------*/
 #if !_FS_READONLY
 static
-FRESULT sync_fs (	/* FR_OK: successful, FR_DISK_ERR: failed */
+FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
 	FATFS* fs		/* File system object */
 )
 {
@@ -721,23 +859,22 @@
 
 	res = sync_window(fs);
 	if (res == FR_OK) {
-		/* Update FSINFO sector if needed */
+		/* Update FSInfo sector if needed */
 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
-			/* Create FSINFO structure */
+			/* Create FSInfo structure */
 			mem_set(fs->win, 0, SS(fs));
-			ST_WORD(fs->win + BS_55AA, 0xAA55);
-			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
-			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
-			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
-			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
-			/* Write it into the FSINFO sector */
+			st_word(fs->win + BS_55AA, 0xAA55);
+			st_dword(fs->win + FSI_LeadSig, 0x41615252);
+			st_dword(fs->win + FSI_StrucSig, 0x61417272);
+			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
+			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
+			/* Write it into the FSInfo sector */
 			fs->winsect = fs->volbase + 1;
 			disk_write(fs->drv, fs->win, fs->winsect, 1);
 			fs->fsi_flag = 0;
 		}
 		/* Make sure that no pending write process in the physical drive */
-		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
-			res = FR_DISK_ERR;
+		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
 	}
 
 	return res;
@@ -750,9 +887,9 @@
 /*-----------------------------------------------------------------------*/
 /* Get sector# from cluster#                                             */
 /*-----------------------------------------------------------------------*/
-/* Hidden API for hacks and disk tools */
 
-DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
+static
+DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
 	FATFS* fs,		/* File system object */
 	DWORD clst		/* Cluster# to be converted */
 )
@@ -768,19 +905,19 @@
 /*-----------------------------------------------------------------------*/
 /* FAT access - Read value of a FAT entry                                */
 /*-----------------------------------------------------------------------*/
-/* Hidden API for hacks and disk tools */
 
-DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
-	FATFS* fs,	/* File system object */
-	DWORD clst	/* FAT index number (cluster number) to get the value */
+static
+DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
+	_FDID* obj,	/* Corresponding object */
+	DWORD clst	/* Cluster number to get the value */
 )
 {
 	UINT wc, bc;
-	BYTE *p;
 	DWORD val;
+	FATFS *fs = obj->fs;
 
 
-	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
+	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 		val = 1;	/* Internal error */
 
 	} else {
@@ -798,16 +935,37 @@
 
 		case FS_FAT16 :
 			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
-			p = &fs->win[clst * 2 % SS(fs)];
-			val = LD_WORD(p);
+			val = ld_word(&fs->win[clst * 2 % SS(fs)]);
 			break;
 
 		case FS_FAT32 :
 			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
-			p = &fs->win[clst * 4 % SS(fs)];
-			val = LD_DWORD(p) & 0x0FFFFFFF;
+			val = ld_dword(&fs->win[clst * 4 % SS(fs)]) & 0x0FFFFFFF;
 			break;
+#if _FS_EXFAT
+		case FS_EXFAT :
+			if (obj->objsize) {
+				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
+				DWORD clen = (DWORD)((obj->objsize - 1) / SS(fs)) / fs->csize;	/* Number of clusters - 1 */
 
+				if (obj->stat == 2) {	/* Is there no valid chain on the FAT? */
+					if (cofs <= clen) {
+						val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* Generate the value */
+						break;
+					}
+				}
+				if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the contiguous part? */
+					val = clst + 1; 	/* Generate the value */
+					break;
+				}
+				if (obj->stat != 2) {	/* Get value from FAT if FAT chain is valid */
+					if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
+					val = ld_dword(&fs->win[clst * 4 % SS(fs)]) & 0x7FFFFFFF;
+					break;
+				}
+			}
+			/* Go default */
+#endif
 		default:
 			val = 1;	/* Internal error */
 		}
@@ -822,26 +980,23 @@
 /*-----------------------------------------------------------------------*/
 /* FAT access - Change value of a FAT entry                              */
 /*-----------------------------------------------------------------------*/
-/* Hidden API for hacks and disk tools */
 
 #if !_FS_READONLY
-FRESULT put_fat (
-	FATFS* fs,	/* File system object */
-	DWORD clst,	/* FAT index number (cluster number) to be changed */
-	DWORD val	/* New value to be set to the entry */
+static
+FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
+	FATFS* fs,		/* Corresponding object */
+	DWORD clst,		/* FAT index number (cluster number) to be changed */
+	DWORD val		/* New value to be set to the entry */
 )
 {
 	UINT bc;
 	BYTE *p;
-	FRESULT res;
+	FRESULT res = FR_INT_ERR;
 
 
-	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
-		res = FR_INT_ERR;
-
-	} else {
+	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 		switch (fs->fs_type) {
-		case FS_FAT12 :
+		case FS_FAT12 :	/* Bitfield items */
 			bc = (UINT)clst; bc += bc / 2;
 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 			if (res != FR_OK) break;
@@ -855,28 +1010,27 @@
 			fs->wflag = 1;
 			break;
 
-		case FS_FAT16 :
+		case FS_FAT16 :	/* WORD aligned items */
 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 			if (res != FR_OK) break;
-			p = &fs->win[clst * 2 % SS(fs)];
-			ST_WORD(p, (WORD)val);
+			st_word(&fs->win[clst * 2 % SS(fs)], (WORD)val);
 			fs->wflag = 1;
 			break;
 
-		case FS_FAT32 :
+		case FS_FAT32 :	/* DWORD aligned items */
+#if _FS_EXFAT
+		case FS_EXFAT :
+#endif
 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 			if (res != FR_OK) break;
-			p = &fs->win[clst * 4 % SS(fs)];
-			val |= LD_DWORD(p) & 0xF0000000;
-			ST_DWORD(p, val);
+			if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
+				val = (val & 0x0FFFFFFF) | (ld_dword(&fs->win[clst * 4 % SS(fs)]) & 0xF0000000);
+			}
+			st_dword(&fs->win[clst * 4 % SS(fs)], val);
 			fs->wflag = 1;
 			break;
-
-		default :
-			res = FR_INT_ERR;
 		}
 	}
-
 	return res;
 }
 #endif /* !_FS_READONLY */
@@ -884,53 +1038,186 @@
 
 
 
+#if _FS_EXFAT && !_FS_READONLY
 /*-----------------------------------------------------------------------*/
+/* exFAT: Accessing FAT and Allocation Bitmap                            */
+/*-----------------------------------------------------------------------*/
+
+/*---------------------------------------------*/
+/* exFAT: Find a contiguous free cluster block */
+/*---------------------------------------------*/
+static
+DWORD find_bitmap (	/* 0:No free cluster, 2..:Free cluster found, 0xFFFFFFFF:Disk error */
+	FATFS* fs,	/* File system object */
+	DWORD clst,	/* Cluster number to scan from */
+	DWORD ncl	/* Number of contiguous clusters to find (1..) */
+)
+{
+	BYTE bm, bv;
+	UINT i;
+	DWORD val, scl, ctr;
+
+
+	clst -= 2;	/* The first bit in the bitmap corresponds to cluster #2 */
+	if (clst >= fs->n_fatent - 2) clst = 0;
+	scl = val = clst; ctr = 0;
+	for (;;) {
+		if (move_window(fs, fs->database + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;
+		i = val / 8 & (SS(fs) - 1); bm = 1 << (val % 8);
+		do {
+			do {
+				bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
+				if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
+					val = 0; bm = 0; i = 4096;
+				}
+				if (!bv) {	/* Is it a free cluster? */
+					if (++ctr == ncl) return scl + 2;	/* Check run length */
+				} else {
+					scl = val; ctr = 0;		/* Encountered a live cluster, restart to scan */
+				}
+				if (val == clst) return 0;	/* All cluster scanned? */
+			} while (bm);
+			bm = 1;
+		} while (++i < SS(fs));
+	}
+}
+
+/*------------------------------------*/
+/* exFAT: Set/Clear a block of bitmap */
+/*------------------------------------*/
+static
+FRESULT change_bitmap (
+	FATFS* fs,	/* File system object */
+	DWORD clst,	/* Cluster number to change from */
+	DWORD ncl,	/* Number of clusters to be changed */
+	int bv		/* bit value to be set (0 or 1) */
+)
+{
+	BYTE bm;
+	UINT i;
+	DWORD sect;
+
+
+	clst -= 2;	/* The first bit corresponds to cluster #2 */
+	sect = fs->database + clst / 8 / SS(fs);	/* Sector address */
+	i = clst / 8 & (SS(fs) - 1);				/* Byte offset in the sector */
+	bm = 1 << (clst % 8);						/* Bit mask in the byte */
+	for (;;) {
+		if (move_window(fs, sect++) != FR_OK) return FR_DISK_ERR;
+		do {
+			do {
+				if (bv == (int)((fs->win[i] & bm) != 0)) return FR_INT_ERR;	/* Is the bit expected value? */
+				fs->win[i] ^= bm;	/* Flip the bit */
+				fs->wflag = 1;
+				if (--ncl == 0) return FR_OK;	/* All bits processed? */
+			} while (bm <<= 1);		/* Next bit */
+			bm = 1;
+		} while (++i < SS(fs));		/* Next byte */
+	}
+}
+
+
+/*---------------------------------------------*/
+/* Complement contiguous part of the FAT chain */
+/*---------------------------------------------*/
+static
+FRESULT fill_fat_chain (
+	_FDID* obj	/* Pointer to the corresponding object */
+)
+{
+	FRESULT res;
+	DWORD cl, n;
+
+	if (obj->stat == 3) {	/* Has the object got fragmented? */
+		for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {	/* Create cluster chain on the FAT */
+			res = put_fat(obj->fs, cl, cl + 1);
+			if (res != FR_OK) return res;
+		}
+		obj->stat = 0;	/* Change status 'FAT chain is valid' */
+	}
+	return FR_OK;
+}
+
+#endif
+
+
+
+/*-----------------------------------------------------------------------*/
 /* FAT handling - Remove a cluster chain                                 */
 /*-----------------------------------------------------------------------*/
 #if !_FS_READONLY
 static
-FRESULT remove_chain (
-	FATFS* fs,			/* File system object */
-	DWORD clst			/* Cluster# to remove a chain from */
+FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
+	_FDID* obj,			/* Corresponding object */
+	DWORD clst,			/* Cluster to remove a chain from */
+	DWORD pclst			/* Previous cluster of clst (0:an entire chain) */
 )
 {
-	FRESULT res;
+	FRESULT res = FR_OK;
 	DWORD nxt;
+	FATFS *fs = obj->fs;
+#if _FS_EXFAT || _USE_TRIM
+	DWORD scl = clst, ecl = clst;
+#endif
 #if _USE_TRIM
-	DWORD scl = clst, ecl = clst, rt[2];
+	DWORD rt[2];
 #endif
 
-	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
-		res = FR_INT_ERR;
+	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 
-	} else {
-		res = FR_OK;
-		while (clst < fs->n_fatent) {			/* Not a last link? */
-			nxt = get_fat(fs, clst);			/* Get cluster status */
-			if (nxt == 0) break;				/* Empty cluster? */
-			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
-			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
-			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
-			if (res != FR_OK) break;
-			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
-				fs->free_clust++;
-				fs->fsi_flag |= 1;
+	/* Mark the previous cluster 'EOC' on the FAT if it exists */
+	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
+		res = put_fat(fs, pclst, 0xFFFFFFFF);
+		if (res != FR_OK) return res;
+	}
+
+	/* Remove the chain */
+	do {
+		nxt = get_fat(obj, clst);			/* Get cluster status */
+		if (nxt == 0) break;				/* Empty cluster? */
+		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
+		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
+		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
+			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
+			if (res != FR_OK) return res;
+		}
+		if (fs->free_clst != 0xFFFFFFFF) {	/* Update FSINFO */
+			fs->free_clst++;
+			fs->fsi_flag |= 1;
+		}
+#if _FS_EXFAT || _USE_TRIM
+		if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
+			ecl = nxt;
+		} else {				/* End of contiguous cluster block */ 
+#if _FS_EXFAT
+			if (fs->fs_type == FS_EXFAT) {
+				res = change_bitmap(fs, scl, ecl - scl + 1, 0);	/* Mark the cluster block 'free' on the bitmap */
+				if (res != FR_OK) return res;
 			}
+#endif
 #if _USE_TRIM
-			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
-				ecl = nxt;
-			} else {				/* End of contiguous clusters */ 
-				rt[0] = clust2sect(fs, scl);					/* Start sector */
-				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
-				disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Erase the block */
-				scl = ecl = nxt;
-			}
+			rt[0] = clust2sect(fs, scl);					/* Start sector */
+			rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
+			disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Inform device the block can be erased */
 #endif
-			clst = nxt;	/* Next cluster */
+			scl = ecl = nxt;
 		}
+#endif
+		clst = nxt;					/* Next cluster */
+	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
+
+#if _FS_EXFAT
+	if (fs->fs_type == FS_EXFAT) {
+		if (pclst == 0) {	/* Does object have no chain? */
+			obj->stat = 0;		/* Change the object status 'initial' */
+		} else {
+			if (obj->stat == 3 && pclst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) {	/* Did the chain got contiguous? */
+				obj->stat = 2;	/* Change the object status 'contiguous' */
+			}
+		}
 	}
-
-	return res;
+#endif
+	return FR_OK;
 }
 #endif
 
@@ -938,60 +1225,82 @@
 
 
 /*-----------------------------------------------------------------------*/
-/* FAT handling - Stretch or Create a cluster chain                      */
+/* FAT handling - Stretch a chain or Create a new chain                  */
 /*-----------------------------------------------------------------------*/
 #if !_FS_READONLY
 static
 DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
-	FATFS* fs,			/* File system object */
-	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
+	_FDID* obj,			/* Corresponding object */
+	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
 )
 {
 	DWORD cs, ncl, scl;
 	FRESULT res;
+	FATFS *fs = obj->fs;
 
 
-	if (clst == 0) {		/* Create a new chain */
-		scl = fs->last_clust;			/* Get suggested start point */
-		if (!scl || scl >= fs->n_fatent) scl = 1;
+	if (clst == 0) {	/* Create a new chain */
+		scl = fs->last_clst;				/* Get suggested cluster to start at */
+		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 	}
-	else {					/* Stretch the current chain */
-		cs = get_fat(fs, clst);			/* Check the cluster status */
-		if (cs < 2) return 1;			/* Invalid value */
+	else {				/* Stretch current chain */
+		cs = get_fat(obj, clst);			/* Check the cluster status */
+		if (cs < 2) return 1;				/* Invalid value */
 		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
 		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 		scl = clst;
 	}
 
-	ncl = scl;				/* Start cluster */
-	for (;;) {
-		ncl++;							/* Next cluster */
-		if (ncl >= fs->n_fatent) {		/* Check wrap around */
-			ncl = 2;
-			if (ncl > scl) return 0;	/* No free cluster */
+#if _FS_EXFAT
+	if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
+		ncl = find_bitmap(fs, scl, 1);				/* Find a free cluster */
+		if (ncl == 0 || ncl == 0xFFFFFFFF) return ncl;	/* No free cluster or hard error? */
+		res = change_bitmap(fs, ncl, 1, 1);			/* Mark the cluster 'in use' */
+		if (res == FR_INT_ERR) return 1;
+		if (res == FR_DISK_ERR) return 0xFFFFFFFF;
+		if (clst == 0) {							/* Is it a new chain? */
+			obj->stat = 2;							/* Set status 'contiguous chain' */
+		} else {									/* This is a stretched chain */
+			if (obj->stat == 2 && ncl != scl + 1) {	/* Is the chain got fragmented? */
+				obj->n_cont = scl - obj->sclust;	/* Set size of the contiguous part */
+				obj->stat = 3;						/* Change status 'just fragmented' */
+			}
 		}
-		cs = get_fat(fs, ncl);			/* Get the cluster status */
-		if (cs == 0) break;				/* Found a free cluster */
-		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
-			return cs;
-		if (ncl == scl) return 0;		/* No free cluster */
+	} else
+#endif
+	{	/* At the FAT12/16/32 */
+		ncl = scl;	/* Start cluster */
+		for (;;) {
+			ncl++;							/* Next cluster */
+			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
+				ncl = 2;
+				if (ncl > scl) return 0;	/* No free cluster */
+			}
+			cs = get_fat(obj, ncl);			/* Get the cluster status */
+			if (cs == 0) break;				/* Found a free cluster */
+			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
+			if (ncl == scl) return 0;		/* No free cluster */
+		}
 	}
 
-	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
-	if (res == FR_OK && clst != 0) {
-		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
+	if (_FS_EXFAT && fs->fs_type == FS_EXFAT && obj->stat == 2) {	/* Is it a contiguous chain? */
+		res = FR_OK;						/* FAT does not need to be written */
+	} else {
+		res = put_fat(fs, ncl, 0xFFFFFFFF);	/* Mark the new cluster 'EOC' */
+		if (res == FR_OK && clst) {
+			res = put_fat(fs, clst, ncl);	/* Link it from the previous one if needed */
+		}
 	}
-	if (res == FR_OK) {
-		fs->last_clust = ncl;			/* Update FSINFO */
-		if (fs->free_clust != 0xFFFFFFFF) {
-			fs->free_clust--;
-			fs->fsi_flag |= 1;
-		}
+
+	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
+		fs->last_clst = ncl;
+		if (fs->free_clst < fs->n_fatent - 2) fs->free_clst--;
+		fs->fsi_flag |= 1;
 	} else {
-		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
+		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Create error status */
 	}
 
-	return ncl;		/* Return new cluster number or error code */
+	return ncl;		/* Return new cluster number or error status */
 }
 #endif /* !_FS_READONLY */
 
@@ -1006,17 +1315,18 @@
 static
 DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
 	FIL* fp,		/* Pointer to the file object */
-	DWORD ofs		/* File offset to be converted to cluster# */
+	FSIZE_t ofs		/* File offset to be converted to cluster# */
 )
 {
 	DWORD cl, ncl, *tbl;
+	FATFS *fs = fp->obj.fs;
 
 
 	tbl = fp->cltbl + 1;	/* Top of CLMT */
-	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
+	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 	for (;;) {
 		ncl = *tbl++;			/* Number of cluters in the fragment */
-		if (!ncl) return 0;		/* End of table? (error) */
+		if (ncl == 0) return 0;	/* End of table? (error) */
 		if (cl < ncl) break;	/* In this fragment? */
 		cl -= ncl; tbl++;		/* Next fragment */
 	}
@@ -1026,48 +1336,48 @@
 
 
 
-
 /*-----------------------------------------------------------------------*/
 /* Directory handling - Set directory index                              */
 /*-----------------------------------------------------------------------*/
 
 static
-FRESULT dir_sdi (
+FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
 	DIR* dp,		/* Pointer to directory object */
-	UINT idx		/* Index of directory table */
+	DWORD ofs		/* Offset of directory table */
 )
 {
-	DWORD clst, sect;
-	UINT ic;
+	DWORD csz, clst;
+	FATFS *fs = dp->obj.fs;
 
 
-	dp->index = (WORD)idx;	/* Current index */
-	clst = dp->sclust;		/* Table start cluster (0:root) */
-	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
+	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 		return FR_INT_ERR;
-	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
-		clst = dp->fs->dirbase;
+	}
+	dp->dptr = ofs;				/* Set current offset */
+	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
+	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
+		clst = fs->dirbase;
+		if (_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
+	}
 
 	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
-		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
-			return FR_INT_ERR;
-		sect = dp->fs->dirbase;
-	}
-	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
-		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
-		while (idx >= ic) {	/* Follow cluster chain */
-			clst = get_fat(dp->fs, clst);				/* Get next cluster */
+		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
+		dp->sect = fs->dirbase;
+
+	} else {			/* Dynamic table (sub-directory or root-directory in FAT32+) */
+		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
+		while (ofs >= csz) {				/* Follow cluster chain */
+			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
-			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
-				return FR_INT_ERR;
-			idx -= ic;
+			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
+			ofs -= csz;
 		}
-		sect = clust2sect(dp->fs, clst);
+		dp->sect = clust2sect(fs, clst);
 	}
-	dp->clust = clst;	/* Current cluster# */
-	if (!sect) return FR_INT_ERR;
-	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
-	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
+	dp->clust = clst;					/* Current cluster# */
+	if (!dp->sect) return FR_INT_ERR;
+	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
+	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 
 	return FR_OK;
 }
@@ -1080,65 +1390,64 @@
 /*-----------------------------------------------------------------------*/
 
 static
-FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
+FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
 	DIR* dp,		/* Pointer to the directory object */
 	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
 )
 {
-	DWORD clst;
-	UINT i;
+	DWORD ofs, clst;
+	FATFS *fs = dp->obj.fs;
 #if !_FS_READONLY
-	UINT c;
+	UINT n;
 #endif
 
+	ofs = dp->dptr + SZDIRE;	/* Next entry */
+	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 
-	i = dp->index + 1;
-	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
-		return FR_NO_FILE;
+	if (ofs % SS(fs) == 0) {	/* Sector changed? */
+		dp->sect++;				/* Next sector */
 
-	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
-		dp->sect++;					/* Next sector */
-
 		if (!dp->clust) {		/* Static table */
-			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
-				return FR_NO_FILE;
+			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
+				dp->sect = 0; return FR_NO_FILE;
+			}
 		}
 		else {					/* Dynamic table */
-			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
-				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
-				if (clst <= 1) return FR_INT_ERR;
-				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
-				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
+			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
+				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
+				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
+				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
+				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 #if !_FS_READONLY
-					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
-					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
+					if (!stretch) {								/* If no stretch, report EOT */
+						dp->sect = 0; return FR_NO_FILE;
+					}
+					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 					if (clst == 0) return FR_DENIED;			/* No free cluster */
-					if (clst == 1) return FR_INT_ERR;
-					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
-					/* Clean-up stretched table */
-					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
-					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
-					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
-					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
-						dp->fs->wflag = 1;
-						if (sync_window(dp->fs)) return FR_DISK_ERR;
-						dp->fs->winsect++;
+					if (clst == 1) return FR_INT_ERR;			/* Internal error */
+					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
+					/* Clean-up the stretched table */
+					if (_FS_EXFAT) dp->obj.stat |= 4;			/* The directory needs to be updated */
+					if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
+					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
+					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
+						fs->wflag = 1;
+						if (sync_window(fs) != FR_OK) return FR_DISK_ERR;
 					}
-					dp->fs->winsect -= c;						/* Rewind window offset */
+					fs->winsect -= n;							/* Restore window offset */
 #else
-					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
-					return FR_NO_FILE;							/* Report EOT */
+					if (!stretch) dp->sect = 0;					/* If no stretch, report EOT (this is to suppress warning) */
+					dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
 #endif
 				}
-				dp->clust = clst;				/* Initialize data for new cluster */
-				dp->sect = clust2sect(dp->fs, clst);
+				dp->clust = clst;		/* Initialize data for new cluster */
+				dp->sect = clust2sect(fs, clst);
 			}
 		}
 	}
+	dp->dptr = ofs;						/* Current entry */
+	dp->dir = &fs->win[ofs % SS(fs)];	/* Pointer to the entry in the win[] */
 
-	dp->index = (WORD)i;	/* Current index */
-	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
-
 	return FR_OK;
 }
 
@@ -1146,18 +1455,19 @@
 
 
 /*-----------------------------------------------------------------------*/
-/* Directory handling - Reserve directory entry                          */
+/* Directory handling - Reserve a block of directory entries             */
 /*-----------------------------------------------------------------------*/
 
 #if !_FS_READONLY
 static
-FRESULT dir_alloc (
-	DIR* dp,	/* Pointer to the directory object */
-	UINT nent	/* Number of contiguous entries to allocate (1-21) */
+FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
+	DIR* dp,		/* Pointer to the directory object */
+	UINT nent		/* Number of contiguous entries to allocate */
 )
 {
 	FRESULT res;
 	UINT n;
+	FATFS *fs = dp->obj.fs;
 
 
 	res = dir_sdi(dp, 0);
@@ -1164,16 +1474,21 @@
 	if (res == FR_OK) {
 		n = 0;
 		do {
-			res = move_window(dp->fs, dp->sect);
+			res = move_window(fs, dp->sect);
 			if (res != FR_OK) break;
-			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
+#if _FS_EXFAT
+			if (fs->fs_type == FS_EXFAT ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {
+#else
+			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
+#endif
 				if (++n == nent) break;	/* A block of contiguous free entries is found */
 			} else {
 				n = 0;					/* Not a blank entry. Restart to search */
 			}
-			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
-		} while (res == FR_OK);
+			res = dir_next(dp, 1);
+		} while (res == FR_OK);	/* Next entry with table stretch enabled */
 	}
+
 	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 	return res;
 }
@@ -1183,20 +1498,21 @@
 
 
 /*-----------------------------------------------------------------------*/
-/* Directory handling - Load/Store start cluster number                  */
+/* FAT: Directory handling - Load/Store start cluster number             */
 /*-----------------------------------------------------------------------*/
 
 static
-DWORD ld_clust (
-	FATFS* fs,	/* Pointer to the fs object */
-	BYTE* dir	/* Pointer to the directory entry */
+DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
+	FATFS* fs,		/* Pointer to the fs object */
+	const BYTE* dir	/* Pointer to the key entry */
 )
 {
 	DWORD cl;
 
-	cl = LD_WORD(dir + DIR_FstClusLO);
-	if (fs->fs_type == FS_FAT32)
-		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
+	cl = ld_word(dir + DIR_FstClusLO);
+	if (fs->fs_type == FS_FAT32) {
+		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
+	}
 
 	return cl;
 }
@@ -1205,12 +1521,15 @@
 #if !_FS_READONLY
 static
 void st_clust (
-	BYTE* dir,	/* Pointer to the directory entry */
+	FATFS* fs,	/* Pointer to the fs object */
+	BYTE* dir,	/* Pointer to the key entry */
 	DWORD cl	/* Value to be set */
 )
 {
-	ST_WORD(dir + DIR_FstClusLO, cl);
-	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
+	st_word(dir + DIR_FstClusLO, (WORD)cl);
+	if (fs->fs_type == FS_FAT32) {
+		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
+	}
 }
 #endif
 
@@ -1217,18 +1536,20 @@
 
 
 
-/*-----------------------------------------------------------------------*/
-/* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
-/*-----------------------------------------------------------------------*/
-#if _USE_LFN
+/*------------------------------------------------------------------------*/
+/* FAT-LFN: LFN handling                                                  */
+/*------------------------------------------------------------------------*/
+#if _USE_LFN != 0
 static
 const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN characters in the directory entry */
 
-
+/*--------------------------------------------------------*/
+/* FAT-LFN: Compare a part of file name with an LFN entry */
+/*--------------------------------------------------------*/
 static
-int cmp_lfn (			/* 1:Matched, 0:Not matched */
-	WCHAR* lfnbuf,		/* Pointer to the LFN to be compared */
-	BYTE* dir			/* Pointer to the directory entry containing a part of LFN */
+int cmp_lfn (				/* 1:matched, 0:not matched */
+	const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer to be compared */
+	BYTE* dir				/* Pointer to the directory entry containing the part of LFN */
 )
 {
 	UINT i, s;
@@ -1235,30 +1556,37 @@
 	WCHAR wc, uc;
 
 
-	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Get offset in the LFN buffer */
-	s = 0; wc = 1;
-	do {
-		uc = LD_WORD(dir + LfnOfs[s]);	/* Pick an LFN character from the entry */
-		if (wc) {	/* Last character has not been processed */
-			wc = ff_wtoupper(uc);		/* Convert it to upper case */
-			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
-				return 0;				/* Not matched */
+	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
+
+	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
+
+	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
+		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
+		if (wc) {
+			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
+				return 0;					/* Not matched */
+			}
+			wc = uc;
 		} else {
-			if (uc != 0xFFFF) return 0;	/* Check filler */
+			if (uc != 0xFFFF) return 0;		/* Check filler */
 		}
-	} while (++s < 13);				/* Repeat until all characters in the entry are checked */
+	}
 
-	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i])	/* Last segment matched but different length */
-		return 0;
+	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 
-	return 1;						/* The part of LFN matched */
+	return 1;		/* The part of LFN matched */
 }
 
-#if _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2
+
+
+#if _FS_MINIMIZE <= 1 || _FS_EXFAT
+/*-----------------------------------------------------*/
+/* FAT-LFN: Pick a part of file name from an LFN entry */
+/*-----------------------------------------------------*/
 static
-int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
-	WCHAR* lfnbuf,		/* Pointer to the Unicode-LFN buffer */
-	BYTE* dir			/* Pointer to the directory entry */
+int pick_lfn (			/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
+	WCHAR* lfnbuf,		/* Pointer to the LFN working buffer */
+	BYTE* dir			/* Pointer to the LFN entry */
 )
 {
 	UINT i, s;
@@ -1265,18 +1593,19 @@
 	WCHAR wc, uc;
 
 
+	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
+
 	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 
-	s = 0; wc = 1;
-	do {
-		uc = LD_WORD(dir + LfnOfs[s]);		/* Pick an LFN character from the entry */
-		if (wc) {	/* Last character has not been processed */
+	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
+		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
+		if (wc) {
 			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 			lfnbuf[i++] = wc = uc;			/* Store it */
 		} else {
 			if (uc != 0xFFFF) return 0;		/* Check filler */
 		}
-	} while (++s < 13);						/* Read all character in the entry */
+	}
 
 	if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
 		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
@@ -1283,17 +1612,20 @@
 		lfnbuf[i] = 0;
 	}
 
-	return 1;
+	return 1;		/* The part of LFN is valid */
 }
-#endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
+#endif
 
 #if !_FS_READONLY
+/*-----------------------------------------*/
+/* FAT-LFN: Create an entry of LFN entries */
+/*-----------------------------------------*/
 static
-void fit_lfn (
-	const WCHAR* lfnbuf,	/* Pointer to the LFN buffer */
-	BYTE* dir,				/* Pointer to the directory entry */
-	BYTE ord,				/* LFN order (1-20) */
-	BYTE sum				/* SFN sum */
+void put_lfn (
+	const WCHAR* lfn,	/* Pointer to the LFN */
+	BYTE* dir,			/* Pointer to the LFN entry to be created */
+	BYTE ord,			/* LFN order (1-20) */
+	BYTE sum			/* Checksum of the corresponding SFN */
 )
 {
 	UINT i, s;
@@ -1300,19 +1632,19 @@
 	WCHAR wc;
 
 
-	dir[LDIR_Chksum] = sum;			/* Set check sum */
+	dir[LDIR_Chksum] = sum;			/* Set checksum */
 	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 	dir[LDIR_Type] = 0;
-	ST_WORD(dir + LDIR_FstClusLO, 0);
+	st_word(dir + LDIR_FstClusLO, 0);
 
-	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
+	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 	s = wc = 0;
 	do {
-		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
-		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
-		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
+		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
+		st_word(dir + LfnOfs[s], wc);		/* Put it */
+		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 	} while (++s < 13);
-	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLEF;	/* Bottom LFN part is the start of LFN sequence */
+	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
 	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 }
 
@@ -1321,11 +1653,10 @@
 
 
 
-
 /*-----------------------------------------------------------------------*/
-/* Create numbered name                                                  */
+/* FAT-LFN: Create a Numbered SFN                                        */
 /*-----------------------------------------------------------------------*/
-#if _USE_LFN
+#if _USE_LFN != 0 && !_FS_READONLY
 static
 void gen_numname (
 	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
@@ -1342,7 +1673,7 @@
 
 	mem_cpy(dst, src, 11);
 
-	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
+	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 		sr = seq;
 		while (*lfn) {	/* Create a CRC */
 			wc = *lfn++;
@@ -1380,11 +1711,10 @@
 
 
 
-
 /*-----------------------------------------------------------------------*/
-/* Calculate sum of an SFN                                               */
+/* FAT-LFN: Calculate checksum of an SFN entry                           */
 /*-----------------------------------------------------------------------*/
-#if _USE_LFN
+#if _USE_LFN != 0
 static
 BYTE sum_sfn (
 	const BYTE* dir		/* Pointer to the SFN entry */
@@ -1401,122 +1731,396 @@
 
 
 
+#if _FS_EXFAT
 /*-----------------------------------------------------------------------*/
-/* Directory handling - Find an object in the directory                  */
+/* exFAT: Directory handling - Load/Store a block of directory entries   */
 /*-----------------------------------------------------------------------*/
 
 static
-FRESULT dir_find (
-	DIR* dp			/* Pointer to the directory object linked to the file name */
+WORD xdir_sum (			/* Get checksum of the directoly block */
+	const BYTE* dir		/* Directory entry block to be calculated */
 )
 {
-	FRESULT res;
-	BYTE c, *dir;
-#if _USE_LFN
-	BYTE a, ord, sum;
+	UINT i, szblk;
+	WORD sum;
+
+
+	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;
+	for (i = sum = 0; i < szblk; i++) {
+		if (i == XDIR_SetSum) {	/* Skip sum field */
+			i++;
+		} else {
+			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
+		}
+	}
+	return sum;
+}
+
+
+
+static
+WORD xname_sum (		/* Get check sum (to be used as hash) of the name */
+	const WCHAR* name	/* File name to be calculated */
+)
+{
+	WCHAR chr;
+	WORD sum = 0;
+
+
+	while ((chr = *name++) != 0) {
+		chr = ff_wtoupper(chr);		/* File name needs to be ignored case */
+		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);
+		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);
+	}
+	return sum;
+}
+
+
+/*------------------------------------------------------*/
+/* exFAT: Get object information from a directory block */
+/*------------------------------------------------------*/
+static
+void get_xdir_info (
+	BYTE* dirb,			/* Pointer to the direcotry entry block 85+C0+C1s */
+	FILINFO* fno		/* Buffer to store the extracted file information */
+)
+{
+	UINT di, si, nc;
+	WCHAR w;
+
+	/* Get file name */
+#if _LFN_UNICODE
+	if (dirb[XDIR_NumName] <= _MAX_LFN) {
+		for (si = SZDIRE * 2, di = 0; di < dirb[XDIR_NumName]; si += 2, di++) {
+			if ((si % SZDIRE) == 0) si += 2;	/* Skip entry type field */
+			w = ld_word(dirb + si);				/* Get a character */
+			fno->fname[di] = w;					/* Store it */
+		}
+	} else {
+		di = 0;	/* Buffer overflow and inaccessible object */
+	}
+#else
+	for (si = SZDIRE * 2, di = nc = 0; nc < dirb[XDIR_NumName]; si += 2, nc++) {
+		if ((si % SZDIRE) == 0) si += 2;	/* Skip entry type field */
+		w = ld_word(dirb + si);				/* Get a character */
+		w = ff_convert(w, 0);				/* Unicode -> OEM */
+		if (w == 0) { di = 0; break; }		/* Could not be converted and inaccessible object */
+		if (_DF1S && w >= 0x100) {			/* Put 1st byte if it is a DBC (always false at SBCS cfg) */
+			fno->fname[di++] = (char)(w >> 8);
+		}
+		if (di >= _MAX_LFN) { di = 0; break; }	/* Buffer overflow and inaccessible object */
+		fno->fname[di++] = (char)w;
+	}
 #endif
+	if (di == 0) fno->fname[di++] = '?';	/* Inaccessible object? */
+	fno->fname[di] = 0;						/* Terminate file name */
 
-	res = dir_sdi(dp, 0);			/* Rewind directory object */
+	fno->altname[0] = 0;							/* No SFN */
+	fno->fattrib = dirb[XDIR_Attr];					/* Attribute */
+	fno->fsize = (fno->fattrib & AM_DIR) ? 0 : ld_qword(dirb + XDIR_FileSize);	/* Size */
+	fno->ftime = ld_word(dirb + XDIR_ModTime + 0);	/* Time */
+	fno->fdate = ld_word(dirb + XDIR_ModTime + 2);	/* Date */
+}
+
+
+/*-----------------------------------*/
+/* exFAT: Get a directry entry block */
+/*-----------------------------------*/
+static
+FRESULT load_xdir (	/* FR_INT_ERR: invalid entry block */
+	DIR* dp			/* Pointer to the reading direcotry object pointing the 85 entry */
+)
+{
+	FRESULT res;
+	UINT i, nent;
+	BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the on-memory direcotry entry block 85+C0+C1s */
+
+
+	/* Load 85 entry */
+	res = move_window(dp->obj.fs, dp->sect);
 	if (res != FR_OK) return res;
+	if (dp->dir[XDIR_Type] != 0x85) return FR_INT_ERR;
+	mem_cpy(&dirb[0], dp->dir, SZDIRE);
+	nent = dirb[XDIR_NumSec] + 1;
 
-#if _USE_LFN
-	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
+	/* Load C0 entry */
+	res = dir_next(dp, 0);
+	if (res != FR_OK) return res;
+	res = move_window(dp->obj.fs, dp->sect);
+	if (res != FR_OK) return res;
+	if (dp->dir[XDIR_Type] != 0xC0) return FR_INT_ERR;
+	mem_cpy(dirb + SZDIRE, dp->dir, SZDIRE);
+
+	/* Load C1 entries */
+	if (nent < 3 || nent > 19) return FR_NO_FILE;
+	i = SZDIRE * 2; nent *= SZDIRE;
+	do {
+		res = dir_next(dp, 0);
+		if (res != FR_OK) return res;
+		res = move_window(dp->obj.fs, dp->sect);
+		if (res != FR_OK) return res;
+		if (dp->dir[XDIR_Type] != 0xC1) return FR_INT_ERR;
+		mem_cpy(dirb + i, dp->dir, SZDIRE);
+		i += SZDIRE;
+	} while (i < nent);
+
+	/* Sanity check */
+	if (xdir_sum(dirb) != ld_word(dirb + XDIR_SetSum)) return FR_INT_ERR;
+
+	return FR_OK;
+}
+
+
+#if !_FS_READONLY || _FS_RPATH != 0 
+/*------------------------------------------------*/
+/* exFAT: Load the object's directory entry block */
+/*------------------------------------------------*/
+static
+FRESULT load_obj_dir (	
+	DIR* dp,			/* Blank directory object to be used to access containing direcotry */
+	const _FDID* obj	/* Object with containing directory information */
+)
+{
+	FRESULT res;
+
+
+	/* Open object containing directory */
+	dp->obj.fs = obj->fs;
+	dp->obj.sclust = obj->c_scl;
+	dp->obj.stat = (BYTE)obj->c_size;
+	dp->obj.objsize = obj->c_size & 0xFFFFFF00;
+	dp->blk_ofs = obj->c_ofs;
+
+	res = dir_sdi(dp, dp->blk_ofs);	/* Goto the block location */
+	if (res == FR_OK) {
+		res = load_xdir(dp);		/* Load the object's entry block */
+	}
+	return res;
+}
 #endif
+
+
+#if !_FS_READONLY
+/*-----------------------------------------------*/
+/* exFAT: Store the directory block to the media */
+/*-----------------------------------------------*/
+static
+FRESULT store_xdir (
+	DIR* dp				/* Pointer to the direcotry object */
+)
+{
+	FRESULT res;
+	UINT nent;
+	WORD sum;
+	BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the direcotry entry block 85+C0+C1s */
+
+	/* Create set sum */
+	sum = xdir_sum(dirb);
+	st_word(dirb + XDIR_SetSum, sum);
+	nent = dirb[XDIR_NumSec] + 1;
+
+	res = dir_sdi(dp, dp->blk_ofs);
+	while (res == FR_OK && (res = move_window(dp->obj.fs, dp->sect)) == FR_OK) {
+		mem_cpy(dp->dir, dirb, SZDIRE);
+		dp->obj.fs->wflag = 1;
+		if (--nent == 0) break;
+		dirb += SZDIRE;
+		res = dir_next(dp, 0);
+	}
+	return (res == FR_OK || res == FR_DISK_ERR) ? res : FR_INT_ERR;
+}
+
+
+/*-------------------------------------------*/
+/* exFAT: Create a new directory enrty block */
+/*-------------------------------------------*/
+static
+void create_xdir (
+	BYTE* dirb,			/* Pointer to the direcotry entry block buffer */
+	const WCHAR* lfn	/* Pointer to the nul terminated file name */
+)
+{
+	UINT i;
+	BYTE nb, nc;
+	WCHAR chr;
+	WORD hash;
+
+
+	mem_set(dirb, 0, 2 * SZDIRE);			/* Initialize 85+C0 entry */
+	dirb[XDIR_Type] = 0x85;
+	dirb[XDIR_Type + SZDIRE] = 0xC0;
+	hash = xname_sum(lfn);
+	st_word(dirb + XDIR_NameHash, hash);	/* Set name hash */
+
+	i = SZDIRE * 2;	/* C1 offset */
+	nc = 0; nb = 1; chr = 1;
 	do {
-		res = move_window(dp->fs, dp->sect);
+		dirb[i++] = 0xC1; dirb[i++] = 0;	/* Entry type C1 */
+		do {	/* Fill name field */
+			if (chr && (chr = lfn[nc]) != 0) nc++;	/* Get a character if exist */
+			st_word(dirb + i, chr); i += 2;	/* Store it */
+		} while (i % SZDIRE);
+		nb++;
+	} while (lfn[nc]);	/* Fill next entry if any char follows */
+
+	dirb[XDIR_NumName] = nc;	/* Set name length */
+	dirb[XDIR_NumSec] = nb;		/* Set number of C0+C1s */
+}
+#endif
+#endif
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Read an object from the directory                                     */
+/*-----------------------------------------------------------------------*/
+#if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 || _USE_LABEL || _FS_EXFAT
+static
+FRESULT dir_read (
+	DIR* dp,		/* Pointer to the directory object */
+	int vol			/* Filtered by 0:file/directory or 1:volume label */
+)
+{
+	FRESULT res = FR_NO_FILE;
+	FATFS *fs = dp->obj.fs;
+	BYTE a, c;
+#if _USE_LFN != 0
+	BYTE ord = 0xFF, sum = 0xFF;
+#endif
+
+	while (dp->sect) {
+		res = move_window(fs, dp->sect);
 		if (res != FR_OK) break;
-		dir = dp->dir;					/* Ptr to the directory entry of current index */
-		c = dir[DIR_Name];
-		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
-#if _USE_LFN	/* LFN configuration */
-		a = dir[DIR_Attr] & AM_MASK;
-		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
-			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
-		} else {
-			if (a == AM_LFN) {			/* An LFN entry is found */
-				if (dp->lfn) {
-					if (c & LLEF) {		/* Is it start of LFN sequence? */
-						sum = dir[LDIR_Chksum];
-						c &= ~LLEF; ord = c;	/* LFN start order */
-						dp->lfn_idx = dp->index;	/* Start index of LFN */
+		c = dp->dir[DIR_Name];	/* Test for the entry type */
+		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of the directory */
+#if _FS_EXFAT
+		if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
+			if (_USE_LABEL && vol) {
+				if (c == 0x83) break;	/* Volume label entry? */
+			} else {
+				if (c == 0x85) {		/* Start of the entry block? */
+					dp->blk_ofs = dp->dptr;	/* Set location of block */
+					res = load_xdir(dp);	/* Load the entry block */
+					if (res == FR_OK) {
+						dp->obj.attr = fs->dirbuf[XDIR_Attr] & AM_MASK;	/* Get attribute */
 					}
-					/* Check validity of the LFN entry and compare it with given name */
-					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
+					break;
 				}
-			} else {					/* An SFN entry is found */
-				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
-				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
-				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 			}
-		}
+		} else
+#endif
+		{	/* At the FAT12/16/32 */
+			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
+#if _USE_LFN != 0	/* LFN configuration */
+			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
+				ord = 0xFF;
+			} else {
+				if (a == AM_LFN) {			/* An LFN entry is found */
+					if (c & LLEF) {			/* Is it start of an LFN sequence? */
+						sum = dp->dir[LDIR_Chksum];
+						c &= ~LLEF; ord = c;
+						dp->blk_ofs = dp->dptr;
+					}
+					/* Check LFN validity and capture it */
+					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(dp->lfn, dp->dir)) ? ord - 1 : 0xFF;
+				} else {					/* An SFN entry is found */
+					if (ord || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
+						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
+					}
+					break;
+				}
+			}
 #else		/* Non LFN configuration */
-		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
-			break;
+			if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
+				break;
+			}
 #endif
+		}
 		res = dir_next(dp, 0);		/* Next entry */
-	} while (res == FR_OK);
+		if (res != FR_OK) break;
+	}
 
+	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 	return res;
 }
+#endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
 
 
 
-
 /*-----------------------------------------------------------------------*/
-/* Read an object from the directory                                     */
+/* Directory handling - Find an object in the directory                  */
 /*-----------------------------------------------------------------------*/
-#if _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2
+
 static
-FRESULT dir_read (
-	DIR* dp,		/* Pointer to the directory object */
-	int vol			/* Filtered by 0:file/directory or 1:volume label */
+FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
+	DIR* dp			/* Pointer to the directory object with the file name */
 )
 {
 	FRESULT res;
-	BYTE a, c, *dir;
-#if _USE_LFN
-	BYTE ord = 0xFF, sum = 0xFF;
+	FATFS *fs = dp->obj.fs;
+	BYTE c;
+#if _USE_LFN != 0
+	BYTE a, ord, sum;
 #endif
 
-	res = FR_NO_FILE;
-	while (dp->sect) {
-		res = move_window(dp->fs, dp->sect);
+	res = dir_sdi(dp, 0);			/* Rewind directory object */
+	if (res != FR_OK) return res;
+#if _FS_EXFAT
+	if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
+		BYTE nc;
+		UINT di, ni;
+		WORD hash = xname_sum(dp->lfn);		/* Hash value of the name to find */
+
+		while ((res = dir_read(dp, 0)) == FR_OK) {	/* Read an item */
+			if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) continue;	/* Skip the comparison if hash value mismatched */
+			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
+				if ((di % SZDIRE) == 0) di += 2;
+				if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(dp->lfn[ni])) break;
+			}
+			if (nc == 0 && !dp->lfn[ni]) break;	/* Name matched? */
+		}
+		return res;
+	}
+#endif
+	/* At the FAT12/16/32 */
+#if _USE_LFN != 0
+	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
+#endif
+	do {
+		res = move_window(fs, dp->sect);
 		if (res != FR_OK) break;
-		dir = dp->dir;					/* Ptr to the directory entry of current index */
-		c = dir[DIR_Name];
+		c = dp->dir[DIR_Name];
 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
-		a = dir[DIR_Attr] & AM_MASK;
-#if _USE_LFN	/* LFN configuration */
-		if (c == DDEM || (!_FS_RPATH && c == '.') || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
-			ord = 0xFF;
+#if _USE_LFN != 0	/* LFN configuration */
+		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
+		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
+			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 		} else {
 			if (a == AM_LFN) {			/* An LFN entry is found */
-				if (c & LLEF) {			/* Is it start of LFN sequence? */
-					sum = dir[LDIR_Chksum];
-					c &= ~LLEF; ord = c;
-					dp->lfn_idx = dp->index;
+				if (dp->lfn) {
+					if (c & LLEF) {		/* Is it start of LFN sequence? */
+						sum = dp->dir[LDIR_Chksum];
+						c &= ~LLEF; ord = c;	/* LFN start order */
+						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
+					}
+					/* Check validity of the LFN entry and compare it with given name */
+					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dp->dir)) ? ord - 1 : 0xFF;
 				}
-				/* Check LFN validity and capture it */
-				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
 			} else {					/* An SFN entry is found */
-				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
-					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
-				break;
+				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
+				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
+				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 			}
 		}
 #else		/* Non LFN configuration */
-		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
-			break;
+		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
+		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
 #endif
-		res = dir_next(dp, 0);				/* Next entry */
-		if (res != FR_OK) break;
-	}
+		res = dir_next(dp, 0);	/* Next entry */
+	} while (res == FR_OK);
 
-	if (res != FR_OK) dp->sect = 0;
-
 	return res;
 }
-#endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
 
 
 
@@ -1526,25 +2130,53 @@
 /*-----------------------------------------------------------------------*/
 #if !_FS_READONLY
 static
-FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
+FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
 	DIR* dp				/* Target directory with object name to be created */
 )
 {
 	FRESULT res;
-#if _USE_LFN	/* LFN configuration */
-	UINT n, nent;
+	FATFS *fs = dp->obj.fs;
+#if _USE_LFN != 0	/* LFN configuration */
+	UINT n, nlen, nent;
 	BYTE sn[12], *fn, sum;
 	WCHAR *lfn;
 
 
 	fn = dp->fn; lfn = dp->lfn;
-	mem_cpy(sn, fn, 12);
+	if (fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
+	for (nlen = 0; lfn[nlen]; nlen++) ;	/* Get lfn length */
 
-	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
-		return FR_INVALID_NAME;
+#if _FS_EXFAT
+	if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
+		DIR dj;
 
+		nent = (nlen + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
+		res = dir_alloc(dp, nent);		/* Allocate entries */
+		if (res != FR_OK) return res;
+		dp->blk_ofs = dp->dptr - SZDIRE * (nent - 1);			/* Set block position */
+
+		if (dp->obj.stat & 4) {			/* Has the sub-directory been stretched? */
+			dp->obj.stat &= 3;
+			dp->obj.objsize += (DWORD)fs->csize * SS(fs);	/* Increase object size by cluster size */
+			res = fill_fat_chain(&dp->obj);	/* Complement FAT chain if needed */
+			if (res != FR_OK) return res;
+			res = load_obj_dir(&dj, &dp->obj);
+			if (res != FR_OK) return res;	/* Load the object status */
+			st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);		/* Update the allocation status */
+			st_qword(fs->dirbuf + XDIR_ValidFileSize, dp->obj.objsize);
+			fs->dirbuf[XDIR_GenFlags] = dp->obj.stat | 1;
+			res = store_xdir(&dj);			/* Store the object status */
+			if (res != FR_OK) return res;
+		}
+
+		create_xdir(fs->dirbuf, lfn);	/* Create on-memory directory block to be written later */
+		return FR_OK;
+	}
+#endif
+	/* At the FAT12/16/32 */
+	mem_cpy(sn, fn, 12);
 	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
-		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
+		fn[NSFLAG] = 0; dp->lfn = 0;		/* Find only SFN */
 		for (n = 1; n < 100; n++) {
 			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
 			res = dir_find(dp);				/* Check if the name collides with existing SFN */
@@ -1555,40 +2187,38 @@
 		fn[NSFLAG] = sn[NSFLAG]; dp->lfn = lfn;
 	}
 
-	if (sn[NSFLAG] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
-		for (n = 0; lfn[n]; n++) ;
-		nent = (n + 25) / 13;
-	} else {						/* Otherwise allocate an entry for an SFN  */
-		nent = 1;
-	}
+	/* Create an SFN with/without LFNs. */
+	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 	res = dir_alloc(dp, nent);		/* Allocate entries */
-
 	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
-		res = dir_sdi(dp, dp->index - nent);
+		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
 		if (res == FR_OK) {
-			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
+			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
 			do {					/* Store LFN entries in bottom first */
-				res = move_window(dp->fs, dp->sect);
+				res = move_window(fs, dp->sect);
 				if (res != FR_OK) break;
-				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
-				dp->fs->wflag = 1;
+				put_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
+				fs->wflag = 1;
 				res = dir_next(dp, 0);	/* Next entry */
 			} while (res == FR_OK && --nent);
 		}
 	}
+
 #else	/* Non LFN configuration */
 	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
+
 #endif
 
-	if (res == FR_OK) {				/* Set SFN entry */
-		res = move_window(dp->fs, dp->sect);
+	/* Set SFN entry */
+	if (res == FR_OK) {
+		res = move_window(fs, dp->sect);
 		if (res == FR_OK) {
-			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
-			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
-#if _USE_LFN
+			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
+			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
+#if _USE_LFN != 0
 			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 #endif
-			dp->fs->wflag = 1;
+			fs->wflag = 1;
 		}
 	}
 
@@ -1604,38 +2234,38 @@
 /*-----------------------------------------------------------------------*/
 #if !_FS_READONLY && !_FS_MINIMIZE
 static
-FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
+FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
 	DIR* dp				/* Directory object pointing the entry to be removed */
 )
 {
 	FRESULT res;
-#if _USE_LFN	/* LFN configuration */
-	UINT i;
+	FATFS *fs = dp->obj.fs;
+#if _USE_LFN != 0	/* LFN configuration */
+	DWORD last = dp->dptr;
 
-	i = dp->index;	/* SFN index */
-	res = dir_sdi(dp, (dp->lfn_idx == 0xFFFF) ? i : dp->lfn_idx);	/* Goto the SFN or top of the LFN entries */
+	res = dp->blk_ofs == 0xFFFFFFFF ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
 	if (res == FR_OK) {
 		do {
-			res = move_window(dp->fs, dp->sect);
+			res = move_window(fs, dp->sect);
 			if (res != FR_OK) break;
-			mem_set(dp->dir, 0, SZ_DIRE);	/* Clear and mark the entry "deleted" */
-			*dp->dir = DDEM;
-			dp->fs->wflag = 1;
-			if (dp->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
-			res = dir_next(dp, 0);		/* Next entry */
+			/* Mark an entry 'deleted' */
+			if (_FS_EXFAT && fs->fs_type == FS_EXFAT) {	/* At the exFAT */
+				dp->dir[XDIR_Type] &= 0x7F;
+			} else {									/* At the FAT12/16/32 */
+				dp->dir[DIR_Name] = DDEM;
+			}
+			fs->wflag = 1;
+			if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been deleted. */
+			res = dir_next(dp, 0);	/* Next entry */
 		} while (res == FR_OK);
 		if (res == FR_NO_FILE) res = FR_INT_ERR;
 	}
+#else			/* Non LFN configuration */
 
-#else			/* Non LFN configuration */
-	res = dir_sdi(dp, dp->index);
+	res = move_window(fs, dp->sect);
 	if (res == FR_OK) {
-		res = move_window(dp->fs, dp->sect);
-		if (res == FR_OK) {
-			mem_set(dp->dir, 0, SZ_DIRE);	/* Clear and mark the entry "deleted" */
-			*dp->dir = DDEM;
-			dp->fs->wflag = 1;
-		}
+		dp->dir[DIR_Name] = DDEM;
+		fs->wflag = 1;
 	}
 #endif
 
@@ -1656,60 +2286,90 @@
 	FILINFO* fno	 	/* Pointer to the file information to be filled */
 )
 {
-	UINT i;
-	TCHAR *p, c;
-	BYTE *dir;
-#if _USE_LFN
+	UINT i, j;
+	TCHAR c;
+#if _USE_LFN != 0
 	WCHAR w, *lfn;
+	WCHAR lfv;
 #endif
 
-	p = fno->fname;
-	if (dp->sect) {		/* Get SFN */
-		dir = dp->dir;
-		i = 0;
-		while (i < 11) {		/* Copy name body and extension */
-			c = (TCHAR)dir[i++];
-			if (c == ' ') continue;				/* Skip padding spaces */
-			if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
-			if (i == 9) *p++ = '.';				/* Insert a . if extension is exist */
-#if _USE_LFN
-			if (IsUpper(c) && (dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY)))
-				c += 0x20;			/* To lower */
-#if _LFN_UNICODE
-			if (IsDBCS1(c) && i != 8 && i != 11 && IsDBCS2(dir[i]))
-				c = c << 8 | dir[i++];
-			c = ff_convert(c, 1);	/* OEM -> Unicode */
-			if (!c) c = '?';
+
+	fno->fname[0] = 0;		/* Invaidate file info */
+	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
+
+#if _USE_LFN != 0	/* LFN configuration */
+#if _FS_EXFAT
+	if (dp->obj.fs->fs_type == FS_EXFAT) {	/* At the exFAT */
+		get_xdir_info(dp->obj.fs->dirbuf, fno);
+		return;
+	} else
 #endif
+	{	/* At the FAT12/16/32 */
+		if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
+			i = 0; lfn = dp->lfn;
+			while ((w = *lfn++) != 0) {		/* Get an LFN character */
+#if !_LFN_UNICODE
+				w = ff_convert(w, 0);		/* Unicode -> OEM */
+				if (w == 0) { i = 0; break; }	/* No LFN if it could not be converted */
+				if (_DF1S && w >= 0x100) {	/* Put 1st byte if it is a DBC (always false at SBCS cfg) */
+					fno->fname[i++] = (char)(w >> 8);
+				}
 #endif
-			*p++ = c;
+				if (i >= _MAX_LFN) { i = 0; break; }	/* No LFN if buffer overflow */
+				fno->fname[i++] = (char)w;
+			}
+			fno->fname[i] = 0;	/* Terminate the LFN */
 		}
-		fno->fattrib = dir[DIR_Attr];				/* Attribute */
-		fno->fsize = LD_DWORD(dir + DIR_FileSize);	/* Size */
-		fno->fdate = LD_WORD(dir + DIR_WrtDate);	/* Date */
-		fno->ftime = LD_WORD(dir + DIR_WrtTime);	/* Time */
 	}
-	*p = 0;		/* Terminate SFN string by a \0 */
 
-#if _USE_LFN
-	if (fno->lfname) {
-		i = 0; p = fno->lfname;
-		if (dp->sect && fno->lfsize && dp->lfn_idx != 0xFFFF) {	/* Get LFN if available */
-			lfn = dp->lfn;
-			while ((w = *lfn++) != 0) {		/* Get an LFN character */
-#if !_LFN_UNICODE
-				w = ff_convert(w, 0);		/* Unicode -> OEM */
-				if (!w) { i = 0; break; }	/* No LFN if it could not be converted */
-				if (_DF1S && w >= 0x100)	/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
-					p[i++] = (TCHAR)(w >> 8);
+	i = j = 0;
+	lfv = fno->fname[i];	/* LFN is exist if non-zero */
+	while (i < 11) {		/* Copy name body and extension */
+		c = (TCHAR)dp->dir[i++];
+		if (c == ' ') continue;				/* Skip padding spaces */
+		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
+		if (i == 9) {						/* Insert a . if extension is exist */
+			if (!lfv) fno->fname[j] = '.';
+			fno->altname[j++] = '.';
+		}
+#if _LFN_UNICODE
+		if (IsDBCS1(c) && i != 8 && i != 11 && IsDBCS2(dp->dir[i])) {
+			c = c << 8 | dp->dir[i++];
+		}
+		c = ff_convert(c, 1);	/* OEM -> Unicode */
+		if (!c) c = '?';
 #endif
-				if (i >= fno->lfsize - 1) { i = 0; break; }	/* No LFN if buffer overflow */
-				p[i++] = (TCHAR)w;
+		fno->altname[j] = c;
+		if (!lfv) {
+			if (IsUpper(c) && (dp->dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY))) {
+				c += 0x20;			/* To lower */
 			}
+			fno->fname[j] = c;
 		}
-		p[i] = 0;	/* Terminate LFN string by a \0 */
+		j++;
 	}
+	if (!lfv) {
+		fno->fname[j] = 0;
+		if (!dp->dir[DIR_NTres]) j = 0;	/* Altname is no longer needed if neither LFN nor case info is exist. */
+	}
+	fno->altname[j] = 0;	/* Terminate the SFN */
+
+#else	/* Non-LFN configuration */
+	i = j = 0;
+	while (i < 11) {		/* Copy name body and extension */
+		c = (TCHAR)dp->dir[i++];
+		if (c == ' ') continue;				/* Skip padding spaces */
+		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
+		if (i == 9) fno->fname[j++] = '.';	/* Insert a . if extension is exist */
+		fno->fname[j++] = c;
+	}
+	fno->fname[j] = 0;
 #endif
+
+	fno->fattrib = dp->dir[DIR_Attr];				/* Attribute */
+	fno->fsize = ld_dword(dp->dir + DIR_FileSize);	/* Size */
+	fno->fdate = ld_word(dp->dir + DIR_WrtDate);	/* Date */
+	fno->ftime = ld_word(dp->dir + DIR_WrtTime);	/* Time */
 }
 #endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 */
 
@@ -1725,25 +2385,27 @@
 	const TCHAR** ptr	/* Pointer to pointer to the SBCS/DBCS/Unicode string */
 )
 {
+#if !_LFN_UNICODE
 	WCHAR chr;
 
-#if !_LFN_UNICODE
 	chr = (BYTE)*(*ptr)++;					/* Get a byte */
 	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
-	if (IsDBCS1(chr) && IsDBCS2(**ptr))		/* Get DBC 2nd byte if needed */
-		chr = chr << 8 | (BYTE)*(*ptr)++;
 #ifdef _EXCVT
 	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
+#else
+	if (IsDBCS1(chr) && IsDBCS2(**ptr)) {		/* Get DBC 2nd byte if needed */
+		chr = chr << 8 | (BYTE)*(*ptr)++;
+	}
 #endif
+	return chr;
 #else
-	chr = ff_wtoupper(*(*ptr)++);			/* Get a word and to upper */
+	return ff_wtoupper(*(*ptr)++);			/* Get a word and to upper */
 #endif
-	return chr;
 }
 
 
 static
-int pattern_matching (	/* Return value: 0:mismatched, 1:matched */
+int pattern_matching (	/* 0:not matched, 1:matched */
 	const TCHAR* pat,	/* Matching pattern */
 	const TCHAR* nam,	/* String to be tested */
 	int skip,			/* Number of pre-skip chars (number of ?s) */
@@ -1768,13 +2430,13 @@
 				do {				/* Analyze the wildcard chars */
 					if (*pp++ == '?') nm++; else nx = 1;
 				} while (*pp == '?' || *pp == '*');
-				if (pattern_matching(pp, np, nm, nx)) return 1;	/* Test new branch (recurs upto number of wildcard blocks in the pattern) */
+				if (pattern_matching(pp, np, nm, nx)) return 1;	/* Test new branch (recursions upto number of wildcard blocks in the pattern) */
 				nc = *np; break;	/* Branch mismatched */
 			}
 			pc = get_achar(&pp);	/* Get a pattern char */
 			nc = get_achar(&np);	/* Get a name char */
 			if (pc != nc) break;	/* Branch mismatched? */
-			if (!pc) return 1;		/* Branch matched? (matched at end of both strings) */
+			if (pc == 0) return 1;	/* Branch matched? (matched at end of both strings) */
 		}
 		get_achar(&nam);			/* nam++ */
 	} while (inf && nc);			/* Retry until end of name if infinite search is specified */
@@ -1787,16 +2449,16 @@
 
 
 /*-----------------------------------------------------------------------*/
-/* Pick a segment and create the object name in directory form           */
+/* Pick a top segment and create the object name in directory form       */
 /*-----------------------------------------------------------------------*/
 
 static
-FRESULT create_name (
+FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
 	DIR* dp,			/* Pointer to the directory object */
 	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
 )
 {
-#if _USE_LFN	/* LFN configuration */
+#if _USE_LFN != 0	/* LFN configuration */
 	BYTE b, cf;
 	WCHAR w, *lfn;
 	UINT i, ni, si, di;
@@ -1803,49 +2465,46 @@
 	const TCHAR *p;
 
 	/* Create LFN in Unicode */
-	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
-	lfn = dp->lfn;
-	si = di = 0;
+	p = *path; lfn = dp->lfn; si = di = 0;
 	for (;;) {
 		w = p[si++];					/* Get a character */
-		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
-		if (di >= _MAX_LFN)				/* Reject too long name */
-			return FR_INVALID_NAME;
+		if (w < ' ' || w == '/' || w == '\\') {		/* Break on end of segment */
+			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator */
+			break;
+		}
+		if (di >= _MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
 #if !_LFN_UNICODE
 		w &= 0xFF;
 		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
 			b = (BYTE)p[si++];			/* Get 2nd byte */
 			w = (w << 8) + b;			/* Create a DBC */
-			if (!IsDBCS2(b))
-				return FR_INVALID_NAME;	/* Reject invalid sequence */
+			if (!IsDBCS2(b)) return FR_INVALID_NAME;	/* Reject invalid sequence */
 		}
 		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
 		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 #endif
-		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
-			return FR_INVALID_NAME;
+		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
 		lfn[di++] = w;					/* Store the Unicode character */
 	}
 	*path = &p[si];						/* Return pointer to the next segment */
 	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
-#if _FS_RPATH
-	if ((di == 1 && lfn[di - 1] == '.') || /* Is this a dot entry? */
-		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {
+#if _FS_RPATH != 0
+	if ((di == 1 && lfn[di - 1] == '.') ||
+		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot name? */
 		lfn[di] = 0;
-		for (i = 0; i < 11; i++)
+		for (i = 0; i < 11; i++)		/* Create dot name for SFN entry */
 			dp->fn[i] = (i < di) ? '.' : ' ';
 		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
 		return FR_OK;
 	}
 #endif
-	while (di) {						/* Strip trailing spaces and dots */
+	while (di) {						/* Snip off trailing spaces and dots if exist */
 		w = lfn[di - 1];
 		if (w != ' ' && w != '.') break;
 		di--;
 	}
-	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
-
 	lfn[di] = 0;						/* LFN is created */
+	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
 
 	/* Create SFN in directory form */
 	mem_set(dp->fn, ' ', 11);
@@ -1881,7 +2540,7 @@
 			cf |= NS_LFN;				/* Force create LFN entry */
 		}
 
-		if (_DF1S && w >= 0x100) {		/* DBC (always false at SBCS cfg) */
+		if (_DF1S && w >= 0x100) {		/* Is this DBC? (always false at SBCS cfg) */
 			if (i >= ni - 1) {
 				cf |= NS_LOSS | NS_LFN; i = ni; continue;
 			}
@@ -1902,11 +2561,10 @@
 		dp->fn[i++] = (BYTE)w;
 	}
 
-	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with deleted mark, replace it with RDDEM */
+	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 
 	if (ni == 8) b <<= 2;
-	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
-		cf |= NS_LFN;
+	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
@@ -1923,11 +2581,10 @@
 	const char *p;
 
 	/* Create file name in directory form */
-	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
-	sfn = dp->fn;
+	p = *path; sfn = dp->fn;
 	mem_set(sfn, ' ', 11);
 	si = i = b = 0; ni = 8;
-#if _FS_RPATH
+#if _FS_RPATH != 0
 	if (p[si] == '.') { /* Is this a dot entry? */
 		for (;;) {
 			c = (BYTE)p[si++];
@@ -1942,7 +2599,10 @@
 #endif
 	for (;;) {
 		c = (BYTE)p[si++];
-		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
+		if (c <= ' ' || c == '/' || c == '\\') {	/* Break on end of segment */
+			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator */
+			break;
+		}
 		if (c == '.' || i >= ni) {
 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
 			i = 8; ni = 11;
@@ -1958,15 +2618,13 @@
 #endif
 #endif
 		}
-		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
+		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
 			d = (BYTE)p[si++];			/* Get 2nd byte */
-			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
-				return FR_INVALID_NAME;
+			if (!IsDBCS2(d) || i >= ni - 1) return FR_INVALID_NAME;	/* Reject invalid DBC */
 			sfn[i++] = c;
 			sfn[i++] = d;
 		} else {						/* SBC */
-			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
-				return FR_INVALID_NAME;
+			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) return FR_INVALID_NAME;	/* Reject illegal chrs for SFN */
 			if (IsUpper(c)) {			/* ASCII large capital? */
 				b |= 2;
 			} else {
@@ -1980,7 +2638,7 @@
 	*path = &p[si];						/* Return pointer to the next segment */
 	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 
-	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
+	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
 	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
 
 	if (ni == 8) b <<= 2;
@@ -2007,36 +2665,50 @@
 )
 {
 	FRESULT res;
-	BYTE *dir, ns;
+	BYTE ns;
+	_FDID *obj = &dp->obj;
+	FATFS *fs = obj->fs;
 
 
-#if _FS_RPATH
-	if (*path == '/' || *path == '\\') {	/* There is a heading separator */
-		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
-	} else {								/* No heading separator */
-		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
+#if _FS_RPATH != 0
+	if (*path != '/' && *path != '\\') {	/* Without heading separator */
+		obj->sclust = fs->cdir;				/* Start from the current directory */
+	} else
+#endif
+	{										/* With heading separator */
+		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
+		obj->sclust = 0;					/* Start from the root directory */
 	}
-#else
-	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
-		path++;
-	dp->sclust = 0;							/* Always start from the root directory */
+#if _FS_EXFAT && _FS_RPATH != 0
+	if (fs->fs_type == FS_EXFAT && obj->sclust) {	/* Retrieve the sub-directory status if needed */
+		DIR dj;
+
+		obj->c_scl = fs->cdc_scl;
+		obj->c_size = fs->cdc_size;
+		obj->c_ofs = fs->cdc_ofs;
+		res = load_obj_dir(&dj, obj);
+		if (res != FR_OK) return res;
+		obj->objsize = ld_dword(fs->dirbuf + XDIR_FileSize);
+		obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
+	}
 #endif
 
 	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
+		dp->fn[NSFLAG] = NS_NONAME;
 		res = dir_sdi(dp, 0);
-		dp->dir = 0;
+
 	} else {								/* Follow path */
 		for (;;) {
 			res = create_name(dp, &path);	/* Get a segment name of the path */
 			if (res != FR_OK) break;
-			res = dir_find(dp);				/* Find an object with the sagment name */
+			res = dir_find(dp);				/* Find an object with the segment name */
 			ns = dp->fn[NSFLAG];
 			if (res != FR_OK) {				/* Failed to find the object */
 				if (res == FR_NO_FILE) {	/* Object is not found */
-					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
-						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
+					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
 						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
-						res = FR_OK;					/* Ended at the root directroy. Function completed. */
+						dp->fn[NSFLAG] = NS_NONAME;
+						res = FR_OK;
 					} else {							/* Could not find the object */
 						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 					}
@@ -2044,11 +2716,23 @@
 				break;
 			}
 			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
-			dir = dp->dir;						/* Follow the sub-directory */
-			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
+			/* Get into the sub-directory */
+			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
 				res = FR_NO_PATH; break;
 			}
-			dp->sclust = ld_clust(dp->fs, dir);
+#if _FS_EXFAT
+			if (fs->fs_type == FS_EXFAT) {
+				obj->c_scl = obj->sclust;		/* Save containing directory information for next dir */
+				obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
+				obj->c_ofs = dp->blk_ofs;
+				obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Open next directory */
+				obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
+				obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
+			} else
+#endif
+			{
+				obj->sclust = ld_clust(fs, &fs->win[dp->dptr % SS(fs)]);	/* Open next directory */
+			}
 		}
 	}
 
@@ -2107,7 +2791,7 @@
 #endif
 			return vol;
 		}
-#if _FS_RPATH && _VOLUMES >= 2
+#if _FS_RPATH != 0 && _VOLUMES >= 2
 		vol = CurrVol;	/* Current drive */
 #else
 		vol = 0;		/* Drive 0 */
@@ -2124,25 +2808,132 @@
 /*-----------------------------------------------------------------------*/
 
 static
-BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
+BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
 	FATFS* fs,	/* File system object */
 	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
 )
 {
-	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
-	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
+	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
+	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
+
+	if (ld_word(&fs->win[BS_55AA]) != 0xAA55 &&	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
+	    ld_word(&fs->win[BS_55AA]) != 0xAB55)	/* Used by UStealth as boot record signature to hide drive */
 		return 3;
 
-	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55 &&	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
-		LD_WORD(&fs->win[BS_55AA]) != 0xAB55)	/* Used by UStealth as boot record signature to hide drive */
+	if ((ld_dword(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
+	if ((ld_dword(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
+#if _FS_EXFAT
+	if (!mem_cmp(&fs->win[BS_OEMName], "EXFAT   ", 8)) return 1;
+#endif
+	return 2;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Get the partitions from a GPT-partitioned drive. (Nintendont)         */
+/*-----------------------------------------------------------------------*/
+
+#define GPT_PARTITION_ENTRY_SIZE 128
+#define GPT_PARTITION_COUNT_MAX 128
+// EFI System Partition: {C12A7328-F81F-11D2-BA4B-00A0C93EC93B}
+static const DWORD GPT_EFISYS_GUID[4] = {0x28732AC1, 0x1FF8D211, 0xBA4B00A0, 0xC93EC93B};
+
+static
+BYTE read_gpt (	/* 0:GPT is valid and partitions read, 1:No partitions found, 2:GPT is invalid, 3:Disk error */
+	FATFS* fs,	/* File system object */
+	DWORD sect,	/* GPT partition table header sector (usually 1) */
+	DWORD br[128],	/* Array to store partition LBAs in */
+	DWORD *part_count	/* Number of partitions read (output) */
+)
+{
+	DWORD partition_count;
+	int n, idx;
+	DWORD sect_max;
+
+	// Read the GPT pseudo-MBR.
+	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invalidate window */
+	if (move_window(fs, sect) != FR_OK)		/* Load sector */
+		return 3;
+
+	// Validate the GPT signature.
+	// NOTE: ld_dword byteswaps the data, so we have
+	// "reversed" DWORDs for the signature here.
+	if (ld_dword(&fs->win[0]) != 0x20494645 ||	/* "EFI " */
+	    ld_dword(&fs->win[4]) != 0x54524150)	/* "PART" */
+	{
+		// Invalid GPT signature.
 		return 2;
+	}
 
-	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
-		return 0;
-	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
-		return 0;
+	// Assuming each partition entry is 128 bytes.
+	if (ld_dword(&fs->win[0x54]) != GPT_PARTITION_ENTRY_SIZE) {
+		// Partition entry size isn't 128 bytes.
+		return 2;
+	}
 
-	return 1;
+	// Get the partition array information.
+	// NOTE: Starting LBA is 64-bit, but it's almost always 2.
+	sect = ld_dword(&fs->win[0x48]);		// Starting LBA of partition array
+	partition_count = ld_dword(&fs->win[0x50]);	// Partition count
+	if (partition_count > GPT_PARTITION_COUNT_MAX) {
+		// We're only supporting the first 128 partitions.
+		// (Why do you have more than 128 partitions on a Wii HDD?)
+		partition_count = GPT_PARTITION_COUNT_MAX;
+	}
+
+	// Read from sect to sect + ((partition_count - 1) / 4).
+	// This assumes 512-byte sectors, 128 bytes per partition entry.
+	// 4096-byte sectors has fewer LBAs.
+	sect_max = ((partition_count - 1) / 4);
+	sect_max += sect;
+
+	for (idx = 0; sect < sect_max && idx < partition_count; sect++) {
+		// Read the current sector.
+		fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invalidate window */
+		if (move_window(fs, sect) != FR_OK)		/* Load sector */
+			return 3;
+
+		// Process partition entries.
+		for (n = 0; n < SS(fs) && idx < partition_count;
+		     n += GPT_PARTITION_ENTRY_SIZE)
+		{
+			QWORD lba64_start, lba64_end;
+			
+			// Save the partition LBA for later.
+			lba64_start = ld_qword(&fs->win[n+0x20]);
+			lba64_end = ld_qword(&fs->win[n+0x28]);
+			if (lba64_start > 0xFFFFFFFFULL || lba64_end > 0xFFFFFFFFULL) {
+				// Partition is over the 32-bit sector limit.
+				// FatFS doesn't support this.
+				// FIXME: FSIZE_t is 64-bit when exFAT is enabled.
+				continue;
+			}
+
+			// Check if this is an EFI System Partition.
+			if (!mem_cmp(&fs->win[n], GPT_EFISYS_GUID, sizeof(GPT_EFISYS_GUID))) {
+				// EFI System Partition. Ignore it.
+				continue;
+			}
+
+			br[idx++] = (DWORD)lba64_start;
+		}
+	}
+
+	// If br[] isn't full, set the last entry to 0.
+	if (idx < 128)
+		br[idx] = 0;
+
+	// Save the partition count.
+	if (part_count)
+		*part_count = idx;
+
+	// GPT partitions processed.
+	// We're not checking for FAT here, since find_volume() does that.
+	// If no valid partitions were found, return 1.
+	// Otherwise, return 0 to indicate we found at least one.
+	return (idx == 0 ? 1 : 0);
 }
 
 
@@ -2149,20 +2940,100 @@
 
 
 /*-----------------------------------------------------------------------*/
+/* Get the logical partitions from an Extended partition. (Nintendont)   */
+/*-----------------------------------------------------------------------*/
+static
+BYTE read_mbr_extended (/* 0:EBR is valid and partitions read, 1:No partitions found, 2:EBR is invalid, 3:Disk error */
+	FATFS* fs,      /* File system object */
+	DWORD sect,     /* Extended partition table header sector */
+	DWORD br[8],    /* Array to store partition LBAs in */
+	DWORD *part_count /* Number of partitions read (output) */
+)
+{
+	int n;			// Current EBR index.
+	int idx = 0;		// Index in br[] array. (partition count)
+	DWORD lba_part;		// Logical partition start.
+	DWORD lba_ebr_next;	// Next EBR.
+	BYTE *pt;		// Pointer to the partition table in the EBR.
+
+	// Read up to 8 Extended Partition Boot Records.
+	// Reference: https://en.wikipedia.org/wiki/Extended_boot_record
+	for (n = 0; n < 8; n++) {
+		// Read the current EBR.
+		fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invalidate window */
+		if (move_window(fs, sect) != FR_OK) {		/* Load sector */
+			// Could not load sector.
+			if (idx == 0) {
+				// No partitions found.
+				// Assume the entire Extended partition is invalid.
+				return 3;
+			}
+			break;
+		}
+
+		// Validate the EBR signature.
+		if (fs->win[510] != 0x55 || fs->win[511] != 0xAA) {
+			// Invalid EBR signature.
+			if (idx == 0) {
+				// No partitions found.
+				// Assume the entire Extended partition is invalid.
+				return 2;
+			}
+			break;
+		}
+
+		// EBR contains an MBR-like partition table.
+		// NOTE: All LBAs are relative to the EBR starting LBA.
+		// Partition 1: Logical partition.
+		// Partition 2: Next EBR, or 0 if end of Extended partition.
+		// Partitions 3 and 4 are unused.
+		pt = fs->win + MBR_Table;
+		lba_part = ld_dword(&pt[8]) + sect;
+		lba_ebr_next = ld_dword(&pt[8+SZ_PTE]) + sect;
+
+		// TODO: Validate lba_part?
+		br[idx++] = lba_part;
+		if (lba_ebr_next <= sect) {
+			// Finished reading the Extended partition.
+			break;
+		}
+		sect = lba_ebr_next;
+	}
+
+	// If br[] isn't full, set the last entry to 0.
+	if (idx < 8)
+		br[idx] = 0;
+
+	// Save the partition count.
+	if (part_count)
+		*part_count = idx;
+
+	// EBR partitions processed.
+	// We're not checking for FAT here, since find_volume() does that.
+	// If no valid partitions were found, return 1.
+	// Otherwise, return 0 to indicate we found at least one.
+	return (idx == 0 ? 1 : 0);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
 /* Find logical drive and check if the volume is mounted                 */
 /*-----------------------------------------------------------------------*/
 
 static
 FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
+	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
 	FATFS** rfs,		/* Pointer to pointer to the found file system object */
-	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
-	BYTE wmode			/* !=0: Check write protection for write access */
+	BYTE mode			/* !=0: Check write protection for write access */
 )
 {
 	BYTE fmt, *pt;
 	int vol;
 	DSTATUS stat;
-	DWORD bsect, fasize, tsect, sysect, nclst, szbfat, br[4];
+	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
+	DWORD br[128];	// 128 for GPT support; MBR only uses 4.
 	WORD nrsv;
 	FATFS *fs;
 	UINT i;
@@ -2180,11 +3051,13 @@
 	ENTER_FF(fs);						/* Lock the volume */
 	*rfs = fs;							/* Return pointer to the file system object */
 
+	mode &= ~FA_READ;					/* Desired access mode, write access or not */
 	if (fs->fs_type) {					/* If the volume has been mounted */
 		stat = disk_status(fs->drv);
 		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
-			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
+			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 				return FR_WRITE_PROTECTED;
+			}
 			return FR_OK;				/* The file system object is valid */
 		}
 	}
@@ -2195,10 +3068,12 @@
 	fs->fs_type = 0;					/* Clear the file system object */
 	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
-	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
+	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
-	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
+	}
+	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
 		return FR_WRITE_PROTECTED;
+	}
 #if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
 	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
 		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
@@ -2205,112 +3080,189 @@
 #endif
 	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
 	bsect = 0;
-	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
-	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
-		for (i = 0; i < 4; i++) {			/* Get partition offset */
-			pt = fs->win + MBR_Table + i * SZ_PTE;
-			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
+	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT boot sector as SFD */
+	if (fmt == 2 || (fmt < 2 && LD2PT(vol))) {	/* Not an FAT boot sector or forced partition number */
+		/* Check for GPT. */
+		DWORD part_count = 0;
+		pt = fs->win + MBR_Table;
+		if (pt[4] == 0xEE) {
+			/* GPT found. Read up to the first four paritions. */
+			bsect = ld_dword(&pt[8]);
+			fmt = read_gpt(fs, bsect, br, &part_count);
+			if (fmt != 0) return FR_DISK_ERR;
+		} else {
+			/* Not GPT. Check the MBR partitions. */
+			int mbr_idx;		// MBR partition index
+			DWORD ebr_count;	// Extended partition count from read_mbr_extended()
+			int ebr_fmt;		// read_mbr_extended() return value.
+			for (mbr_idx = 0; mbr_idx < 4; mbr_idx++) {     /* Get partition offset */
+				pt = fs->win + MBR_Table + mbr_idx * SZ_PTE;
+				switch (pt[4]) {
+					case 0:
+						br[part_count++] = 0;
+						break;
+					case 0xF:
+						// Extended partition.
+						// FIXME: Disable if LD2PT(vol) != 0?
+						bsect = ld_dword(&pt[8]);
+						ebr_fmt = read_mbr_extended(fs, bsect, &br[part_count], &ebr_count);
+						if (ebr_fmt > 1) return FR_DISK_ERR;
+						part_count += ebr_count;
+						break;
+					default:
+						// Primary partition.
+						br[part_count++] = pt[4] ? ld_dword(&pt[8]) : 0;
+						break;
+				}
+			}
 		}
 		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
 		if (i) i--;
 		do {								/* Find an FAT volume */
 			bsect = br[i];
-			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
-		} while (!LD2PT(vol) && fmt && ++i < 4);
+			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
+		} while (!LD2PT(vol) && fmt >= 2 && ++i < part_count);
 	}
-	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
-	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
+	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
+	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 
 	/* An FAT volume is found. Following code initializes the file system object */
 
-	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
-		return FR_NO_FILESYSTEM;
+#if _FS_EXFAT
+	if (fmt == 1) {
+		QWORD maxlba;
 
-	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
-	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
-	fs->fsize = fasize;
+		for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && !fs->win[i]; i++) ;	/* Check zero filler */
+		if (i < BPB_ZeroedEx + 53) return FR_NO_FILESYSTEM;
 
-	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
-	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
-		return FR_NO_FILESYSTEM;
-	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
+		if (ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;	/* Check exFAT revision (Must be 1.0) */
 
-	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
-	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
-		return FR_NO_FILESYSTEM;
+		if (1 << fs->win[BPB_BytsPerSecEx] != SS(fs))	/* (BPB_BytsPerSecEx must be equal to the physical sector size) */
+			return FR_NO_FILESYSTEM;
 
-	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
-	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
-		return FR_NO_FILESYSTEM;
+		maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Number of sectors on the volume */
+		if (maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be handled in 32-bit LBA) */
 
-	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
-	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
+		fs->fsize = ld_dword(fs->win + BPB_FatSzEx);	/* Number of sectors per FAT */
 
-	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
-	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
+		fs->n_fats = fs->win[BPB_NumFATsEx];			/* Number of FATs */
+		if (fs->n_fats != 1) return FR_NO_FILESYSTEM;	/* (Must be 1) */
 
-	/* Determine the FAT sub type */
-	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
-	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
-	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
-	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
-	fmt = FS_FAT12;
-	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
-	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
+		fs->csize = 1 << fs->win[BPB_SecPerClusEx];		/* Cluster size */
+		if (fs->csize == 0)	return FR_NO_FILESYSTEM;	/* (Must be 1..32768) */
 
-	/* Boundaries and Limits */
-	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
-	fs->volbase = bsect;								/* Volume start sector */
-	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
-	fs->database = bsect + sysect;						/* Data start sector */
-	if (fmt == FS_FAT32) {
-		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
-		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
-		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
-	} else {
-		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
-		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
-		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
-			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
-	}
-	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
-		return FR_NO_FILESYSTEM;
+		nclst = ld_dword(fs->win + BPB_NumClusEx);		/* Number of clusters */
+		fs->n_fatent = nclst + 2;
+		if (fs->n_fatent >= 0x80000000) return FR_NO_FILESYSTEM;	/* (Must be <= 0x7FFFFFFF) */
 
+		/* Boundaries and Limits */
+		fs->volbase = bsect;
+		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
+		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
+		if (maxlba < fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
+		fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);
+
+		/* Check if bitmap location is in assumption (at the first cluster) */
+		if (move_window(fs, clust2sect(fs, fs->dirbase)) != FR_OK) return FR_DISK_ERR;
+		for (i = 0; i < SS(fs); i += SZDIRE) {
+			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
+		}
+		if (i == SS(fs)) return FR_NO_FILESYSTEM;
 #if !_FS_READONLY
-	/* Initialize cluster allocation information */
-	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
+		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
+#endif
+#if _USE_LFN == 1
+		fs->dirbuf = DirBuf;	/* Static directory block working buuffer */
+#endif
+		fmt = FS_EXFAT;			/* FAT sub-type */
+	} else
+#endif
+	{
+		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 
-	/* Get fsinfo if available */
-	fs->fsi_flag = 0x80;
+		fasize = ld_word(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
+		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
+		fs->fsize = fasize;
+
+		fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FATs */
+		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
+		fasize *= fs->n_fats;								/* Number of sectors for FAT area */
+
+		fs->csize = fs->win[BPB_SecPerClus];				/* Cluster size */
+		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
+
+		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
+		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
+
+		tsect = ld_word(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
+		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
+
+		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
+		if (nrsv == 0) return FR_NO_FILESYSTEM;				/* (Must not be 0) */
+
+		/* Determine the FAT sub type */
+		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
+		if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
+		nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
+		if (nclst == 0) return FR_NO_FILESYSTEM;			/* (Invalid volume size) */
+		fmt = FS_FAT12;
+		if (nclst >= MIN_FAT16) fmt = FS_FAT16;
+		if (nclst >= MIN_FAT32) fmt = FS_FAT32;
+
+		/* Boundaries and Limits */
+		fs->n_fatent = nclst + 2;							/* Number of FAT entries */
+		fs->volbase = bsect;								/* Volume start sector */
+		fs->fatbase = bsect + nrsv; 						/* FAT start sector */
+		fs->database = bsect + sysect;						/* Data start sector */
+		if (fmt == FS_FAT32) {
+			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
+			if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
+			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
+			szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
+		} else {
+			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
+			fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
+			szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
+				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
+		}
+		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
+
+#if !_FS_READONLY
+		/* Initialize cluster allocation information */
+		fs->last_clst = fs->free_clst = 0xFFFFFFFF;
+
+		/* Get FSINFO if available */
+		fs->fsi_flag = 0x80;
 #if (_FS_NOFSINFO & 3) != 3
-	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
-		&& LD_WORD(fs->win + BPB_FSInfo) == 1
-		&& move_window(fs, bsect + 1) == FR_OK)
-	{
-		fs->fsi_flag = 0;
-		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
-			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
-			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
+		if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo32 == 1 */
+			&& ld_word(fs->win + BPB_FSInfo32) == 1
+			&& move_window(fs, bsect + 1) == FR_OK)
 		{
+			fs->fsi_flag = 0;
+			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
+				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
+				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
+			{
 #if (_FS_NOFSINFO & 1) == 0
-			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
+				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
 #endif
 #if (_FS_NOFSINFO & 2) == 0
-			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
+				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 #endif
+			}
 		}
-	}
 #endif
 #endif
+	}
+
 	fs->fs_type = fmt;	/* FAT sub-type */
 	fs->id = ++Fsid;	/* File system mount ID */
-#if _FS_RPATH
-	fs->cdir = 0;		/* Set current directory to root */
+#if _FS_RPATH != 0
+	fs->cdir = 0;		/* Initialize current directory */
 #endif
-#if _FS_LOCK			/* Clear file lock semaphores */
+#if _FS_LOCK != 0		/* Clear file lock semaphores */
 	clear_lock(fs);
 #endif
-
 	return FR_OK;
 }
 
@@ -2322,32 +3274,34 @@
 /*-----------------------------------------------------------------------*/
 
 static
-FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
-	void* obj		/* Pointer to the object FIL/DIR to check validity */
+FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
+	void* dfp,		/* Pointer to the FIL/DIR object to check validity */
+	FATFS** fs		/* Pointer to pointer to the owner file system object to return */
 )
 {
-	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */
+	_FDID *obj = (_FDID*)dfp;	/* Assuming .obj in the FIL/DIR is the first member */
+	FRESULT res;
 
 
-	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
-		return FR_INVALID_OBJECT;
-
-	ENTER_FF(fil->fs);		/* Lock file system */
-
-	if (disk_status(fil->fs->drv) & STA_NOINIT)
-		return FR_NOT_READY;
-
-	return FR_OK;
+	if (!dfp || !obj->fs || !obj->fs->fs_type || obj->fs->id != obj->id || (disk_status(obj->fs->drv) & STA_NOINIT)) {
+		*fs = 0;				/* The object is invalid */
+		res = FR_INVALID_OBJECT;
+	} else {
+		*fs = obj->fs;			/* Owner file sytem object */
+		ENTER_FF(obj->fs);		/* Lock file system */
+		res = FR_OK;
+	}
+	return res;
 }
 
 
 
 
-/*--------------------------------------------------------------------------
+/*---------------------------------------------------------------------------
 
-   Public Functions
+   Public Functions (FatFs API)
 
---------------------------------------------------------------------------*/
+----------------------------------------------------------------------------*/
 
 
 
@@ -2358,7 +3312,7 @@
 FRESULT f_mount (
 	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
 	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
-	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
+	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
 )
 {
 	FATFS *cfs;
@@ -2372,7 +3326,7 @@
 	cfs = FatFs[vol];					/* Pointer to fs object */
 
 	if (cfs) {
-#if _FS_LOCK
+#if _FS_LOCK != 0
 		clear_lock(cfs);
 #endif
 #if _FS_REENTRANT						/* Discard sync object of the current volume */
@@ -2391,7 +3345,7 @@
 
 	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 
-	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
+	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 	LEAVE_FF(fs, res);
 }
 
@@ -2410,35 +3364,32 @@
 {
 	FRESULT res;
 	DIR dj;
-	BYTE *dir;
-	DEFINE_NAMEBUF;
+	FATFS *fs;
 #if !_FS_READONLY
 	DWORD dw, cl;
 #endif
+	DEF_NAMBUF;
 
 
 	if (!fp) return FR_INVALID_OBJECT;
-	fp->fs = 0;			/* Clear file object */
+	fp->obj.fs = 0;		/* Clear file object */
 
 	/* Get logical drive number */
-#if !_FS_READONLY
-	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
-	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
-#else
-	mode &= FA_READ;
-	res = find_volume(&dj.fs, &path, 0);
-#endif
+	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
+	res = find_volume(&path, &fs, mode);
 	if (res == FR_OK) {
-		INIT_BUF(dj);
+		dj.obj.fs = fs;
+		INIT_NAMBUF(dj);
 		res = follow_path(&dj, path);	/* Follow the file path */
-		dir = dj.dir;
 #if !_FS_READONLY	/* R/W configuration */
 		if (res == FR_OK) {
-			if (!dir)	/* Default directory itself */
+			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 				res = FR_INVALID_NAME;
-#if _FS_LOCK
-			else
+			}
+#if _FS_LOCK != 0
+			else {
 				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
+			}
 #endif
 		}
 		/* Create or Open a file */
@@ -2445,90 +3396,130 @@
 		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 			if (res != FR_OK) {					/* No file, create new */
 				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
-#if _FS_LOCK
+#if _FS_LOCK != 0
 					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 #else
 					res = dir_register(&dj);
 #endif
 				mode |= FA_CREATE_ALWAYS;		/* File is created */
-				dir = dj.dir;					/* New entry */
 			}
 			else {								/* Any object is already existing */
-				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
+				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 					res = FR_DENIED;
 				} else {
-					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
-						res = FR_EXIST;
+					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 				}
 			}
 			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
-				dw = GET_FATTIME();				/* Created time */
-				ST_DWORD(dir + DIR_CrtTime, dw);
-				dir[DIR_Attr] = 0;				/* Reset attribute */
-				ST_DWORD(dir + DIR_FileSize, 0);/* size = 0 */
-				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
-				st_clust(dir, 0);				/* cluster = 0 */
-				dj.fs->wflag = 1;
-				if (cl) {						/* Remove the cluster chain if exist */
-					dw = dj.fs->winsect;
-					res = remove_chain(dj.fs, cl);
-					if (res == FR_OK) {
-						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
-						res = move_window(dj.fs, dw);
+				dw = GET_FATTIME();
+#if _FS_EXFAT
+				if (fs->fs_type == FS_EXFAT) {
+					/* Get current allocation info */
+					fp->obj.fs = fs;
+					fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);
+					fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
+					fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
+					/* Initialize directory entry block */
+					st_dword(fs->dirbuf + XDIR_CrtTime, dw);	/* Set created time */
+					fs->dirbuf[XDIR_CrtTime10] = 0;
+					st_dword(fs->dirbuf + XDIR_ModTime, dw);	/* Set modified time */
+					fs->dirbuf[XDIR_ModTime10] = 0;
+					fs->dirbuf[XDIR_Attr] = AM_ARC;				/* Reset attribute */
+					st_dword(fs->dirbuf + XDIR_FstClus, 0);		/* Reset file allocation info */
+					st_qword(fs->dirbuf + XDIR_FileSize, 0);
+					st_qword(fs->dirbuf + XDIR_ValidFileSize, 0);
+					fs->dirbuf[XDIR_GenFlags] = 1;
+					res = store_xdir(&dj);
+					if (res == FR_OK && fp->obj.sclust) {		/* Remove the cluster chain if exist */
+						res = remove_chain(&fp->obj, fp->obj.sclust, 0);
+						fs->last_clst = fp->obj.sclust - 1;		/* Reuse the cluster hole */
 					}
+				} else
+#endif
+				{
+					/* Clean directory info */
+					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
+					st_dword(dj.dir + DIR_WrtTime, dw);	/* Set modified time */
+					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
+					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
+					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
+					st_dword(dj.dir + DIR_FileSize, 0);
+					fs->wflag = 1;
+
+					if (cl) {							/* Remove the cluster chain if exist */
+						dw = fs->winsect;
+						res = remove_chain(&dj.obj, cl, 0);
+						if (res == FR_OK) {
+							res = move_window(fs, dw);
+							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
+						}
+					}
 				}
 			}
 		}
 		else {	/* Open an existing file */
-			if (res == FR_OK) {					/* Follow succeeded */
-				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
+			if (res == FR_OK) {					/* Following succeeded */
+				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
 					res = FR_NO_FILE;
 				} else {
-					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
+					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
 						res = FR_DENIED;
+					}
 				}
 			}
 		}
 		if (res == FR_OK) {
 			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
-				mode |= FA__WRITTEN;
-			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
-			fp->dir_ptr = dir;
-#if _FS_LOCK
-			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
-			if (!fp->lockid) res = FR_INT_ERR;
+				mode |= _FA_MODIFIED;
+			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
+			fp->dir_ptr = dj.dir;
+#if _FS_LOCK != 0
+			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
+			if (!fp->obj.lockid) res = FR_INT_ERR;
 #endif
 		}
-
-#else				/* R/O configuration */
-		if (res == FR_OK) {					/* Follow succeeded */
-			dir = dj.dir;
-			if (!dir) {						/* Current directory itself */
+#else		/* R/O configuration */
+		if (res == FR_OK) {
+			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 				res = FR_INVALID_NAME;
 			} else {
-				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
+				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
 					res = FR_NO_FILE;
+				}
 			}
 		}
 #endif
-		FREE_BUF();
 
 		if (res == FR_OK) {
-			fp->flag = mode;					/* File access mode */
-			fp->err = 0;						/* Clear error flag */
-			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
-			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
-			fp->fptr = 0;						/* File pointer */
-			fp->dsect = 0;
+#if _FS_EXFAT
+			if (fs->fs_type == FS_EXFAT) {
+				fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Get allocation info */
+				fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
+				fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
+				fp->obj.c_scl = dj.obj.sclust;
+				fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
+				fp->obj.c_ofs = dj.blk_ofs;
+			} else
+#endif
+			{
+				fp->obj.sclust = ld_clust(fs, dj.dir);				/* Get allocation info */
+				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
+			}
 #if _USE_FASTSEEK
-			fp->cltbl = 0;						/* Normal seek mode */
+			fp->cltbl = 0;			/* Normal seek mode */
 #endif
-			fp->fs = dj.fs;	 					/* Validate file object */
-			fp->id = fp->fs->id;
+			fp->err = 0;			/* Clear error flag */
+			fp->fptr = 0;			/* Set file pointer */
+			fp->sect = 0;			/* Invalidate current data sector */
+			fp->flag = mode;		/* File access mode */
+			fp->obj.fs = fs;	 	/* Validate the file object */
+			fp->obj.id = fs->id;
 		}
+
+		FREE_NAMBUF();
 	}
 
-	LEAVE_FF(dj.fs, res);
+	LEAVE_FF(dj.obj.fs, res);
 }
 
 
@@ -2539,96 +3530,103 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_read (
-	FIL* fp, 		/* Pointer to the file object */
-	void* buff,		/* Pointer to data buffer */
-	UINT btr,		/* Number of bytes to read */
-	UINT* br		/* Pointer to number of bytes read */
+	FIL* fp, 	/* Pointer to the file object */
+	void* buff,	/* Pointer to data buffer */
+	UINT btr,	/* Number of bytes to read */
+	UINT* br	/* Pointer to number of bytes read */
 )
 {
 	FRESULT res;
-	DWORD clst, sect, remain;
-	UINT rcnt, cc;
-	BYTE csect, *rbuff = (BYTE*)buff;
+	FATFS *fs;
+	DWORD clst, sect;
+	FSIZE_t remain;
+	UINT rcnt, cc, csect;
+	BYTE *rbuff = (BYTE*)buff;
 
 
 	*br = 0;	/* Clear read byte counter */
-
-	res = validate(fp);							/* Check validity */
-	if (res != FR_OK) LEAVE_FF(fp->fs, res);
-	if (fp->err)								/* Check error */
-		LEAVE_FF(fp->fs, (FRESULT)fp->err);
-	if (!(fp->flag & FA_READ)) 					/* Check access mode */
-		LEAVE_FF(fp->fs, FR_DENIED);
-	remain = fp->fsize - fp->fptr;
+	res = validate(fp, &fs);
+	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
+	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
+	remain = fp->obj.objsize - fp->fptr;
 	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 
 	for ( ;  btr;								/* Repeat until all data read */
 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
-		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
-			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
-			if (!csect) {						/* On the cluster boundary? */
+		if ((fp->fptr % SS(fs)) == 0) {			/* On the sector boundary? */
+			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
+			if (csect == 0) {					/* On the cluster boundary? */
 				if (fp->fptr == 0) {			/* On the top of the file? */
-					clst = fp->sclust;			/* Follow from the origin */
+					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 				} else {						/* Middle or end of the file */
 #if _USE_FASTSEEK
-					if (fp->cltbl)
+					if (fp->cltbl) {
 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
-					else
+					} else
 #endif
-						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
+					{
+						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
+					}
 				}
-				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
-				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
+				if (clst < 2) ABORT(fs, FR_INT_ERR);
+				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 				fp->clust = clst;				/* Update current cluster */
 			}
-			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
-			if (!sect) ABORT(fp->fs, FR_INT_ERR);
+			sect = clust2sect(fs, fp->clust);	/* Get current sector */
+			if (!sect) ABORT(fs, FR_INT_ERR);
 			sect += csect;
-			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
+			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
 			if (cc) {							/* Read maximum contiguous sectors directly */
-				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
-					cc = fp->fs->csize - csect;
-				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
-					ABORT(fp->fs, FR_DISK_ERR);
+				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
+					cc = fs->csize - csect;
+				}
+				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) {
+					ABORT(fs, FR_DISK_ERR);
+				}
 #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
 #if _FS_TINY
-				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
-					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
+				if (fs->wflag && fs->winsect - sect < cc) {
+					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
+				}
 #else
-				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
-					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
+				if ((fp->flag & _FA_DIRTY) && fp->sect - sect < cc) {
+					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
+				}
 #endif
 #endif
-				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
+				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 				continue;
 			}
 #if !_FS_TINY
-			if (fp->dsect != sect) {			/* Load data sector if not in cache */
+			if (fp->sect != sect) {			/* Load data sector if not in cache */
 #if !_FS_READONLY
-				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
-					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
-						ABORT(fp->fs, FR_DISK_ERR);
-					fp->flag &= ~FA__DIRTY;
+				if (fp->flag & _FA_DIRTY) {		/* Write-back dirty sector cache */
+					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
+						ABORT(fs, FR_DISK_ERR);
+					}
+					fp->flag &= ~_FA_DIRTY;
 				}
 #endif
-				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
-					ABORT(fp->fs, FR_DISK_ERR);
+				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	{	/* Fill sector cache */
+					ABORT(fs, FR_DISK_ERR);
+				}
 			}
 #endif
-			fp->dsect = sect;
+			fp->sect = sect;
 		}
-		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
+		rcnt = SS(fs) - ((UINT)fp->fptr % SS(fs));	/* Get partial sector data from sector buffer */
 		if (rcnt > btr) rcnt = btr;
 #if _FS_TINY
-		if (move_window(fp->fs, fp->dsect) != FR_OK)		/* Move sector window */
-			ABORT(fp->fs, FR_DISK_ERR);
-		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
+		if (move_window(fs, fp->sect) != FR_OK) {	/* Move sector window */
+			ABORT(fs, FR_DISK_ERR);
+		}
+		mem_cpy(rbuff, &fs->win[fp->fptr % SS(fs)], rcnt);	/* Pick partial sector */
 #else
-		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
+		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fs)], rcnt);	/* Pick partial sector */
 #endif
 	}
 
-	LEAVE_FF(fp->fs, FR_OK);
+	LEAVE_FF(fs, FR_OK);
 }
 
 
@@ -2641,117 +3639,126 @@
 
 FRESULT f_write (
 	FIL* fp,			/* Pointer to the file object */
-	const void *buff,	/* Pointer to the data to be written */
+	const void* buff,	/* Pointer to the data to be written */
 	UINT btw,			/* Number of bytes to write */
 	UINT* bw			/* Pointer to number of bytes written */
 )
 {
 	FRESULT res;
+	FATFS *fs;
 	DWORD clst, sect;
-	UINT wcnt, cc;
+	UINT wcnt, cc, csect;
 	const BYTE *wbuff = (const BYTE*)buff;
-	BYTE csect;
 
 
 	*bw = 0;	/* Clear write byte counter */
+	res = validate(fp, &fs);
+	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
+	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 
-	res = validate(fp);						/* Check validity */
-	if (res != FR_OK) LEAVE_FF(fp->fs, res);
-	if (fp->err)							/* Check error */
-		LEAVE_FF(fp->fs, (FRESULT)fp->err);
-	if (!(fp->flag & FA_WRITE))				/* Check access mode */
-		LEAVE_FF(fp->fs, FR_DENIED);
-	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
+	/* Check fptr wrap-around (file size cannot exceed the limit on each FAT specs) */
+	if ((_FS_EXFAT && fs->fs_type == FS_EXFAT && fp->fptr + btw < fp->fptr)
+		|| (DWORD)fp->fptr + btw < (DWORD)fp->fptr) {
+		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
+	}
 
 	for ( ;  btw;							/* Repeat until all data written */
-		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
-		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
-			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
-			if (!csect) {					/* On the cluster boundary? */
+		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
+		if ((fp->fptr % SS(fs)) == 0) {		/* On the sector boundary? */
+			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
+			if (csect == 0) {				/* On the cluster boundary? */
 				if (fp->fptr == 0) {		/* On the top of the file? */
-					clst = fp->sclust;		/* Follow from the origin */
-					if (clst == 0)			/* When no cluster is allocated, */
-						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
-				} else {					/* Middle or end of the file */
+					clst = fp->obj.sclust;	/* Follow from the origin */
+					if (clst == 0) {		/* If no cluster is allocated, */
+						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
+					}
+				} else {					/* On the middle or end of the file */
 #if _USE_FASTSEEK
-					if (fp->cltbl)
+					if (fp->cltbl) {
 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
-					else
+					} else
 #endif
-						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
+					{
+						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
+					}
 				}
 				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
-				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
-				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
+				if (clst == 1) ABORT(fs, FR_INT_ERR);
+				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 				fp->clust = clst;			/* Update current cluster */
-				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
+				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 			}
 #if _FS_TINY
-			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
-				ABORT(fp->fs, FR_DISK_ERR);
+			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK)	{	/* Write-back sector cache */
+				ABORT(fs, FR_DISK_ERR);
+			}
 #else
-			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
-				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
-					ABORT(fp->fs, FR_DISK_ERR);
-				fp->flag &= ~FA__DIRTY;
+			if (fp->flag & _FA_DIRTY) {		/* Write-back sector cache */
+				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
+					ABORT(fs, FR_DISK_ERR);
+				}
+				fp->flag &= ~_FA_DIRTY;
 			}
 #endif
-			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
-			if (!sect) ABORT(fp->fs, FR_INT_ERR);
+			sect = clust2sect(fs, fp->clust);	/* Get current sector */
+			if (!sect) ABORT(fs, FR_INT_ERR);
 			sect += csect;
-			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
+			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
 			if (cc) {						/* Write maximum contiguous sectors directly */
-				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
-					cc = fp->fs->csize - csect;
-				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
-					ABORT(fp->fs, FR_DISK_ERR);
+				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
+					cc = fs->csize - csect;
+				}
+				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) {
+					ABORT(fs, FR_DISK_ERR);
+				}
 #if _FS_MINIMIZE <= 2
 #if _FS_TINY
-				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
-					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
-					fp->fs->wflag = 0;
+				if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
+					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
+					fs->wflag = 0;
 				}
 #else
-				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
-					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
-					fp->flag &= ~FA__DIRTY;
+				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
+					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
+					fp->flag &= ~_FA_DIRTY;
 				}
 #endif
 #endif
-				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
+				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
 				continue;
 			}
 #if _FS_TINY
-			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
-				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
-				fp->fs->winsect = sect;
+			if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling at growing edge */
+				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
+				fs->winsect = sect;
 			}
 #else
-			if (fp->dsect != sect) {		/* Fill sector cache with file data */
-				if (fp->fptr < fp->fsize &&
-					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
-						ABORT(fp->fs, FR_DISK_ERR);
+			if (fp->sect != sect) {		/* Fill sector cache with file data */
+				if (fp->fptr < fp->obj.objsize &&
+					disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) {
+						ABORT(fs, FR_DISK_ERR);
+				}
 			}
 #endif
-			fp->dsect = sect;
+			fp->sect = sect;
 		}
-		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
+		wcnt = SS(fs) - ((UINT)fp->fptr % SS(fs));	/* Put partial sector into file I/O buffer */
 		if (wcnt > btw) wcnt = btw;
 #if _FS_TINY
-		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
-			ABORT(fp->fs, FR_DISK_ERR);
-		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
-		fp->fs->wflag = 1;
+		if (move_window(fs, fp->sect) != FR_OK) {	/* Move sector window */
+			ABORT(fs, FR_DISK_ERR);
+		}
+		mem_cpy(&fs->win[fp->fptr % SS(fs)], wbuff, wcnt);	/* Fit partial sector */
+		fs->wflag = 1;
 #else
-		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
-		fp->flag |= FA__DIRTY;
+		mem_cpy(&fp->buf[fp->fptr % SS(fs)], wbuff, wcnt);	/* Fit partial sector */
+		fp->flag |= _FA_DIRTY;
 #endif
 	}
 
-	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
-	fp->flag |= FA__WRITTEN;						/* Set file change flag */
+	fp->flag |= _FA_MODIFIED;						/* Set file change flag */
 
-	LEAVE_FF(fp->fs, FR_OK);
+	LEAVE_FF(fs, FR_OK);
 }
 
 
@@ -2766,39 +3773,70 @@
 )
 {
 	FRESULT res;
+	FATFS *fs;
 	DWORD tm;
 	BYTE *dir;
+	DEF_DIRBUF;
 
 
-	res = validate(fp);					/* Check validity of the object */
+	res = validate(fp, &fs);	/* Check validity of the object */
 	if (res == FR_OK) {
-		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
-			/* Write-back dirty buffer */
+		if (fp->flag & _FA_MODIFIED) {	/* Is there any change to the file? */
 #if !_FS_TINY
-			if (fp->flag & FA__DIRTY) {
-				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
-					LEAVE_FF(fp->fs, FR_DISK_ERR);
-				fp->flag &= ~FA__DIRTY;
+			if (fp->flag & _FA_DIRTY) {	/* Write-back cached data if needed */
+				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
+					LEAVE_FF(fs, FR_DISK_ERR);
+				}
+				fp->flag &= ~_FA_DIRTY;
 			}
 #endif
 			/* Update the directory entry */
-			res = move_window(fp->fs, fp->dir_sect);
-			if (res == FR_OK) {
-				dir = fp->dir_ptr;
-				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
-				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
-				st_clust(dir, fp->sclust);					/* Update start cluster */
-				tm = GET_FATTIME();							/* Update updated time */
-				ST_DWORD(dir + DIR_WrtTime, tm);
-				ST_WORD(dir + DIR_LstAccDate, 0);
-				fp->flag &= ~FA__WRITTEN;
-				fp->fs->wflag = 1;
-				res = sync_fs(fp->fs);
+			tm = GET_FATTIME();				/* Modified time */
+#if _FS_EXFAT
+			if (fs->fs_type == FS_EXFAT) {
+				res = fill_fat_chain(&fp->obj);	/* Create FAT chain if needed */
+				if (res == FR_OK) {
+					DIR dj;
+
+					INIT_DIRBUF(fs);
+					res = load_obj_dir(&dj, &fp->obj);	/* Load directory entry block */
+					if (res == FR_OK) {
+						fs->dirbuf[XDIR_Attr] |= AM_ARC;					/* Set archive bit */
+						fs->dirbuf[XDIR_GenFlags] = fp->obj.stat | 1;		/* Update file allocation info */
+						st_dword(fs->dirbuf + XDIR_FstClus, fp->obj.sclust);
+						st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);
+						st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);
+						st_dword(fs->dirbuf + XDIR_ModTime, tm);			/* Update modified time */
+						fs->dirbuf[XDIR_ModTime10] = 0;
+						st_dword(fs->dirbuf + XDIR_AccTime, 0);
+						res = store_xdir(&dj);	/* Restore it to the directory */
+						if (res == FR_OK) {
+							res = sync_fs(fs);
+							fp->flag &= ~_FA_MODIFIED;
+						}
+					}
+					FREE_DIRBUF();
+				}
+			} else
+#endif
+			{
+				res = move_window(fs, fp->dir_sect);
+				if (res == FR_OK) {
+					dir = fp->dir_ptr;
+					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
+					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
+					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
+					st_dword(dir + DIR_WrtTime, tm);				/* Update modified time */
+					st_word(dir + DIR_LstAccDate, 0);
+					fs->wflag = 1;
+					res = sync_fs(fs);					/* Restore it to the directory */
+					fp->flag &= ~_FA_MODIFIED;
+				}
 			}
 		}
 	}
 
-	LEAVE_FF(fp->fs, res);
+	LEAVE_FF(fs, res);
 }
 
 #endif /* !_FS_READONLY */
@@ -2811,27 +3849,26 @@
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_close (
-	FIL *fp		/* Pointer to the file object to be closed */
+	FIL* fp		/* Pointer to the file object to be closed */
 )
 {
 	FRESULT res;
+	FATFS *fs;
 
-
 #if !_FS_READONLY
 	res = f_sync(fp);					/* Flush cached data */
 	if (res == FR_OK)
 #endif
 	{
-		res = validate(fp);				/* Lock volume */
+		res = validate(fp, &fs);	/* Lock volume */
 		if (res == FR_OK) {
-#if _FS_REENTRANT
-			FATFS *fs = fp->fs;
-#endif
-#if _FS_LOCK
-			res = dec_lock(fp->lockid);	/* Decrement file open counter */
+#if _FS_LOCK != 0
+			res = dec_lock(fp->obj.lockid);	/* Decrement file open counter */
 			if (res == FR_OK)
 #endif
-				fp->fs = 0;				/* Invalidate file object */
+			{
+				fp->obj.fs = 0;			/* Invalidate file object */
+			}
 #if _FS_REENTRANT
 			unlock_fs(fs, FR_OK);		/* Unlock volume */
 #endif
@@ -2872,29 +3909,48 @@
 {
 	FRESULT res;
 	DIR dj;
-	DEFINE_NAMEBUF;
+	FATFS *fs;
+	DEF_NAMBUF;
 
-
 	/* Get logical drive number */
-	res = find_volume(&dj.fs, &path, 0);
+	res = find_volume(&path, &fs, 0);
 	if (res == FR_OK) {
-		INIT_BUF(dj);
+		dj.obj.fs = fs;
+		INIT_NAMBUF(dj);
 		res = follow_path(&dj, path);		/* Follow the path */
-		FREE_BUF();
 		if (res == FR_OK) {					/* Follow completed */
-			if (!dj.dir) {
-				dj.fs->cdir = dj.sclust;	/* Start directory itself */
+			if (dj.fn[NSFLAG] & NS_NONAME) {
+				fs->cdir = dj.obj.sclust;	/* It is the start directory itself */
+#if _FS_EXFAT
+				if (fs->fs_type == FS_EXFAT) {
+					fs->cdc_scl = dj.obj.c_scl;
+					fs->cdc_size = dj.obj.c_size;
+					fs->cdc_ofs = dj.obj.c_ofs;
+				}
+#endif
 			} else {
-				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
-					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
-				else
+				if (dj.obj.attr & AM_DIR) {	/* It is a sub-directory */
+#if _FS_EXFAT
+					if (fs->fs_type == FS_EXFAT) {
+						fs->cdir = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Sub-directory cluster */
+						fs->cdc_scl = dj.obj.sclust;						/* Save containing directory information */
+						fs->cdc_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
+						fs->cdc_ofs = dj.blk_ofs;
+					} else
+#endif
+					{
+						fs->cdir = ld_clust(fs, dj.dir);					/* Sub-directory cluster */
+					}
+				} else {
 					res = FR_NO_PATH;		/* Reached but a file */
+				}
 			}
 		}
+		FREE_NAMBUF();
 		if (res == FR_NO_FILE) res = FR_NO_PATH;
 	}
 
-	LEAVE_FF(dj.fs, res);
+	LEAVE_FF(fs, res);
 }
 
 
@@ -2906,51 +3962,47 @@
 {
 	FRESULT res;
 	DIR dj;
+	FATFS *fs;
 	UINT i, n;
 	DWORD ccl;
 	TCHAR *tp;
 	FILINFO fno;
-	DEFINE_NAMEBUF;
+	DEF_NAMBUF;
 
 
 	*buff = 0;
 	/* Get logical drive number */
-	res = find_volume(&dj.fs, (const TCHAR**)&buff, 0);	/* Get current volume */
+	res = find_volume((const TCHAR**)&buff, &fs, 0);	/* Get current volume */
 	if (res == FR_OK) {
-		INIT_BUF(dj);
+		dj.obj.fs = fs;
+		INIT_NAMBUF(dj);
 		i = len;			/* Bottom of buffer (directory stack base) */
-		dj.sclust = dj.fs->cdir;			/* Start to follow upper directory from current directory */
-		while ((ccl = dj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
-			res = dir_sdi(&dj, 1);			/* Get parent directory */
-			if (res != FR_OK) break;
-			res = dir_read(&dj, 0);
-			if (res != FR_OK) break;
-			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent directory */
-			res = dir_sdi(&dj, 0);
-			if (res != FR_OK) break;
-			do {							/* Find the entry links to the child directory */
-				res = dir_read(&dj, 0);
+		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* (Cannot do getcwd on exFAT and returns root path) */
+			dj.obj.sclust = fs->cdir;				/* Start to follow upper directory from current directory */
+			while ((ccl = dj.obj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
+				res = dir_sdi(&dj, 1 * SZDIRE);	/* Get parent directory */
 				if (res != FR_OK) break;
-				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
-				res = dir_next(&dj, 0);	
-			} while (res == FR_OK);
-			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
-			if (res != FR_OK) break;
-#if _USE_LFN
-			fno.lfname = buff;
-			fno.lfsize = i;
-#endif
-			get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
-			tp = fno.fname;
-#if _USE_LFN
-			if (*buff) tp = buff;
-#endif
-			for (n = 0; tp[n]; n++) ;
-			if (i < n + 3) {
-				res = FR_NOT_ENOUGH_CORE; break;
+				res = move_window(fs, dj.sect);
+				if (res != FR_OK) break;
+				dj.obj.sclust = ld_clust(fs, dj.dir);	/* Goto parent directory */
+				res = dir_sdi(&dj, 0);
+				if (res != FR_OK) break;
+				do {							/* Find the entry links to the child directory */
+					res = dir_read(&dj, 0);
+					if (res != FR_OK) break;
+					if (ccl == ld_clust(fs, dj.dir)) break;	/* Found the entry */
+					res = dir_next(&dj, 0);
+				} while (res == FR_OK);
+				if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
+				if (res != FR_OK) break;
+				get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
+				for (n = 0; fno.fname[n]; n++) ;
+				if (i < n + 3) {
+					res = FR_NOT_ENOUGH_CORE; break;
+				}
+				while (n) buff[--i] = fno.fname[--n];
+				buff[--i] = '/';
 			}
-			while (n) buff[--i] = tp[--n];
-			buff[--i] = '/';
 		}
 		tp = buff;
 		if (res == FR_OK) {
@@ -2967,10 +4019,10 @@
 			}
 		}
 		*tp = 0;
-		FREE_BUF();
+		FREE_NAMBUF();
 	}
 
-	LEAVE_FF(dj.fs, res);
+	LEAVE_FF(fs, res);
 }
 #endif /* _FS_RPATH >= 2 */
 #endif /* _FS_RPATH >= 1 */
@@ -2984,27 +4036,25 @@
 
 FRESULT f_lseek (
 	FIL* fp,		/* Pointer to the file object */
-	DWORD ofs		/* File pointer from top of file */
+	FSIZE_t ofs		/* File pointer from top of file */
 )
 {
 	FRESULT res;
-	DWORD clst, bcs, nsect, ifptr;
+	FATFS *fs;
+	DWORD clst, bcs, nsect;
+	FSIZE_t ifptr;
 #if _USE_FASTSEEK
 	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
 #endif
 
-
-	res = validate(fp);					/* Check validity of the object */
-	if (res != FR_OK) LEAVE_FF(fp->fs, res);
-	if (fp->err)						/* Check error */
-		LEAVE_FF(fp->fs, (FRESULT)fp->err);
-
+	res = validate(fp, &fs);		/* Check validity of the object */
+	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 #if _USE_FASTSEEK
 	if (fp->cltbl) {	/* Fast seek */
 		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
 			tbl = fp->cltbl;
 			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
-			cl = fp->sclust;			/* Top of the chain */
+			cl = fp->obj.sclust;		/* Top of the chain */
 			if (cl) {
 				do {
 					/* Get a fragment */
@@ -3011,43 +4061,44 @@
 					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 					do {
 						pcl = cl; ncl++;
-						cl = get_fat(fp->fs, cl);
-						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
-						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
+						cl = get_fat(&fp->obj, cl);
+						if (cl <= 1) ABORT(fs, FR_INT_ERR);
+						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 					} while (cl == pcl + 1);
 					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 						*tbl++ = ncl; *tbl++ = tcl;
 					}
-				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
+				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
 			}
 			*fp->cltbl = ulen;	/* Number of items used */
-			if (ulen <= tlen)
+			if (ulen <= tlen) {
 				*tbl = 0;		/* Terminate table */
-			else
+			} else {
 				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
-
+			}
 		} else {						/* Fast seek */
-			if (ofs > fp->fsize)		/* Clip offset at the file size */
-				ofs = fp->fsize;
+			if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
 			fp->fptr = ofs;				/* Set file pointer */
 			if (ofs) {
 				fp->clust = clmt_clust(fp, ofs - 1);
-				dsc = clust2sect(fp->fs, fp->clust);
-				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
-				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
-				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
+				dsc = clust2sect(fs, fp->clust);
+				if (!dsc) ABORT(fs, FR_INT_ERR);
+				dsc += (ofs - 1) / SS(fs) & (fs->csize - 1);
+				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 #if !_FS_TINY
 #if !_FS_READONLY
-					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
-						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
-							ABORT(fp->fs, FR_DISK_ERR);
-						fp->flag &= ~FA__DIRTY;
+					if (fp->flag & _FA_DIRTY) {		/* Write-back dirty sector cache */
+						if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
+							ABORT(fs, FR_DISK_ERR);
+						}
+						fp->flag &= ~_FA_DIRTY;
 					}
 #endif
-					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
-						ABORT(fp->fs, FR_DISK_ERR);
+					if (disk_read(fs->drv, fp->buf, dsc, 1) != RES_OK) {	/* Load current sector */
+						ABORT(fs, FR_DISK_ERR);
+					}
 #endif
-					fp->dsect = dsc;
+					fp->sect = dsc;
 				}
 			}
 		}
@@ -3056,16 +4107,16 @@
 
 	/* Normal Seek */
 	{
-		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
+		if (ofs > fp->obj.objsize				/* In read-only mode, clip offset with the file size */
 #if !_FS_READONLY
 			 && !(fp->flag & FA_WRITE)
 #endif
-			) ofs = fp->fsize;
+			) ofs = fp->obj.objsize;
 
 		ifptr = fp->fptr;
 		fp->fptr = nsect = 0;
 		if (ofs) {
-			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
+			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
 			if (ifptr > 0 &&
 				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
@@ -3072,13 +4123,13 @@
 				ofs -= fp->fptr;
 				clst = fp->clust;
 			} else {									/* When seek to back cluster, */
-				clst = fp->sclust;						/* start from the first cluster */
+				clst = fp->obj.sclust;					/* start from the first cluster */
 #if !_FS_READONLY
 				if (clst == 0) {						/* If no cluster chain, create a new chain */
-					clst = create_chain(fp->fs, 0);
-					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
-					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
-					fp->sclust = clst;
+					clst = create_chain(&fp->obj, 0);
+					if (clst == 1) ABORT(fs, FR_INT_ERR);
+					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
+					fp->obj.sclust = clst;
 				}
 #endif
 				fp->clust = clst;
@@ -3087,50 +4138,52 @@
 				while (ofs > bcs) {						/* Cluster following loop */
 #if !_FS_READONLY
 					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
-						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
+						clst = create_chain(&fp->obj, clst);	/* Force stretch if in write mode */
 						if (clst == 0) {				/* When disk gets full, clip file size */
 							ofs = bcs; break;
 						}
 					} else
 #endif
-						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
-					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
-					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
+						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
+					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
+					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
 					fp->clust = clst;
 					fp->fptr += bcs;
 					ofs -= bcs;
 				}
 				fp->fptr += ofs;
-				if (ofs % SS(fp->fs)) {
-					nsect = clust2sect(fp->fs, clst);	/* Current sector */
-					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
-					nsect += ofs / SS(fp->fs);
+				if (ofs % SS(fs)) {
+					nsect = clust2sect(fs, clst);	/* Current sector */
+					if (!nsect) ABORT(fs, FR_INT_ERR);
+					nsect += (DWORD)(ofs / SS(fs));
 				}
 			}
 		}
-		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
+		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
 #if !_FS_TINY
 #if !_FS_READONLY
-			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
-				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
-					ABORT(fp->fs, FR_DISK_ERR);
-				fp->flag &= ~FA__DIRTY;
+			if (fp->flag & _FA_DIRTY) {			/* Write-back dirty sector cache */
+				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
+					ABORT(fs, FR_DISK_ERR);
+				}
+				fp->flag &= ~_FA_DIRTY;
 			}
 #endif
-			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
-				ABORT(fp->fs, FR_DISK_ERR);
+			if (disk_read(fs->drv, fp->buf, nsect, 1) != RES_OK) {	/* Fill sector cache */
+				ABORT(fs, FR_DISK_ERR);
+			}
 #endif
-			fp->dsect = nsect;
+			fp->sect = nsect;
 		}
 #if !_FS_READONLY
-		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
-			fp->fsize = fp->fptr;
-			fp->flag |= FA__WRITTEN;
+		if (fp->fptr > fp->obj.objsize) {		/* Set file change flag if the file size is extended */
+			fp->obj.objsize = fp->fptr;
+			fp->flag |= _FA_MODIFIED;
 		}
 #endif
 	}
 
-	LEAVE_FF(fp->fs, res);
+	LEAVE_FF(fs, res);
 }
 
 
@@ -3146,45 +4199,59 @@
 )
 {
 	FRESULT res;
-	FATFS* fs;
-	DEFINE_NAMEBUF;
+	FATFS *fs;
+	_FDID *obj;
+	DEF_NAMBUF;
 
 
 	if (!dp) return FR_INVALID_OBJECT;
 
 	/* Get logical drive number */
-	res = find_volume(&fs, &path, 0);
+	obj = &dp->obj;
+	res = find_volume(&path, &fs, 0);
 	if (res == FR_OK) {
-		dp->fs = fs;
-		INIT_BUF(*dp);
+		obj->fs = fs;
+		INIT_NAMBUF(*dp);
 		res = follow_path(dp, path);			/* Follow the path to the directory */
-		FREE_BUF();
 		if (res == FR_OK) {						/* Follow completed */
-			if (dp->dir) {						/* It is not the origin directory itself */
-				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
-					dp->sclust = ld_clust(fs, dp->dir);
-				else							/* The object is a file */
+			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
+				if (obj->attr & AM_DIR) {		/* This object is a sub-directory */
+#if _FS_EXFAT
+					if (fs->fs_type == FS_EXFAT) {
+						obj->c_scl = obj->sclust;	/* Save containing directory inforamation */
+						obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
+						obj->c_ofs = dp->blk_ofs;
+						obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Get object location and status */
+						obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
+						obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
+					} else
+#endif
+					{
+						obj->sclust = ld_clust(fs, dp->dir);	/* Get object location */
+					}
+				} else {						/* This object is a file */
 					res = FR_NO_PATH;
+				}
 			}
 			if (res == FR_OK) {
-				dp->id = fs->id;
+				obj->id = fs->id;
 				res = dir_sdi(dp, 0);			/* Rewind directory */
-#if _FS_LOCK
+#if _FS_LOCK != 0
 				if (res == FR_OK) {
-					if (dp->sclust) {
-						dp->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
-						if (!dp->lockid)
-							res = FR_TOO_MANY_OPEN_FILES;
+					if (obj->sclust) {
+						obj->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
+						if (!obj->lockid) res = FR_TOO_MANY_OPEN_FILES;
 					} else {
-						dp->lockid = 0;	/* Root directory need not to be locked */
+						obj->lockid = 0;	/* Root directory need not to be locked */
 					}
 				}
 #endif
 			}
 		}
+		FREE_NAMBUF();
 		if (res == FR_NO_FILE) res = FR_NO_PATH;
 	}
-	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
+	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
 
 	LEAVE_FF(fs, res);
 }
@@ -3201,19 +4268,20 @@
 )
 {
 	FRESULT res;
+	FATFS *fs;
 
 
-	res = validate(dp);
+	res = validate(dp, &fs);
 	if (res == FR_OK) {
-#if _FS_REENTRANT
-		FATFS *fs = dp->fs;
-#endif
-#if _FS_LOCK
-		if (dp->lockid)				/* Decrement sub-directory open counter */
-			res = dec_lock(dp->lockid);
+#if _FS_LOCK != 0
+		if (dp->obj.lockid) {				/* Decrement sub-directory open counter */
+			res = dec_lock(dp->obj.lockid);
+		}
 		if (res == FR_OK)
 #endif
-			dp->fs = 0;				/* Invalidate directory object */
+		{
+			dp->obj.fs = 0;			/* Invalidate directory object */
+		}
 #if _FS_REENTRANT
 		unlock_fs(fs, FR_OK);		/* Unlock volume */
 #endif
@@ -3234,33 +4302,27 @@
 )
 {
 	FRESULT res;
-	DEFINE_NAMEBUF;
+	FATFS *fs;
+	DEF_NAMBUF;
 
 
-	res = validate(dp);						/* Check validity of the object */
+	res = validate(dp, &fs);	/* Check validity of the object */
 	if (res == FR_OK) {
 		if (!fno) {
 			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 		} else {
-			INIT_BUF(*dp);
+			INIT_NAMBUF(*dp);
 			res = dir_read(dp, 0);			/* Read an item */
-			if (res == FR_NO_FILE) {		/* Reached end of directory */
-				dp->sect = 0;
-				res = FR_OK;
-			}
+			if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
 			if (res == FR_OK) {				/* A valid entry is found */
 				get_fileinfo(dp, fno);		/* Get the object information */
 				res = dir_next(dp, 0);		/* Increment index for next */
-				if (res == FR_NO_FILE) {
-					dp->sect = 0;
-					res = FR_OK;
-				}
+				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
 			}
-			FREE_BUF();
+			FREE_NAMBUF();
 		}
 	}
-
-	LEAVE_FF(dp->fs, res);
+	LEAVE_FF(fs, res);
 }
 
 
@@ -3267,7 +4329,7 @@
 
 #if _USE_FIND
 /*-----------------------------------------------------------------------*/
-/* Find next file                                                        */
+/* Find Next File                                                        */
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_findnext (
@@ -3281,19 +4343,18 @@
 	for (;;) {
 		res = f_readdir(dp, fno);		/* Get a directory item */
 		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
-#if _USE_LFN
-		if (fno->lfname && pattern_matching(dp->pat, fno->lfname, 0, 0)) break;	/* Test for LFN if exist */
+		if (pattern_matching(dp->pat, fno->fname, 0, 0)) break;		/* Test for the file name */
+#if _USE_LFN != 0 && _USE_FIND == 2
+		if (pattern_matching(dp->pat, fno->altname, 0, 0)) break;	/* Test for alternative name if exist */
 #endif
-		if (pattern_matching(dp->pat, fno->fname, 0, 0)) break;	/* Test for SFN */
 	}
 	return res;
-
 }
 
 
 
 /*-----------------------------------------------------------------------*/
-/* Find first file                                                       */
+/* Find First File                                                       */
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_findfirst (
@@ -3308,8 +4369,9 @@
 
 	dp->pat = pattern;		/* Save pointer to pattern string */
 	res = f_opendir(dp, path);		/* Open the target directory */
-	if (res == FR_OK)
+	if (res == FR_OK) {
 		res = f_findnext(dp, fno);	/* Find the first item */
+	}
 	return res;
 }
 
@@ -3329,25 +4391,25 @@
 {
 	FRESULT res;
 	DIR dj;
-	DEFINE_NAMEBUF;
+	DEF_NAMBUF;
 
 
 	/* Get logical drive number */
-	res = find_volume(&dj.fs, &path, 0);
+	res = find_volume(&path, &dj.obj.fs, 0);
 	if (res == FR_OK) {
-		INIT_BUF(dj);
+		INIT_NAMBUF(dj);
 		res = follow_path(&dj, path);	/* Follow the file path */
 		if (res == FR_OK) {				/* Follow completed */
-			if (dj.dir) {		/* Found an object */
+			if (dj.fn[NSFLAG] & NS_NONAME) {	/* It is origin directory */
+				res = FR_INVALID_NAME;
+			} else {							/* Found an object */
 				if (fno) get_fileinfo(&dj, fno);
-			} else {			/* It is root directory */
-				res = FR_INVALID_NAME;
 			}
 		}
-		FREE_BUF();
+		FREE_NAMBUF();
 	}
 
-	LEAVE_FF(dj.fs, res);
+	LEAVE_FF(dj.obj.fs, res);
 }
 
 
@@ -3365,55 +4427,75 @@
 {
 	FRESULT res;
 	FATFS *fs;
-	DWORD n, clst, sect, stat;
+	DWORD nfree, clst, sect, stat;
 	UINT i;
-	BYTE fat, *p;
+	BYTE *p;
+	_FDID obj;
 
 
 	/* Get logical drive number */
-	res = find_volume(fatfs, &path, 0);
-	fs = *fatfs;
+	res = find_volume(&path, &fs, 0);
 	if (res == FR_OK) {
-		/* If free_clust is valid, return it without full cluster scan */
-		if (fs->free_clust <= fs->n_fatent - 2) {
-			*nclst = fs->free_clust;
+		*fatfs = fs;				/* Return ptr to the fs object */
+		/* If free_clst is valid, return it without full cluster scan */
+		if (fs->free_clst <= fs->n_fatent - 2) {
+			*nclst = fs->free_clst;
 		} else {
 			/* Get number of free clusters */
-			fat = fs->fs_type;
-			n = 0;
-			if (fat == FS_FAT12) {
-				clst = 2;
+			nfree = 0;
+			if (fs->fs_type == FS_FAT12) {	/* FAT12: Sector unalighed FAT entries */
+				clst = 2; obj.fs = fs;
 				do {
-					stat = get_fat(fs, clst);
+					stat = get_fat(&obj, clst);
 					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
 					if (stat == 1) { res = FR_INT_ERR; break; }
-					if (stat == 0) n++;
+					if (stat == 0) nfree++;
 				} while (++clst < fs->n_fatent);
 			} else {
-				clst = fs->n_fatent;
-				sect = fs->fatbase;
-				i = 0; p = 0;
-				do {
-					if (!i) {
-						res = move_window(fs, sect++);
-						if (res != FR_OK) break;
-						p = fs->win;
-						i = SS(fs);
-					}
-					if (fat == FS_FAT16) {
-						if (LD_WORD(p) == 0) n++;
-						p += 2; i -= 2;
-					} else {
-						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
-						p += 4; i -= 4;
-					}
-				} while (--clst);
+#if _FS_EXFAT
+				if (fs->fs_type == FS_EXFAT) {	/* exFAT: Scan bitmap table */
+					BYTE bm;
+					UINT b;
+
+					clst = fs->n_fatent - 2;
+					sect = fs->database;
+					i = 0;
+					do {
+						if (i == 0 && (res = move_window(fs, sect++)) != FR_OK) break;
+						for (b = 8, bm = fs->win[i]; b && clst; b--, clst--) {
+							if (!(bm & 1)) nfree++;
+							bm >>= 1;
+						}
+						i = (i + 1) & (SS(fs) - 1);
+					} while (clst);
+				} else
+#endif
+				{	/* FAT16/32: Sector alighed FAT entries */
+					clst = fs->n_fatent; sect = fs->fatbase;
+					i = 0; p = 0;
+					do {
+						if (i == 0) {
+							res = move_window(fs, sect++);
+							if (res != FR_OK) break;
+							p = fs->win;
+							i = SS(fs);
+						}
+						if (fs->fs_type == FS_FAT16) {
+							if (ld_word(p) == 0) nfree++;
+							p += 2; i -= 2;
+						} else {
+							if ((ld_dword(p) & 0x0FFFFFFF) == 0) nfree++;
+							p += 4; i -= 4;
+						}
+					} while (--clst);
+				}
 			}
-			fs->free_clust = n;
-			fs->fsi_flag |= 1;
-			*nclst = n;
+			*nclst = nfree;			/* Return the free clusters */
+			fs->free_clst = nfree;	/* Now free_clst is valid */
+			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
 		}
 	}
+
 	LEAVE_FF(fs, res);
 }
 
@@ -3429,48 +4511,42 @@
 )
 {
 	FRESULT res;
+	FATFS *fs;
 	DWORD ncl;
 
 
-	res = validate(fp);						/* Check validity of the object */
-	if (res == FR_OK) {
-		if (fp->err) {						/* Check error */
-			res = (FRESULT)fp->err;
-		} else {
-			if (!(fp->flag & FA_WRITE))		/* Check access mode */
-				res = FR_DENIED;
+	res = validate(fp, &fs);	/* Check validity of the object */
+	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
+	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
+
+	if (fp->obj.objsize > fp->fptr) {
+		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
+			res = remove_chain(&fp->obj, fp->obj.sclust, 0);
+			fp->obj.sclust = 0;
+		} else {				/* When truncate a part of the file, remove remaining clusters */
+			ncl = get_fat(&fp->obj, fp->clust);
+			res = FR_OK;
+			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
+			if (ncl == 1) res = FR_INT_ERR;
+			if (res == FR_OK && ncl < fs->n_fatent) {
+				res = remove_chain(&fp->obj, ncl, fp->clust);
+			}
 		}
-	}
-	if (res == FR_OK) {
-		if (fp->fsize > fp->fptr) {
-			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
-			fp->flag |= FA__WRITTEN;
-			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
-				res = remove_chain(fp->fs, fp->sclust);
-				fp->sclust = 0;
-			} else {				/* When truncate a part of the file, remove remaining clusters */
-				ncl = get_fat(fp->fs, fp->clust);
-				res = FR_OK;
-				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
-				if (ncl == 1) res = FR_INT_ERR;
-				if (res == FR_OK && ncl < fp->fs->n_fatent) {
-					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
-					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
-				}
-			}
+		fp->obj.objsize = fp->fptr;	/* Set file size to current R/W point */
+		fp->flag |= _FA_MODIFIED;
 #if !_FS_TINY
-			if (res == FR_OK && (fp->flag & FA__DIRTY)) {
-				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
-					res = FR_DISK_ERR;
-				else
-					fp->flag &= ~FA__DIRTY;
+		if (res == FR_OK && (fp->flag & _FA_DIRTY)) {
+			if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
+				res = FR_DISK_ERR;
+			} else {
+				fp->flag &= ~_FA_DIRTY;
 			}
+		}
 #endif
-		}
-		if (res != FR_OK) fp->err = (FRESULT)res;
+		if (res != FR_OK) ABORT(fs, res);
 	}
 
-	LEAVE_FF(fp->fs, res);
+	LEAVE_FF(fs, res);
 }
 
 
@@ -3477,7 +4553,7 @@
 
 
 /*-----------------------------------------------------------------------*/
-/* Delete a File or Directory                                            */
+/* Delete a File/Directory                                               */
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_unlink (
@@ -3486,60 +4562,86 @@
 {
 	FRESULT res;
 	DIR dj, sdj;
-	BYTE *dir;
 	DWORD dclst = 0;
-	DEFINE_NAMEBUF;
+	FATFS *fs;
+#if _FS_EXFAT
+	_FDID obj;
+#endif
+	DEF_NAMBUF;
 
 
 	/* Get logical drive number */
-	res = find_volume(&dj.fs, &path, 1);
+	res = find_volume(&path, &fs, FA_WRITE);
+	dj.obj.fs = fs;
 	if (res == FR_OK) {
-		INIT_BUF(dj);
+		INIT_NAMBUF(dj);
 		res = follow_path(&dj, path);		/* Follow the file path */
-		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
+		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {
 			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
-#if _FS_LOCK
-		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open object */
+		}
+#if _FS_LOCK != 0
+		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
 #endif
 		if (res == FR_OK) {					/* The object is accessible */
-			dir = dj.dir;
-			if (!dir) {
+			if (dj.fn[NSFLAG] & NS_NONAME) {
 				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
 			} else {
-				if (dir[DIR_Attr] & AM_RDO)
+				if (dj.obj.attr & AM_RDO) {
 					res = FR_DENIED;		/* Cannot remove R/O object */
+				}
 			}
 			if (res == FR_OK) {
-				dclst = ld_clust(dj.fs, dir);
-				if (dclst && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-directory ? */
-#if _FS_RPATH
-					if (dclst == dj.fs->cdir) {		 		/* Is it the current directory? */
+#if _FS_EXFAT
+				obj.fs = fs;
+				if (fs->fs_type == FS_EXFAT) {
+					obj.sclust = dclst = ld_dword(fs->dirbuf + XDIR_FstClus);
+					obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
+					obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
+				} else
+#endif
+				{
+					dclst = ld_clust(fs, dj.dir);
+				}
+				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory ? */
+#if _FS_RPATH != 0
+					if (dclst == fs->cdir) {		 		/* Is it the current directory? */
 						res = FR_DENIED;
 					} else
 #endif
 					{
-						mem_cpy(&sdj, &dj, sizeof (DIR));	/* Open the sub-directory */
-						sdj.sclust = dclst;
-						res = dir_sdi(&sdj, 2);
+						sdj.obj.fs = fs;						/* Open the sub-directory */
+						sdj.obj.sclust = dclst;
+#if _FS_EXFAT
+						if (fs->fs_type == FS_EXFAT) {
+							sdj.obj.objsize = obj.objsize;
+							sdj.obj.stat = obj.stat;
+						}
+#endif
+						res = dir_sdi(&sdj, 0);
 						if (res == FR_OK) {
-							res = dir_read(&sdj, 0);			/* Read an item (excluding dot entries) */
-							if (res == FR_OK) res = FR_DENIED;	/* Not empty? (cannot remove) */
-							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? (can remove) */
+							res = dir_read(&sdj, 0);			/* Read an item */
+							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
+							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
 						}
 					}
 				}
 			}
 			if (res == FR_OK) {
-				res = dir_remove(&dj);		/* Remove the directory entry */
-				if (res == FR_OK && dclst)	/* Remove the cluster chain if exist */
-					res = remove_chain(dj.fs, dclst);
-				if (res == FR_OK) res = sync_fs(dj.fs);
+				res = dir_remove(&dj);			/* Remove the directory entry */
+				if (res == FR_OK && dclst) {	/* Remove the cluster chain if exist */
+#if _FS_EXFAT
+					res = remove_chain(&obj, dclst, 0);
+#else
+					res = remove_chain(&dj.obj, dclst, 0);
+#endif
+				}
+				if (res == FR_OK) res = sync_fs(fs);
 			}
 		}
-		FREE_BUF();
+		FREE_NAMBUF();
 	}
 
-	LEAVE_FF(dj.fs, res);
+	LEAVE_FF(fs, res);
 }
 
 
@@ -3555,65 +4657,85 @@
 {
 	FRESULT res;
 	DIR dj;
-	BYTE *dir, n;
-	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
-	DEFINE_NAMEBUF;
+	FATFS *fs;
+	BYTE *dir;
+	UINT n;
+	DWORD dsc, dcl, pcl, tm;
+	DEF_NAMBUF;
 
 
 	/* Get logical drive number */
-	res = find_volume(&dj.fs, &path, 1);
+	res = find_volume(&path, &fs, FA_WRITE);
+	dj.obj.fs = fs;
 	if (res == FR_OK) {
-		INIT_BUF(dj);
+		INIT_NAMBUF(dj);
 		res = follow_path(&dj, path);			/* Follow the file path */
 		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
-		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
+		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {
 			res = FR_INVALID_NAME;
+		}
 		if (res == FR_NO_FILE) {				/* Can create a new directory */
-			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
+			dcl = create_chain(&dj.obj, 0);		/* Allocate a cluster for the new directory table */
+			dj.obj.objsize = (DWORD)fs->csize * SS(fs);
 			res = FR_OK;
 			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 			if (dcl == 1) res = FR_INT_ERR;
 			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
-			if (res == FR_OK)					/* Flush FAT */
-				res = sync_window(dj.fs);
+			if (res == FR_OK) res = sync_window(fs);	/* Flush FAT */
+			tm = GET_FATTIME();
 			if (res == FR_OK) {					/* Initialize the new directory table */
-				dsc = clust2sect(dj.fs, dcl);
-				dir = dj.fs->win;
-				mem_set(dir, 0, SS(dj.fs));
-				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
-				dir[DIR_Name] = '.';
-				dir[DIR_Attr] = AM_DIR;
-				ST_DWORD(dir + DIR_WrtTime, tm);
-				st_clust(dir, dcl);
-				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
-				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
-				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
-					pcl = 0;
-				st_clust(dir + SZ_DIRE, pcl);
-				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
-					dj.fs->winsect = dsc++;
-					dj.fs->wflag = 1;
-					res = sync_window(dj.fs);
+				dsc = clust2sect(fs, dcl);
+				dir = fs->win;
+				mem_set(dir, 0, SS(fs));
+				if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
+					mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
+					dir[DIR_Name] = '.';
+					dir[DIR_Attr] = AM_DIR;
+					st_dword(dir + DIR_WrtTime, tm);
+					st_clust(fs, dir, dcl);
+					mem_cpy(dir + SZDIRE, dir, SZDIRE); 	/* Create ".." entry */
+					dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
+					if (fs->fs_type == FS_FAT32 && pcl == fs->dirbase)
+						pcl = 0;
+					st_clust(fs, dir + SZDIRE, pcl);
+				}
+				for (n = fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
+					fs->winsect = dsc++;
+					fs->wflag = 1;
+					res = sync_window(fs);
 					if (res != FR_OK) break;
-					mem_set(dir, 0, SS(dj.fs));
+					mem_set(dir, 0, SS(fs));
 				}
 			}
 			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
-			if (res != FR_OK) {
-				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
+			if (res == FR_OK) {
+#if _FS_EXFAT
+				if (fs->fs_type == FS_EXFAT) {
+					st_dword(fs->dirbuf + XDIR_ModTime, tm);
+					st_dword(fs->dirbuf + XDIR_FstClus, dcl);
+					st_dword(fs->dirbuf + XDIR_FileSize, (DWORD)dj.obj.objsize);
+					st_dword(fs->dirbuf + XDIR_ValidFileSize, (DWORD)dj.obj.objsize);
+					fs->dirbuf[XDIR_GenFlags] = 3;
+					fs->dirbuf[XDIR_Attr] = AM_DIR;
+					res = store_xdir(&dj);
+				} else
+#endif
+				{
+					dir = dj.dir;
+					st_dword(dir + DIR_WrtTime, tm);	/* Created time */
+					st_clust(fs, dir, dcl);				/* Table start cluster */
+					dir[DIR_Attr] = AM_DIR;				/* Attribute */
+					fs->wflag = 1;
+				}
+				res = sync_fs(fs);
 			} else {
-				dir = dj.dir;
-				dir[DIR_Attr] = AM_DIR;				/* Attribute */
-				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
-				st_clust(dir, dcl);					/* Table start cluster */
-				dj.fs->wflag = 1;
-				res = sync_fs(dj.fs);
+				remove_chain(&dj.obj, dcl, 0);		/* Could not register, remove cluster chain */
 			}
 		}
-		FREE_BUF();
+		FREE_NAMBUF();
 	}
 
-	LEAVE_FF(dj.fs, res);
+	LEAVE_FF(fs, res);
 }
 
 
@@ -3620,127 +4742,155 @@
 
 
 /*-----------------------------------------------------------------------*/
-/* Change Attribute                                                      */
+/* Rename a File/Directory                                               */
 /*-----------------------------------------------------------------------*/
 
-FRESULT f_chmod (
-	const TCHAR* path,	/* Pointer to the file path */
-	BYTE attr,			/* Attribute bits */
-	BYTE mask			/* Attribute mask to change */
-)
-{
-	FRESULT res;
-	DIR dj;
-	BYTE *dir;
-	DEFINE_NAMEBUF;
-
-
-	/* Get logical drive number */
-	res = find_volume(&dj.fs, &path, 1);
-	if (res == FR_OK) {
-		INIT_BUF(dj);
-		res = follow_path(&dj, path);		/* Follow the file path */
-		FREE_BUF();
-		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
-			res = FR_INVALID_NAME;
-		if (res == FR_OK) {
-			dir = dj.dir;
-			if (!dir) {						/* Is it a root directory? */
-				res = FR_INVALID_NAME;
-			} else {						/* File or sub directory */
-				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
-				dir[DIR_Attr] = (attr & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
-				dj.fs->wflag = 1;
-				res = sync_fs(dj.fs);
-			}
-		}
-	}
-
-	LEAVE_FF(dj.fs, res);
-}
-
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Rename File/Directory                                                 */
-/*-----------------------------------------------------------------------*/
-
 FRESULT f_rename (
-	const TCHAR* path_old,	/* Pointer to the object to be renamed */
+	const TCHAR* path_old,	/* Pointer to the object name to be renamed */
 	const TCHAR* path_new	/* Pointer to the new name */
 )
 {
 	FRESULT res;
 	DIR djo, djn;
-	BYTE buf[21], *dir;
+	FATFS *fs;
+	BYTE buf[_FS_EXFAT ? SZDIRE * 2 : 24], *dir;
 	DWORD dw;
-	DEFINE_NAMEBUF;
+	DEF_NAMBUF;
 
 
-	/* Get logical drive number of the source object */
-	res = find_volume(&djo.fs, &path_old, 1);
+	get_ldnumber(&path_new);						/* Ignore drive number of new name */
+	res = find_volume(&path_old, &fs, FA_WRITE);	/* Get logical drive number of the old object */
 	if (res == FR_OK) {
-		djn.fs = djo.fs;
-		INIT_BUF(djo);
+		djo.obj.fs = fs;
+		INIT_NAMBUF(djo);
 		res = follow_path(&djo, path_old);		/* Check old object */
-		if (_FS_RPATH && res == FR_OK && (djo.fn[NSFLAG] & NS_DOT))
-			res = FR_INVALID_NAME;
-#if _FS_LOCK
+		if (res == FR_OK && (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check validity of name */
+#if _FS_LOCK != 0
 		if (res == FR_OK) res = chk_lock(&djo, 2);
 #endif
-		if (res == FR_OK) {						/* Old object is found */
-			if (!djo.dir) {						/* Is root dir? */
-				res = FR_NO_FILE;
-			} else {
-				mem_cpy(buf, djo.dir + DIR_Attr, 21);	/* Save information about object except name */
+		if (res == FR_OK) {						/* Object to be renamed is found */
+#if _FS_EXFAT
+			if (fs->fs_type == FS_EXFAT) {	/* At exFAT */
+				BYTE nf, nn;
+				WORD nh;
+
+				mem_cpy(buf, fs->dirbuf, SZDIRE * 2);	/* Save 85+C0 entry of old object */
+				mem_cpy(&djn, &djo, sizeof djo);
+				res = follow_path(&djn, path_new);	/* Make sure if new object name is not in use */
+				if (res == FR_OK) res = FR_EXIST;	/* Is new name already in use? */
+				if (res == FR_NO_FILE) { 			/* It is a valid path and no name collision */
+					res = dir_register(&djn);		/* Register the new entry */
+					if (res == FR_OK) {
+						nf = fs->dirbuf[XDIR_NumSec]; nn = fs->dirbuf[XDIR_NumName];
+						nh = ld_word(fs->dirbuf + XDIR_NameHash);
+						mem_cpy(fs->dirbuf, buf, SZDIRE * 2);
+						fs->dirbuf[XDIR_NumSec] = nf; fs->dirbuf[XDIR_NumName] = nn;
+						st_word(fs->dirbuf + XDIR_NameHash, nh);
+/* Start of critical section where any interruption can cause a cross-link */
+						res = store_xdir(&djn);
+					}
+				}
+			} else
+#endif
+			{	/* At FAT12/FAT16/FAT32 */
+				mem_cpy(buf, djo.dir + DIR_Attr, 21);	/* Save information about the object except name */
 				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
-				if (get_ldnumber(&path_new) >= 0)		/* Snip drive number off and ignore it */
-					res = follow_path(&djn, path_new);	/* and make sure if new object name is not conflicting */
-				else
-					res = FR_INVALID_DRIVE;
-				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
+				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
+				if (res == FR_OK) res = FR_EXIST;		/* Is new name already in use? */
 				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
 					res = dir_register(&djn);			/* Register the new entry */
 					if (res == FR_OK) {
-/* Start of critical section where any interruption can cause a cross-link */
 						dir = djn.dir;					/* Copy information about object except name */
 						mem_cpy(dir + 13, buf + 2, 19);
 						dir[DIR_Attr] = buf[0] | AM_ARC;
-						djo.fs->wflag = 1;
-						if ((dir[DIR_Attr] & AM_DIR) && djo.sclust != djn.sclust) {	/* Update .. entry in the sub-directory if needed */
-							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
+						fs->wflag = 1;
+						if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {	/* Update .. entry in the sub-directory if needed */
+							dw = clust2sect(fs, ld_clust(fs, dir));
 							if (!dw) {
 								res = FR_INT_ERR;
 							} else {
-								res = move_window(djo.fs, dw);
-								dir = djo.fs->win + SZ_DIRE * 1;	/* Ptr to .. entry */
+/* Start of critical section where any interruption can cause a cross-link */
+								res = move_window(fs, dw);
+								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
 								if (res == FR_OK && dir[1] == '.') {
-									st_clust(dir, djn.sclust);
-									djo.fs->wflag = 1;
+									st_clust(fs, dir, djn.obj.sclust);
+									fs->wflag = 1;
 								}
 							}
 						}
-						if (res == FR_OK) {
-							res = dir_remove(&djo);		/* Remove old entry */
-							if (res == FR_OK)
-								res = sync_fs(djo.fs);
-						}
-/* End of critical section */
 					}
 				}
 			}
+			if (res == FR_OK) {
+				res = dir_remove(&djo);		/* Remove old entry */
+				if (res == FR_OK) {
+					res = sync_fs(fs);
+				}
+			}
+/* End of critical section */
 		}
-		FREE_BUF();
+		FREE_NAMBUF();
 	}
 
-	LEAVE_FF(djo.fs, res);
+	LEAVE_FF(fs, res);
 }
 
 
 
+#endif /* !_FS_READONLY */
+#endif /* _FS_MINIMIZE == 0 */
+#endif /* _FS_MINIMIZE <= 1 */
+#endif /* _FS_MINIMIZE <= 2 */
 
+
+
+#if _USE_CHMOD && !_FS_READONLY
 /*-----------------------------------------------------------------------*/
+/* Change Attribute                                                      */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_chmod (
+	const TCHAR* path,	/* Pointer to the file path */
+	BYTE attr,			/* Attribute bits */
+	BYTE mask			/* Attribute mask to change */
+)
+{
+	FRESULT res;
+	DIR dj;
+	FATFS *fs;
+	DEF_NAMBUF;
+
+
+	res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive number */
+	dj.obj.fs = fs;
+	if (res == FR_OK) {
+		INIT_NAMBUF(dj);
+		res = follow_path(&dj, path);	/* Follow the file path */
+		if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
+		if (res == FR_OK) {
+			mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
+#if _FS_EXFAT
+			if (fs->fs_type == FS_EXFAT) {
+				fs->dirbuf[XDIR_Attr] = (attr & mask) | (fs->dirbuf[XDIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
+				res = store_xdir(&dj);
+			} else
+#endif
+			{
+				dj.dir[DIR_Attr] = (attr & mask) | (dj.dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
+				fs->wflag = 1;
+			}
+			res = sync_fs(fs);
+		}
+		FREE_NAMBUF();
+	}
+
+	LEAVE_FF(fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
 /* Change Timestamp                                                      */
 /*-----------------------------------------------------------------------*/
 
@@ -3751,45 +4901,44 @@
 {
 	FRESULT res;
 	DIR dj;
-	BYTE *dir;
-	DEFINE_NAMEBUF;
+	FATFS *fs;
+	DEF_NAMBUF;
 
 
-	/* Get logical drive number */
-	res = find_volume(&dj.fs, &path, 1);
+	res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive number */
+	dj.obj.fs = fs;
 	if (res == FR_OK) {
-		INIT_BUF(dj);
+		INIT_NAMBUF(dj);
 		res = follow_path(&dj, path);	/* Follow the file path */
-		FREE_BUF();
-		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
-			res = FR_INVALID_NAME;
+		if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
 		if (res == FR_OK) {
-			dir = dj.dir;
-			if (!dir) {					/* Root directory */
-				res = FR_INVALID_NAME;
-			} else {					/* File or sub-directory */
-				ST_WORD(dir + DIR_WrtTime, fno->ftime);
-				ST_WORD(dir + DIR_WrtDate, fno->fdate);
-				dj.fs->wflag = 1;
-				res = sync_fs(dj.fs);
+#if _FS_EXFAT
+			if (fs->fs_type == FS_EXFAT) {
+				st_word(fs->dirbuf + XDIR_ModTime, fno->ftime);
+				st_word(fs->dirbuf + XDIR_ModTime + 2, fno->fdate);
+				res = store_xdir(&dj);
+			} else
+#endif
+			{
+				st_word(dj.dir + DIR_WrtTime, fno->ftime);
+				st_word(dj.dir + DIR_WrtDate, fno->fdate);
+				fs->wflag = 1;
 			}
+			if (res == FR_OK) res = sync_fs(fs);
 		}
+		FREE_NAMBUF();
 	}
 
-	LEAVE_FF(dj.fs, res);
+	LEAVE_FF(fs, res);
 }
 
-#endif /* !_FS_READONLY */
-#endif /* _FS_MINIMIZE == 0 */
-#endif /* _FS_MINIMIZE <= 1 */
-#endif /* _FS_MINIMIZE <= 2 */
+#endif	/* _USE_CHMOD && !_FS_READONLY */
 
 
 
-
 #if _USE_LABEL
 /*-----------------------------------------------------------------------*/
-/* Get volume label                                                      */
+/* Get Volume Label                                                      */
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_getlabel (
@@ -3800,56 +4949,78 @@
 {
 	FRESULT res;
 	DIR dj;
-	UINT i, j;
-#if _USE_LFN && _LFN_UNICODE
+	FATFS *fs;
+	UINT si, di;
+#if _LFN_UNICODE || _FS_EXFAT
 	WCHAR w;
 #endif
 
-
 	/* Get logical drive number */
-	res = find_volume(&dj.fs, &path, 0);
+	res = find_volume(&path, &fs, 0);
 
 	/* Get volume label */
 	if (res == FR_OK && label) {
-		dj.sclust = 0;					/* Open root directory */
+		dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
 		res = dir_sdi(&dj, 0);
 		if (res == FR_OK) {
-			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
-			if (res == FR_OK) {			/* A volume label is exist */
-#if _USE_LFN && _LFN_UNICODE
-				i = j = 0;
-				do {
-					w = (i < 11) ? dj.dir[i++] : ' ';
-					if (IsDBCS1(w) && i < 11 && IsDBCS2(dj.dir[i]))
-						w = w << 8 | dj.dir[i++];
-					label[j++] = ff_convert(w, 1);	/* OEM -> Unicode */
-				} while (j < 11);
+		 	res = dir_read(&dj, 1);			/* Find a volume label entry */
+		 	if (res == FR_OK) {
+#if _FS_EXFAT
+				if (fs->fs_type == FS_EXFAT) {
+					for (si = di = 0; si < dj.dir[XDIR_NumLabel]; si++) {	/* Extract volume label from 83 entry */
+						w = ld_word(dj.dir + XDIR_Label + si * 2);
+#if _LFN_UNICODE
+						label[di++] = w;
 #else
-				mem_cpy(label, dj.dir, 11);
+						w = ff_convert(w, 0);	/* Unicode -> OEM */
+						if (w == 0) w = '?';	/* Replace wrong character */
+						if (_DF1S && w >= 0x100) label[di++] = (char)(w >> 8);
+						label[di++] = (char)w;
 #endif
-				j = 11;
-				do {
-					label[j] = 0;
-					if (!j) break;
-				} while (label[--j] == ' ');
+					}
+					label[di] = 0;
+				} else
+#endif
+				{
+					si = di = 0;		/* Extract volume label from AM_VOL entry with code comversion */
+					do {
+#if _LFN_UNICODE
+						w = (si < 11) ? dj.dir[si++] : ' ';
+						if (IsDBCS1(w) && si < 11 && IsDBCS2(dj.dir[si])) {
+							w = w << 8 | dj.dir[si++];
+						}
+						label[di++] = ff_convert(w, 1);	/* OEM -> Unicode */
+#else
+						label[di++] = dj.dir[si++];
+#endif
+					} while (di < 11);
+					do {				/* Truncate trailing spaces */
+						label[di] = 0;
+						if (di == 0) break;
+					} while (label[--di] == ' ');
+				}
 			}
-			if (res == FR_NO_FILE) {	/* No label, return nul string */
-				label[0] = 0;
-				res = FR_OK;
-			}
 		}
+		if (res == FR_NO_FILE) {	/* No label entry and return nul string */
+			label[0] = 0;
+			res = FR_OK;
+		}
 	}
 
 	/* Get volume serial number */
 	if (res == FR_OK && vsn) {
-		res = move_window(dj.fs, dj.fs->volbase);
+		res = move_window(fs, fs->volbase);
 		if (res == FR_OK) {
-			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
-			*vsn = LD_DWORD(&dj.fs->win[i]);
+			switch (fs->fs_type) {
+			case FS_EXFAT: di = BPB_VolIDEx; break;
+			case FS_FAT32: di = BS_VolID32; break;
+			default:       di = BS_VolID;
+			}
+			*vsn = ld_dword(&fs->win[di]);
 		}
 	}
 
-	LEAVE_FF(dj.fs, res);
+	LEAVE_FF(fs, res);
 }
 
 
@@ -3856,7 +5027,7 @@
 
 #if !_FS_READONLY
 /*-----------------------------------------------------------------------*/
-/* Set volume label                                                      */
+/* Set Volume Label                                                      */
 /*-----------------------------------------------------------------------*/
 
 FRESULT f_setlabel (
@@ -3865,77 +5036,108 @@
 {
 	FRESULT res;
 	DIR dj;
-	BYTE vn[11];
-	UINT i, j, sl;
+	FATFS *fs;
+	BYTE dirvn[22];
+	UINT i, j, slen;
 	WCHAR w;
-	DWORD tm;
+	static const char badchr[] = "\"*+,.:;<=>\?[]|\x7F";
 
 
 	/* Get logical drive number */
-	res = find_volume(&dj.fs, &label, 1);
-	if (res) LEAVE_FF(dj.fs, res);
+	res = find_volume(&label, &fs, FA_WRITE);
+	if (res != FR_OK) LEAVE_FF(fs, res);
+	dj.obj.fs = fs;
 
-	/* Create a volume label in directory form */
-	vn[0] = 0;
-	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
-	for ( ; sl && label[sl - 1] == ' '; sl--) ;	/* Remove trailing spaces */
-	if (sl) {	/* Create volume label in directory form */
-		i = j = 0;
-		do {
-#if _USE_LFN && _LFN_UNICODE
-			w = ff_convert(ff_wtoupper(label[i++]), 0);
+	/* Get length of given volume label */
+	for (slen = 0; (UINT)label[slen] >= ' '; slen++) ;	/* Get name length */
+
+#if _FS_EXFAT
+	if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
+		for (i = j = 0; i < slen; ) {	/* Create volume label in directory form */
+			w = label[i++];
+#if !_LFN_UNICODE
+			if (IsDBCS1(w)) {
+				w = (i < slen && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
+			}
+			w = ff_convert(w, 1);
+#endif
+			if (w == 0 || chk_chr(badchr, w) || j == 22) {	/* Check validity check validity of the volume label */
+				LEAVE_FF(fs, FR_INVALID_NAME);
+			}
+			st_word(dirvn + j, w); j += 2;
+		}
+		slen = j;
+	} else
+#endif
+	{	/* At the FAT12/16/32 */
+		for ( ; slen && label[slen - 1] == ' '; slen--) ;	/* Remove trailing spaces */
+		if (slen) {		/* Is there a volume label to be set? */
+			dirvn[0] = 0; i = j = 0;	/* Create volume label in directory form */
+			do {
+#if _LFN_UNICODE
+				w = ff_convert(ff_wtoupper(label[i++]), 0);
 #else
-			w = (BYTE)label[i++];
-			if (IsDBCS1(w))
-				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
-#if _USE_LFN
-			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
+				w = (BYTE)label[i++];
+				if (IsDBCS1(w)) {
+					w = (j < 10 && i < slen && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
+				}
+#if _USE_LFN != 0
+				w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
 #else
-			if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
+				if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
 #ifdef _EXCVT
-			if (w >= 0x80) w = ExCvt[w - 0x80];	/* To upper extended characters (SBCS cfg) */
+				if (w >= 0x80) w = ExCvt[w - 0x80];	/* To upper extended characters (SBCS cfg) */
 #else
-			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
+				if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
 #endif
 #endif
 #endif
-			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
-				LEAVE_FF(dj.fs, FR_INVALID_NAME);
-			if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
-			vn[j++] = (BYTE)w;
-		} while (i < sl);
-		while (j < 11) vn[j++] = ' ';	/* Fill remaining name field */
-		if (vn[0] == DDEM) LEAVE_FF(dj.fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
+				if (w == 0 || chk_chr(badchr, w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) {	/* Reject invalid characters for volume label */
+					LEAVE_FF(fs, FR_INVALID_NAME);
+				}
+				if (w >= 0x100) dirvn[j++] = (BYTE)(w >> 8);
+				dirvn[j++] = (BYTE)w;
+			} while (i < slen);
+			while (j < 11) dirvn[j++] = ' ';	/* Fill remaining name field */
+			if (dirvn[0] == DDEM) LEAVE_FF(fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
+		}
 	}
 
 	/* Set volume label */
-	dj.sclust = 0;					/* Open root directory */
+	dj.obj.sclust = 0;		/* Open root directory */
 	res = dir_sdi(&dj, 0);
 	if (res == FR_OK) {
-		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
-		if (res == FR_OK) {			/* A volume label is found */
-			if (vn[0]) {
-				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
-				tm = GET_FATTIME();
-				ST_DWORD(dj.dir + DIR_WrtTime, tm);
+		res = dir_read(&dj, 1);	/* Get volume label entry */
+		if (res == FR_OK) {
+			if (_FS_EXFAT && fs->fs_type == FS_EXFAT) {
+				dj.dir[XDIR_NumLabel] = slen / 2;	/* Change the volume label */
+				mem_cpy(dj.dir + XDIR_Label, dirvn, slen);
 			} else {
-				dj.dir[0] = DDEM;			/* Remove the volume label */
+				if (slen) {
+					mem_cpy(dj.dir, dirvn, 11);	/* Change the volume label */
+				} else {
+					dj.dir[DIR_Name] = DDEM;	/* Remove the volume label */
+				}
 			}
-			dj.fs->wflag = 1;
-			res = sync_fs(dj.fs);
-		} else {					/* No volume label is found or error */
+			fs->wflag = 1;
+			res = sync_fs(fs);
+		} else {			/* No volume label entry is found or error */
 			if (res == FR_NO_FILE) {
 				res = FR_OK;
-				if (vn[0]) {				/* Create volume label as new */
-					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
+				if (slen) {	/* Create a volume label entry */
+					res = dir_alloc(&dj, 1);	/* Allocate an entry */
 					if (res == FR_OK) {
-						mem_set(dj.dir, 0, SZ_DIRE);	/* Set volume label */
-						mem_cpy(dj.dir, vn, 11);
-						dj.dir[DIR_Attr] = AM_VOL;
-						tm = GET_FATTIME();
-						ST_DWORD(dj.dir + DIR_WrtTime, tm);
-						dj.fs->wflag = 1;
-						res = sync_fs(dj.fs);
+						mem_set(dj.dir, 0, SZDIRE);	/* Clear the entry */
+						if (_FS_EXFAT && fs->fs_type == FS_EXFAT) {
+							dj.dir[XDIR_Type] = 0x83;		/* Create 83 entry */
+							dj.dir[XDIR_NumLabel] = slen / 2;
+							mem_cpy(dj.dir + XDIR_Label, dirvn, slen);
+						} else {
+							dj.dir[DIR_Attr] = AM_VOL;		/* Create volume label entry */
+							mem_cpy(dj.dir, dirvn, 11);
+						}
+						fs->wflag = 1;
+						res = sync_fs(fs);
 					}
 				}
 			}
@@ -3942,7 +5144,7 @@
 		}
 	}
 
-	LEAVE_FF(dj.fs, res);
+	LEAVE_FF(fs, res);
 }
 
 #endif /* !_FS_READONLY */
@@ -3950,11 +5152,96 @@
 
 
 
+#if _USE_EXPAND && !_FS_READONLY
 /*-----------------------------------------------------------------------*/
-/* Forward data to the stream directly (available on only tiny cfg)      */
+/* Allocate a Contiguous Blocks to the File                              */
 /*-----------------------------------------------------------------------*/
-#if _USE_FORWARD && _FS_TINY
 
+FRESULT f_expand (
+	FIL* fp,		/* Pointer to the file object */
+	FSIZE_t fsz,	/* File size to be expanded to */
+	BYTE opt		/* Operation mode 0:Find and prepare or 1:Find and allocate */
+)
+{
+	FRESULT res;
+	FATFS *fs;
+	DWORD val, clst, csz, stcl, scl, ncl, tcl;
+
+
+	res = validate(fp, &fs);		/* Check validity of the object */
+	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
+	if (fsz == 0 || fp->obj.objsize != 0 || !(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);
+#if _FS_EXFAT
+	if (fs->fs_type != FS_EXFAT && fsz >= 0x100000000) LEAVE_FF(fs, FR_DENIED);	/* Check if in size limit */
+#endif
+	csz = (DWORD)fs->csize * SS(fs);	/* Cluster size */
+	tcl = (DWORD)(fsz / csz) + ((fsz & (csz - 1)) ? 1 : 0);	/* Number of clusters required */
+	stcl = fs->last_clst;
+	if (stcl < 2 || stcl >= fs->n_fatent) stcl = 2;
+
+#if _FS_EXFAT
+	if (fs->fs_type == FS_EXFAT) {
+		scl = find_bitmap(fs, stcl, tcl);			/* Find a contiguous cluster block */
+		if (scl == 0) res = FR_DENIED;				/* No contiguous cluster block was found */
+		if (scl == 1) res = FR_INT_ERR;
+		if (scl == 0xFFFFFFFF) res = FR_DISK_ERR;
+		if (res == FR_OK) {
+			if (opt) {
+				res = change_bitmap(fs, scl, tcl, 1);	/* Mark the cluster block 'in use' */
+				fs->last_clst = scl + tcl - 1;
+			} else {
+				fs->last_clst = scl - 1;				/* Set suggested cluster to start next */
+			}
+		}
+	} else
+#endif
+	{
+		scl = clst = stcl; ncl = 0;
+		for (;;) {	/* Find a contiguous cluster block */
+			val = get_fat(&fp->obj, clst);
+			if (++clst >= fs->n_fatent) clst = 2;
+			if (val == 1) { res = FR_INT_ERR; break; }
+			if (val == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
+			if (val == 0) {	/* Is it a free cluster? */
+				if (++ncl == tcl) break;	/* Break if a contiguous cluster block was found */
+			} else {
+				scl = clst; ncl = 0;		/* Not a free cluster */
+			}
+			if (clst == stcl) { res = FR_DENIED; break; }	/* All cluster scanned? */
+		}
+		if (res == FR_OK) {
+			if (opt) {
+				for (clst = scl; tcl; clst++, tcl--) {	/* Create a cluster chain on the FAT */
+					val = (tcl == 1) ? 0xFFFFFFFF : clst + 1;
+					res = put_fat(fs, clst, val);
+					if (res != FR_OK) break;
+					fs->last_clst = clst;
+				}
+			} else {
+				fs->last_clst = scl - 1;				/* Set suggested cluster to start next */
+			}
+		}
+	}
+
+	if (opt && res == FR_OK) {
+		fp->obj.sclust = scl;		/* Update allocation information */
+		fp->obj.objsize = fsz;
+		if (_FS_EXFAT) fp->obj.stat = 2;
+		fp->flag |= _FA_MODIFIED;
+	}
+
+	LEAVE_FF(fs, res);
+}
+
+#endif /* _USE_EXPAND && !_FS_READONLY */
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Forward data to the stream directly                                   */
+/*-----------------------------------------------------------------------*/
+#if _USE_FORWARD
+
 FRESULT f_forward (
 	FIL* fp, 						/* Pointer to the file object */
 	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
@@ -3963,48 +5250,59 @@
 )
 {
 	FRESULT res;
-	DWORD remain, clst, sect;
-	UINT rcnt;
-	BYTE csect;
+	FATFS *fs;
+	DWORD clst, sect;
+	FSIZE_t remain;
+	UINT rcnt, csect;
+	const BYTE *dbuf;
 
 
 	*bf = 0;	/* Clear transfer byte counter */
+	res = validate(fp, &fs);		/* Check validity of the object */
+	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
+	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 
-	res = validate(fp);								/* Check validity of the object */
-	if (res != FR_OK) LEAVE_FF(fp->fs, res);
-	if (fp->err)									/* Check error */
-		LEAVE_FF(fp->fs, (FRESULT)fp->err);
-	if (!(fp->flag & FA_READ))						/* Check access mode */
-		LEAVE_FF(fp->fs, FR_DENIED);
-
-	remain = fp->fsize - fp->fptr;
+	remain = fp->obj.objsize - fp->fptr;
 	if (btf > remain) btf = (UINT)remain;			/* Truncate btf by remaining bytes */
 
-	for ( ;  btf && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
+	for ( ;  btf && (*func)(0, 0);					/* Repeat until all data transferred or stream goes busy */
 		fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {
-		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
-		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
-			if (!csect) {							/* On the cluster boundary? */
+		csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
+		if (fp->fptr % SS(fs) == 0) {				/* On the sector boundary? */
+			if (csect == 0) {						/* On the cluster boundary? */
 				clst = (fp->fptr == 0) ?			/* On the top of the file? */
-					fp->sclust : get_fat(fp->fs, fp->clust);
-				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
-				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
+					fp->obj.sclust : get_fat(&fp->obj, fp->clust);
+				if (clst <= 1) ABORT(fs, FR_INT_ERR);
+				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 				fp->clust = clst;					/* Update current cluster */
 			}
 		}
-		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
-		if (!sect) ABORT(fp->fs, FR_INT_ERR);
+		sect = clust2sect(fs, fp->clust);			/* Get current data sector */
+		if (!sect) ABORT(fs, FR_INT_ERR);
 		sect += csect;
-		if (move_window(fp->fs, sect) != FR_OK)		/* Move sector window */
-			ABORT(fp->fs, FR_DISK_ERR);
-		fp->dsect = sect;
-		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
-		if (rcnt > btf) rcnt = btf;
-		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
-		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
+#if _FS_TINY
+		if (move_window(fs, sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window to the file data */
+		dbuf = fs->win;
+#else
+		if (fp->sect != sect) {		/* Fill sector cache with file data */
+#if !_FS_READONLY
+			if (fp->flag & _FA_DIRTY) {		/* Write-back dirty sector cache */
+				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
+				fp->flag &= ~_FA_DIRTY;
+			}
+#endif
+			if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
+		}
+		dbuf = fp->buf;
+#endif
+		fp->sect = sect;
+		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
+		if (rcnt > btf) rcnt = btf;					/* Clip it by btr if needed */
+		rcnt = (*func)(dbuf + ((UINT)fp->fptr % SS(fs)), rcnt);	/* Forward the file data */
+		if (!rcnt) ABORT(fs, FR_INT_ERR);
 	}
 
-	LEAVE_FF(fp->fs, FR_OK);
+	LEAVE_FF(fs, FR_OK);
 }
 #endif /* _USE_FORWARD */
 
@@ -4041,9 +5339,9 @@
 
 	/* Check mounted drive and clear work area */
 	if (sfd > 1) return FR_INVALID_PARAMETER;
-	vol = get_ldnumber(&path);
+	vol = get_ldnumber(&path);				/* Get target volume */
 	if (vol < 0) return FR_INVALID_DRIVE;
-	fs = FatFs[vol];
+	fs = FatFs[vol];						/* Check if the volume has work area */
 	if (!fs) return FR_NOT_ENABLED;
 	fs->fs_type = 0;
 	pdrv = LD2PD(vol);	/* Physical drive */
@@ -4054,21 +5352,23 @@
 	if (stat & STA_NOINIT) return FR_NOT_READY;
 	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
 #if _MAX_SS != _MIN_SS		/* Get disk sector size */
-	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS || SS(fs) < _MIN_SS)
+	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS || SS(fs) < _MIN_SS) {
 		return FR_DISK_ERR;
+	}
 #endif
 	if (_MULTI_PARTITION && part) {
 		/* Get partition information from partition table in the MBR */
 		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
-		if (LD_WORD(fs->win + BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
+		if (ld_word(fs->win + BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
 		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
 		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
-		b_vol = LD_DWORD(tbl + 8);	/* Volume start sector */
-		n_vol = LD_DWORD(tbl + 12);	/* Volume size */
+		b_vol = ld_dword(tbl + 8);	/* Volume start sector */
+		n_vol = ld_dword(tbl + 12);	/* Volume size */
 	} else {
-		/* Create a partition in this function */
-		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
+		/* Create a single-partition in this function */
+		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128) {
 			return FR_DISK_ERR;
+		}
 		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
 		n_vol -= b_vol;				/* Volume size */
 	}
@@ -4098,7 +5398,7 @@
 		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
 		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
 		n_rsv = 1;
-		n_dir = (DWORD)N_ROOTDIR * SZ_DIRE / SS(fs);
+		n_dir = (DWORD)N_ROOTDIR * SZDIRE / SS(fs);
 	}
 	b_fat = b_vol + n_rsv;				/* FAT area start sector */
 	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
@@ -4119,8 +5419,9 @@
 	/* Determine number of clusters and final check of validity of the FAT sub-type */
 	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
 	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
-		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
+		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32)) {
 		return FR_MKFS_ABORTED;
+	}
 
 	/* Determine system ID in the partition table */
 	if (fmt == FS_FAT32) {
@@ -4137,8 +5438,9 @@
 		/* Update system ID in the partition table */
 		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
 		tbl[4] = sys;
-		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to teh MBR */
+		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) {	/* Write it to teh MBR */
 			return FR_DISK_ERR;
+		}
 		md = 0xF8;
 	} else {
 		if (sfd) {	/* No partition table (SFD) */
@@ -4154,11 +5456,12 @@
 			n = (b_vol + n_vol) / 63 / 255;
 			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
 			tbl[7] = (BYTE)n;				/* End cylinder */
-			ST_DWORD(tbl + 8, 63);			/* Partition start in LBA */
-			ST_DWORD(tbl + 12, n_vol);		/* Partition size in LBA */
-			ST_WORD(fs->win + BS_55AA, 0xAA55);	/* MBR signature */
-			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR */
+			st_dword(tbl + 8, 63);			/* Partition start in LBA */
+			st_dword(tbl + 12, n_vol);		/* Partition size in LBA */
+			st_word(fs->win + BS_55AA, 0xAA55);	/* MBR signature */
+			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) {	/* Write it to the MBR */
 				return FR_DISK_ERR;
+			}
 			md = 0xF8;
 		}
 	}
@@ -4168,43 +5471,45 @@
 	mem_set(tbl, 0, SS(fs));
 	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
 	i = SS(fs);								/* Sector size */
-	ST_WORD(tbl + BPB_BytsPerSec, i);
+	st_word(tbl + BPB_BytsPerSec, (WORD)i);
 	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
-	ST_WORD(tbl + BPB_RsvdSecCnt, n_rsv);	/* Reserved sectors */
+	st_word(tbl + BPB_RsvdSecCnt, (WORD)n_rsv);	/* Reserved sectors */
 	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
 	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
-	ST_WORD(tbl + BPB_RootEntCnt, i);
+	st_word(tbl + BPB_RootEntCnt, (WORD)i);
 	if (n_vol < 0x10000) {					/* Number of total sectors */
-		ST_WORD(tbl + BPB_TotSec16, n_vol);
+		st_word(tbl + BPB_TotSec16, (WORD)n_vol);
 	} else {
-		ST_DWORD(tbl + BPB_TotSec32, n_vol);
+		st_dword(tbl + BPB_TotSec32, n_vol);
 	}
 	tbl[BPB_Media] = md;					/* Media descriptor */
-	ST_WORD(tbl + BPB_SecPerTrk, 63);		/* Number of sectors per track */
-	ST_WORD(tbl + BPB_NumHeads, 255);		/* Number of heads */
-	ST_DWORD(tbl + BPB_HiddSec, b_vol);		/* Hidden sectors */
+	st_word(tbl + BPB_SecPerTrk, 63);		/* Number of sectors per track */
+	st_word(tbl + BPB_NumHeads, 255);		/* Number of heads */
+	st_dword(tbl + BPB_HiddSec, b_vol);		/* Volume offset */
 	n = GET_FATTIME();						/* Use current time as VSN */
 	if (fmt == FS_FAT32) {
-		ST_DWORD(tbl + BS_VolID32, n);		/* VSN */
-		ST_DWORD(tbl + BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
-		ST_DWORD(tbl + BPB_RootClus, 2);	/* Root directory start cluster (2) */
-		ST_WORD(tbl + BPB_FSInfo, 1);		/* FSINFO record offset (VBR + 1) */
-		ST_WORD(tbl + BPB_BkBootSec, 6);	/* Backup boot record offset (VBR + 6) */
+		st_dword(tbl + BS_VolID32, n);		/* VSN */
+		st_dword(tbl + BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
+		st_dword(tbl + BPB_RootClus32, 2);	/* Root directory start cluster (2) */
+		st_word(tbl + BPB_FSInfo32, 1);		/* FSINFO record offset (VBR + 1) */
+		st_word(tbl + BPB_BkBootSec32, 6);	/* Backup boot record offset (VBR + 6) */
 		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
 		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
 		mem_cpy(tbl + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
 	} else {
-		ST_DWORD(tbl + BS_VolID, n);		/* VSN */
-		ST_WORD(tbl + BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
+		st_dword(tbl + BS_VolID, n);		/* VSN */
+		st_word(tbl + BPB_FATSz16, (WORD)n_fat);	/* Number of sectors per FAT */
 		tbl[BS_DrvNum] = 0x80;				/* Drive number */
 		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
 		mem_cpy(tbl + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
 	}
-	ST_WORD(tbl + BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
-	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
+	st_word(tbl + BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
+	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK) {	/* Write it to the VBR sector */
 		return FR_DISK_ERR;
-	if (fmt == FS_FAT32)					/* Write backup VBR if needed (VBR + 6) */
+	}
+	if (fmt == FS_FAT32) {					/* Write it to the backup VBR if needed (VBR + 6) */
 		disk_write(pdrv, tbl, b_vol + 6, 1);
+	}
 
 	/* Initialize FAT area */
 	wsect = b_fat;
@@ -4213,19 +5518,21 @@
 		n = md;								/* Media descriptor byte */
 		if (fmt != FS_FAT32) {
 			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
-			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT12/16) */
+			st_dword(tbl + 0, n);			/* Reserve cluster #0-1 (FAT12/16) */
 		} else {
 			n |= 0xFFFFFF00;
-			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT32) */
-			ST_DWORD(tbl + 4, 0xFFFFFFFF);
-			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
+			st_dword(tbl + 0, n);			/* Reserve cluster #0-1 (FAT32) */
+			st_dword(tbl + 4, 0xFFFFFFFF);
+			st_dword(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
 		}
-		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
+		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK) {
 			return FR_DISK_ERR;
+		}
 		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
 		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
-			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
+			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK) {
 				return FR_DISK_ERR;
+			}
 		}
 	}
 
@@ -4232,8 +5539,9 @@
 	/* Initialize root directory */
 	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
 	do {
-		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
+		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK) {
 			return FR_DISK_ERR;
+		}
 	} while (--i);
 
 #if _USE_TRIM	/* Erase data area if needed */
@@ -4245,11 +5553,11 @@
 
 	/* Create FSINFO if needed */
 	if (fmt == FS_FAT32) {
-		ST_DWORD(tbl + FSI_LeadSig, 0x41615252);
-		ST_DWORD(tbl + FSI_StrucSig, 0x61417272);
-		ST_DWORD(tbl + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
-		ST_DWORD(tbl + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
-		ST_WORD(tbl + BS_55AA, 0xAA55);
+		st_dword(tbl + FSI_LeadSig, 0x41615252);
+		st_dword(tbl + FSI_StrucSig, 0x61417272);
+		st_dword(tbl + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
+		st_dword(tbl + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
+		st_word(tbl + BS_55AA, 0xAA55);
 		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR + 1) */
 		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR + 7) */
 	}
@@ -4313,13 +5621,13 @@
 		p[5] = e_hd;						/* End head */
 		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
 		p[7] = (BYTE)e_cyl;					/* End cylinder */
-		ST_DWORD(p + 8, s_part);			/* Start sector in LBA */
-		ST_DWORD(p + 12, sz_part);			/* Partition size */
+		st_dword(p + 8, s_part);			/* Start sector in LBA */
+		st_dword(p + 12, sz_part);			/* Partition size */
 
 		/* Next partition */
 		b_cyl += p_cyl;
 	}
-	ST_WORD(p, 0xAA55);
+	st_word(p, 0xAA55);
 
 	/* Write it to the MBR */
 	return (disk_write(pdrv, buf, 0, 1) != RES_OK || disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) ? FR_DISK_ERR : FR_OK;
@@ -4350,7 +5658,7 @@
 
 
 	while (n < len - 1) {	/* Read characters until buffer gets filled */
-#if _USE_LFN && _LFN_UNICODE
+#if _LFN_UNICODE
 #if _STRF_ENCODE == 3		/* Read a character in UTF-8 */
 		f_read(fp, s, 1, &rc);
 		if (rc != 1) break;
@@ -4433,13 +5741,14 @@
 	int i;
 
 
-	if (_USE_STRFUNC == 2 && c == '\n')	 /* LF -> CRLF conversion */
+	if (_USE_STRFUNC == 2 && c == '\n') {	 /* LF -> CRLF conversion */
 		putc_bfd(pb, '\r');
+	}
 
 	i = pb->idx;	/* Buffer write index (-1:error) */
 	if (i < 0) return;
 
-#if _USE_LFN && _LFN_UNICODE
+#if _LFN_UNICODE
 #if _STRF_ENCODE == 3			/* Write a character in UTF-8 */
 	if (c < 0x80) {				/* 7-bit */
 		pb->buf[i++] = (BYTE)c;
@@ -4544,7 +5853,7 @@
 	BYTE f, r;
 	UINT nw, i, j, w;
 	DWORD v;
-	TCHAR c, d, s[16], *p;
+	TCHAR c, d, str[32], *p;
 	putbuff pb;
 
 
@@ -4614,12 +5923,12 @@
 		do {
 			d = (TCHAR)(v % r); v /= r;
 			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
-			s[i++] = d + '0';
-		} while (v && i < sizeof s / sizeof s[0]);
-		if (f & 8) s[i++] = '-';
+			str[i++] = d + '0';
+		} while (v && i < sizeof str / sizeof str[0]);
+		if (f & 8) str[i++] = '-';
 		j = i; d = (f & 1) ? '0' : ' ';
 		while (!(f & 2) && j++ < w) putc_bfd(&pb, d);
-		do putc_bfd(&pb, s[--i]); while (i);
+		do putc_bfd(&pb, str[--i]); while (i);
 		while (j++ < w) putc_bfd(&pb, d);
 	}
 
Index: kernel/ff.h
===================================================================
--- kernel/ff.h	(revision 334)
+++ kernel/ff.h	(working copy)
@@ -1,10 +1,10 @@
 /*---------------------------------------------------------------------------/
-/  FatFs - FAT file system module include R0.11     (C)ChaN, 2015
+/  FatFs - FAT file system module include R0.12     (C)ChaN, 2016
 /----------------------------------------------------------------------------/
 / FatFs module is a free software that opened under license policy of
 / following conditions.
 /
-/ Copyright (C) 2015, ChaN, all right reserved.
+/ Copyright (C) 2016, ChaN, all right reserved.
 /
 / 1. Redistributions of source code must retain the above copyright notice,
 /    this condition and the following disclaimer.
@@ -17,7 +17,7 @@
 
 
 #ifndef _FATFS
-#define _FATFS	32020	/* Revision ID */
+#define _FATFS	88100	/* Revision ID */
 
 #ifdef __cplusplus
 extern "C" {
@@ -53,7 +53,7 @@
 /* Type of path name strings on FatFs API */
 
 #if _LFN_UNICODE			/* Unicode string */
-#if !_USE_LFN
+#if _USE_LFN == 0
 #error _LFN_UNICODE must be 0 at non-LFN cfg.
 #endif
 #ifndef _INC_TCHAR
@@ -76,33 +76,41 @@
 /* File system object structure (FATFS) */
 
 typedef struct {
-	BYTE	fs_type;		/* FAT sub-type (0:Not mounted) */
+	BYTE	fs_type;		/* File system type (0:N/A) */
 	BYTE	drv;			/* Physical drive number */
-	BYTE	csize;			/* Sectors per cluster (1,2,4...128) */
-	BYTE	n_fats;			/* Number of FAT copies (1 or 2) */
+	BYTE	n_fats;			/* Number of FATs (1 or 2) */
 	BYTE	wflag;			/* win[] flag (b0:dirty) */
 	BYTE	fsi_flag;		/* FSINFO flags (b7:disabled, b0:dirty) */
 	WORD	id;				/* File system mount ID */
 	WORD	n_rootdir;		/* Number of root directory entries (FAT12/16) */
+	WORD	csize;			/* Cluster size [sectors] */
 #if _MAX_SS != _MIN_SS
-	WORD	ssize;			/* Bytes per sector (512, 1024, 2048 or 4096) */
+	WORD	ssize;			/* Sector size (512, 1024, 2048 or 4096) */
 #endif
+#if _FS_EXFAT
+	BYTE*	dirbuf;			/* Directory entry block scratchpad buffer */
+#endif
 #if _FS_REENTRANT
 	_SYNC_t	sobj;			/* Identifier of sync object */
 #endif
 #if !_FS_READONLY
-	DWORD	last_clust;		/* Last allocated cluster */
-	DWORD	free_clust;		/* Number of free clusters */
+	DWORD	last_clst;		/* Last allocated cluster */
+	DWORD	free_clst;		/* Number of free clusters */
 #endif
-#if _FS_RPATH
+#if _FS_RPATH != 0
 	DWORD	cdir;			/* Current directory start cluster (0:root) */
+#if _FS_EXFAT
+	DWORD	cdc_scl;		/* Containing directory start cluster (invalid when cdir is 0) */
+	DWORD	cdc_size;		/* b31-b8:Size of containing directory, b7-b0: Chain status */
+	DWORD	cdc_ofs;		/* Offset in the containing directory (invalid when cdir is 0) */
 #endif
-	DWORD	n_fatent;		/* Number of FAT entries, = number of clusters + 2 */
-	DWORD	fsize;			/* Sectors per FAT */
-	DWORD	volbase;		/* Volume start sector */
-	DWORD	fatbase;		/* FAT start sector */
-	DWORD	dirbase;		/* Root directory start sector (FAT32:Cluster#) */
-	DWORD	database;		/* Data start sector */
+#endif
+	DWORD	n_fatent;		/* Number of FAT entries (number of clusters + 2) */
+	DWORD	fsize;			/* Size of an FAT [sectors] */
+	DWORD	volbase;		/* Volume base sector */
+	DWORD	fatbase;		/* FAT base sector */
+	DWORD	dirbase;		/* Root directory base sector/cluster */
+	DWORD	database;		/* Data base sector */
 	DWORD	winsect;		/* Current sector appearing in the win[] */
 	BYTE	win[_MAX_SS];	/* Disk access window for Directory, FAT (and file data at tiny cfg) */
 } FATFS;
@@ -109,18 +117,50 @@
 
 
 
+/* Type of file size variables and object identifier */
+
+#if _FS_EXFAT
+#if _USE_LFN == 0
+#error LFN must be enabled when enable exFAT
+#endif
+typedef QWORD FSIZE_t;
+#else
+typedef DWORD FSIZE_t;
+#endif
+
+
+
+/* Object ID and allocation information (_FDID) */
+
+typedef struct {
+	FATFS*	fs;			/* Pointer to the owner file system object */
+	WORD	id;			/* Owner file system mount ID */
+	BYTE	attr;		/* Object attribute */
+	BYTE	stat;		/* Object chain status (b1-0: =0:not contiguous, =2:contiguous (no data on FAT), =3:got flagmented, b2:sub-directory stretched) */
+	DWORD	sclust;		/* Object start cluster (0:no cluster or root directory) */
+	FSIZE_t	objsize;	/* Object size (valid when sclust != 0) */
+#if _FS_EXFAT
+	DWORD	n_cont;		/* Size of coutiguous part, clusters - 1 (valid when stat == 3) */
+	DWORD	c_scl;		/* Containing directory start cluster (valid when sclust != 0) */
+	DWORD	c_size;		/* b31-b8:Size of containing directory, b7-b0: Chain status (valid when c_scl != 0) */
+	DWORD	c_ofs;		/* Offset in the containing directory (valid when sclust != 0) */
+#endif
+#if _FS_LOCK != 0
+	UINT	lockid;		/* File lock ID origin from 1 (index of file semaphore table Files[]) */
+#endif
+} _FDID;
+
+
+
 /* File object structure (FIL) */
 
 typedef struct {
-	FATFS*	fs;				/* Pointer to the related file system object (**do not change order**) */
-	WORD	id;				/* Owner file system mount ID (**do not change order**) */
-	BYTE	flag;			/* Status flags */
+	_FDID	obj;			/* Object identifier */
+	BYTE	flag;			/* File status flags */
 	BYTE	err;			/* Abort flag (error code) */
-	DWORD	fptr;			/* File read/write pointer (Zeroed on file open) */
-	DWORD	fsize;			/* File size */
-	DWORD	sclust;			/* File start cluster (0:no cluster chain, always 0 when fsize is 0) */
+	FSIZE_t	fptr;			/* File read/write pointer (Zeroed on file open) */
 	DWORD	clust;			/* Current cluster of fpter (not valid when fprt is 0) */
-	DWORD	dsect;			/* Sector number appearing in buf[] (0:invalid) */
+	DWORD	sect;			/* Sector number appearing in buf[] (0:invalid) */
 #if !_FS_READONLY
 	DWORD	dir_sect;		/* Sector number containing the directory entry */
 	BYTE*	dir_ptr;		/* Pointer to the directory entry in the win[] */
@@ -128,9 +168,6 @@
 #if _USE_FASTSEEK
 	DWORD*	cltbl;			/* Pointer to the cluster link map table (Nulled on file open) */
 #endif
-#if _FS_LOCK
-	UINT	lockid;			/* File lock ID origin from 1 (index of file semaphore table Files[]) */
-#endif
 #if !_FS_TINY
 	BYTE	buf[_MAX_SS];	/* File private data read/write window */
 #endif
@@ -141,23 +178,18 @@
 /* Directory object structure (DIR) */
 
 typedef struct {
-	FATFS*	fs;				/* Pointer to the owner file system object (**do not change order**) */
-	WORD	id;				/* Owner file system mount ID (**do not change order**) */
-	WORD	index;			/* Current read/write index number */
-	DWORD	sclust;			/* Table start cluster (0:Root dir) */
+	_FDID	obj;			/* Object identifier */
+	DWORD	dptr;			/* Current read/write offset */
 	DWORD	clust;			/* Current cluster */
 	DWORD	sect;			/* Current sector */
-	BYTE*	dir;			/* Pointer to the current SFN entry in the win[] */
-	BYTE*	fn;				/* Pointer to the SFN (in/out) {file[8],ext[3],status[1]} */
-#if _FS_LOCK
-	UINT	lockid;			/* File lock ID (index of file semaphore table Files[]) */
-#endif
-#if _USE_LFN
+	BYTE*	dir;			/* Pointer to the directory item in the win[] */
+	BYTE*	fn;				/* Pointer to the SFN (in/out) {body[8],ext[3],status[1]} */
+#if _USE_LFN != 0
+	DWORD	blk_ofs;		/* Offset of current entry block being processed (0xFFFFFFFF:Invalid) */
 	WCHAR*	lfn;			/* Pointer to the LFN working buffer */
-	WORD	lfn_idx;		/* Last matched LFN index number (0xFFFF:No LFN) */
 #endif
 #if _USE_FIND
-	const TCHAR*	pat;	/* Pointer to the name matching pattern */
+	const TCHAR* pat;		/* Pointer to the name matching pattern */
 #endif
 } DIR;
 
@@ -166,14 +198,15 @@
 /* File information structure (FILINFO) */
 
 typedef struct {
-	DWORD	fsize;			/* File size */
-	WORD	fdate;			/* Last modified date */
-	WORD	ftime;			/* Last modified time */
-	BYTE	fattrib;		/* Attribute */
-	TCHAR	fname[13];		/* Short file name (8.3 format) */
-#if _USE_LFN
-	TCHAR*	lfname;			/* Pointer to the LFN buffer */
-	UINT 	lfsize;			/* Size of LFN buffer in TCHAR */
+	FSIZE_t	fsize;			/* File size */
+	WORD	fdate;			/* Modified date */
+	WORD	ftime;			/* Modified time */
+	BYTE	fattrib;		/* File attribute */
+#if _USE_LFN != 0
+	TCHAR	altname[13];			/* Altenative file name */
+	TCHAR	fname[_MAX_LFN + 1];	/* Primary file name */
+#else
+	TCHAR	fname[13];		/* File name */
 #endif
 } FILINFO;
 
@@ -200,7 +233,7 @@
 	FR_TIMEOUT,				/* (15) Could not get a grant to access the volume within defined period */
 	FR_LOCKED,				/* (16) The operation is rejected according to the file sharing policy */
 	FR_NOT_ENOUGH_CORE,		/* (17) LFN working buffer could not be allocated */
-	FR_TOO_MANY_OPEN_FILES,	/* (18) Number of open files > _FS_SHARE */
+	FR_TOO_MANY_OPEN_FILES,	/* (18) Number of open files > _FS_LOCK */
 	FR_INVALID_PARAMETER	/* (19) Given parameter is invalid */
 } FRESULT;
 
@@ -213,8 +246,7 @@
 FRESULT f_close (FIL* fp);											/* Close an open file object */
 FRESULT f_read (FIL* fp, void* buff, UINT btr, UINT* br);			/* Read data from a file */
 FRESULT f_write (FIL* fp, const void* buff, UINT btw, UINT* bw);	/* Write data to a file */
-FRESULT f_forward (FIL* fp, UINT(*func)(const BYTE*,UINT), UINT btf, UINT* bf);	/* Forward data to the stream */
-FRESULT f_lseek (FIL* fp, DWORD ofs);								/* Move file pointer of a file object */
+FRESULT f_lseek (FIL* fp, FSIZE_t ofs);								/* Move file pointer of a file object */
 FRESULT f_truncate (FIL* fp);										/* Truncate file */
 FRESULT f_sync (FIL* fp);											/* Flush cached data of a writing file */
 FRESULT f_opendir (DIR* dp, const TCHAR* path);						/* Open a directory */
@@ -227,7 +259,7 @@
 FRESULT f_rename (const TCHAR* path_old, const TCHAR* path_new);	/* Rename/Move a file or directory */
 FRESULT f_stat (const TCHAR* path, FILINFO* fno);					/* Get file status */
 FRESULT f_chmod (const TCHAR* path, BYTE attr, BYTE mask);			/* Change attribute of the file/dir */
-FRESULT f_utime (const TCHAR* path, const FILINFO* fno);			/* Change times-tamp of the file/dir */
+FRESULT f_utime (const TCHAR* path, const FILINFO* fno);			/* Change timestamp of the file/dir */
 FRESULT f_chdir (const TCHAR* path);								/* Change current directory */
 FRESULT f_chdrive (const TCHAR* path);								/* Change current drive */
 FRESULT f_getcwd (TCHAR* buff, UINT len);							/* Get current directory */
@@ -234,6 +266,8 @@
 FRESULT f_getfree (const TCHAR* path, DWORD* nclst, FATFS** fatfs);	/* Get number of free clusters on the drive */
 FRESULT f_getlabel (const TCHAR* path, TCHAR* label, DWORD* vsn);	/* Get volume label */
 FRESULT f_setlabel (const TCHAR* label);							/* Set volume label */
+FRESULT f_forward (FIL* fp, UINT(*func)(const BYTE*,UINT), UINT btf, UINT* bf);	/* Forward data to the stream */
+FRESULT f_expand (FIL* fp, FSIZE_t szf, BYTE opt);					/* Allocate a contiguous block to the file */
 FRESULT f_mount (FATFS* fs, const TCHAR* path, BYTE opt);			/* Mount/Unmount a logical drive */
 FRESULT f_mkfs (const TCHAR* path, BYTE sfd, UINT au);				/* Create a file system on the volume */
 FRESULT f_fdisk (BYTE pdrv, const DWORD szt[], void* work);			/* Divide a physical drive into some partitions */
@@ -242,10 +276,10 @@
 int f_printf (FIL* fp, const TCHAR* str, ...);						/* Put a formatted string to the file */
 TCHAR* f_gets (TCHAR* buff, int len, FIL* fp);						/* Get a string from the file */
 
-#define f_eof(fp) ((int)((fp)->fptr == (fp)->fsize))
+#define f_eof(fp) ((int)((fp)->fptr == (fp)->obj.objsize))
 #define f_error(fp) ((fp)->err)
 #define f_tell(fp) ((fp)->fptr)
-#define f_size(fp) ((fp)->fsize)
+#define f_size(fp) ((fp)->obj.objsize)
 #define f_rewind(fp) f_lseek((fp), 0)
 #define f_rewinddir(dp) f_readdir((dp), 0)
 
@@ -265,7 +299,7 @@
 #endif
 
 /* Unicode support functions */
-#if _USE_LFN							/* Unicode - OEM code conversion */
+#if _USE_LFN != 0						/* Unicode - OEM code conversion */
 WCHAR ff_convert (WCHAR chr, UINT dir);	/* OEM-Unicode bidirectional conversion */
 WCHAR ff_wtoupper (WCHAR chr);			/* Unicode upper-case conversion */
 #if _USE_LFN == 3						/* Memory functions */
@@ -292,16 +326,13 @@
 /* File access control and file status flags (FIL.flag) */
 
 #define	FA_READ				0x01
+#define	FA_WRITE			0x02
 #define	FA_OPEN_EXISTING	0x00
-
-#if !_FS_READONLY
-#define	FA_WRITE			0x02
 #define	FA_CREATE_NEW		0x04
 #define	FA_CREATE_ALWAYS	0x08
 #define	FA_OPEN_ALWAYS		0x10
-#define FA__WRITTEN			0x20
-#define FA__DIRTY			0x40
-#endif
+#define _FA_MODIFIED		0x20
+#define _FA_DIRTY			0x40
 
 
 /* FAT sub type (FATFS.fs_type) */
@@ -309,6 +340,7 @@
 #define FS_FAT12	1
 #define FS_FAT16	2
 #define FS_FAT32	3
+#define FS_EXFAT	4
 
 
 /* File attribute bits for directory entry */
@@ -323,26 +355,10 @@
 #define AM_MASK	0x3F	/* Mask of defined bits */
 
 
-/* Fast seek feature */
-#define CREATE_LINKMAP	0xFFFFFFFF
+/* Fast seek controls */
+#define CREATE_LINKMAP	((FSIZE_t)0 - 1)
 
 
-
-/*--------------------------------*/
-/* Multi-byte word access macros  */
-
-#if _WORD_ACCESS == 1	/* Enable word access to the FAT structure */
-#define	LD_WORD(ptr)		(WORD)(*(WORD*)(BYTE*)(ptr))
-#define	LD_DWORD(ptr)		(DWORD)(*(DWORD*)(BYTE*)(ptr))
-#define	ST_WORD(ptr,val)	*(WORD*)(BYTE*)(ptr)=(WORD)(val)
-#define	ST_DWORD(ptr,val)	*(DWORD*)(BYTE*)(ptr)=(DWORD)(val)
-#else					/* Use byte-by-byte access to the FAT structure */
-#define	LD_WORD(ptr)		(WORD)(((WORD)*((BYTE*)(ptr)+1)<<8)|(WORD)*(BYTE*)(ptr))
-#define	LD_DWORD(ptr)		(DWORD)(((DWORD)*((BYTE*)(ptr)+3)<<24)|((DWORD)*((BYTE*)(ptr)+2)<<16)|((WORD)*((BYTE*)(ptr)+1)<<8)|*(BYTE*)(ptr))
-#define	ST_WORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8)
-#define	ST_DWORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8); *((BYTE*)(ptr)+2)=(BYTE)((DWORD)(val)>>16); *((BYTE*)(ptr)+3)=(BYTE)((DWORD)(val)>>24)
-#endif
-
 #ifdef __cplusplus
 }
 #endif
Index: kernel/ffconf.h
===================================================================
--- kernel/ffconf.h	(revision 334)
+++ kernel/ffconf.h	(working copy)
@@ -1,21 +1,13 @@
 /*---------------------------------------------------------------------------/
-/  FatFs - FAT file system module configuration file  R0.11 (C)ChaN, 2015
+/  FatFs - FAT file system module configuration file  R0.12  (C)ChaN, 2016
 /---------------------------------------------------------------------------*/
 
-#define _FFCONF 32020	/* Revision ID */
+#define _FFCONF 88100	/* Revision ID */
 
 /*---------------------------------------------------------------------------/
-/ Functions and Buffer Configurations
+/ Function Configurations
 /---------------------------------------------------------------------------*/
 
-#define	_FS_TINY		1
-/* This option switches tiny buffer configuration. (0:Normal or 1:Tiny)
-/  At the tiny configuration, size of the file object (FIL) is reduced _MAX_SS
-/  bytes. Instead of private sector buffer eliminated from the file object,
-/  common sector buffer in the file system object (FATFS) is used for the file
-/  data transfer. */
-
-
 #define _FS_READONLY	0
 /* This option switches read-only configuration. (0:Read/Write or 1:Read-only)
 /  Read-only configuration removes writing API functions, f_write(), f_sync(),
@@ -27,8 +19,8 @@
 /* This option defines minimization level to remove some basic API functions.
 /
 /   0: All basic functions are enabled.
-/   1: f_stat(), f_getfree(), f_unlink(), f_mkdir(), f_chmod(), f_utime(),
-/      f_truncate() and f_rename() function are removed.
+/   1: f_stat(), f_getfree(), f_unlink(), f_mkdir(), f_truncate() and f_rename()
+/      are removed.
 /   2: f_opendir(), f_readdir() and f_closedir() are removed in addition to 1.
 /   3: f_lseek() function is removed in addition to 2. */
 
@@ -43,8 +35,8 @@
 
 
 #define _USE_FIND		0
-/* This option switches filtered directory read feature and related functions,
-/  f_findfirst() and f_findnext(). (0:Disable or 1:Enable) */
+/* This option switches filtered directory read functions, f_findfirst() and
+/  f_findnext(). (0:Disable, 1:Enable 2:Enable with matching altname[] too) */
 
 
 #define	_USE_MKFS		0
@@ -52,9 +44,18 @@
 
 
 #define	_USE_FASTSEEK	1
-/* This option switches fast seek feature. (0:Disable or 1:Enable) */
+/* This option switches fast seek function. (0:Disable or 1:Enable) */
 
 
+#define	_USE_EXPAND		0
+/* This option switches f_expand function. (0:Disable or 1:Enable) */
+
+
+#define _USE_CHMOD		0
+/* This option switches attribute manipulation functions, f_chmod() and f_utime().
+/  (0:Disable or 1:Enable) Also _FS_READONLY needs to be 0 to enable this option. */
+
+
 #define _USE_LABEL		0
 /* This option switches volume label functions, f_getlabel() and f_setlabel().
 /  (0:Disable or 1:Enable) */
@@ -62,7 +63,7 @@
 
 #define	_USE_FORWARD	0
 /* This option switches f_forward() function. (0:Disable or 1:Enable)
-/  To enable it, also _FS_TINY need to be set to 1. */
+/  To enable it, also _FS_TINY need to be 1. */
 
 
 /*---------------------------------------------------------------------------/
@@ -73,45 +74,44 @@
 /* This option specifies the OEM code page to be used on the target system.
 /  Incorrect setting of the code page can cause a file open failure.
 /
-/   932  - Japanese Shift_JIS (DBCS, OEM, Windows)
-/   936  - Simplified Chinese GBK (DBCS, OEM, Windows)
-/   949  - Korean (DBCS, OEM, Windows)
-/   950  - Traditional Chinese Big5 (DBCS, OEM, Windows)
-/   1250 - Central Europe (Windows)
-/   1251 - Cyrillic (Windows)
-/   1252 - Latin 1 (Windows)
-/   1253 - Greek (Windows)
-/   1254 - Turkish (Windows)
-/   1255 - Hebrew (Windows)
-/   1256 - Arabic (Windows)
-/   1257 - Baltic (Windows)
-/   1258 - Vietnam (OEM, Windows)
-/   437  - U.S. (OEM)
-/   720  - Arabic (OEM)
-/   737  - Greek (OEM)
-/   775  - Baltic (OEM)
-/   850  - Multilingual Latin 1 (OEM)
-/   858  - Multilingual Latin 1 + Euro (OEM)
-/   852  - Latin 2 (OEM)
-/   855  - Cyrillic (OEM)
-/   866  - Russian (OEM)
-/   857  - Turkish (OEM)
-/   862  - Hebrew (OEM)
-/   874  - Thai (OEM, Windows)
-/   1    - ASCII (No extended character. Valid for only non-LFN configuration.) */
+/   1   - ASCII (No extended character. Non-LFN cfg. only)
+/   437 - U.S.
+/   720 - Arabic
+/   737 - Greek
+/   771 - KBL
+/   775 - Baltic
+/   850 - Latin 1
+/   852 - Latin 2
+/   855 - Cyrillic
+/   857 - Turkish
+/   860 - Portuguese
+/   861 - Icelandic
+/   862 - Hebrew
+/   863 - Canadian French
+/   864 - Arabic
+/   865 - Nordic
+/   866 - Russian
+/   869 - Greek 2
+/   932 - Japanese (DBCS)
+/   936 - Simplified Chinese (DBCS)
+/   949 - Korean (DBCS)
+/   950 - Traditional Chinese (DBCS)
+*/
 
 
 #define	_USE_LFN	2
 #define	_MAX_LFN	255
-/* The _USE_LFN option switches the LFN feature.
+/* The _USE_LFN switches the support of long file name (LFN).
 /
-/   0: Disable LFN feature. _MAX_LFN has no effect.
+/   0: Disable support of LFN. _MAX_LFN has no effect.
 /   1: Enable LFN with static working buffer on the BSS. Always NOT thread-safe.
 /   2: Enable LFN with dynamic working buffer on the STACK.
 /   3: Enable LFN with dynamic working buffer on the HEAP.
 /
-/  When enable the LFN feature, Unicode handling functions (option/unicode.c) must
-/  be added to the project. The LFN working buffer occupies (_MAX_LFN + 1) * 2 bytes.
+/  To enable the LFN, Unicode handling functions (option/unicode.c) must be added
+/  to the project. The working buffer occupies (_MAX_LFN + 1) * 2 bytes and
+/  additional 608 bytes at exFAT enabled. _MAX_LFN can be in range from 12 to 255.
+/  It should be set 255 to support full featured LFN operations.
 /  When use stack for the working buffer, take care on stack overflow. When use heap
 /  memory for the working buffer, memory management functions, ff_memalloc() and
 /  ff_memfree(), must be added to the project. */
@@ -119,12 +119,12 @@
 
 #define	_LFN_UNICODE	1
 /* This option switches character encoding on the API. (0:ANSI/OEM or 1:Unicode)
-/  To use Unicode string for the path name, enable LFN feature and set _LFN_UNICODE
-/  to 1. This option also affects behavior of string I/O functions. */
+/  To use Unicode string for the path name, enable LFN and set _LFN_UNICODE = 1.
+/  This option also affects behavior of string I/O functions. */
 
 
 #define _STRF_ENCODE	3
-/* When _LFN_UNICODE is 1, this option selects the character encoding on the file to
+/* When _LFN_UNICODE == 1, this option selects the character encoding on the file to
 /  be read/written via string I/O functions, f_gets(), f_putc(), f_puts and f_printf().
 /
 /  0: ANSI/OEM
@@ -132,17 +132,16 @@
 /  2: UTF-16BE
 /  3: UTF-8
 /
-/  When _LFN_UNICODE is 0, this option has no effect. */
+/  This option has no effect when _LFN_UNICODE == 0. */
 
 
 #define _FS_RPATH	0
-/* This option configures relative path feature.
+/* This option configures support of relative path.
 /
-/   0: Disable relative path feature and remove related functions.
-/   1: Enable relative path feature. f_chdir() and f_chdrive() are available.
+/   0: Disable relative path and remove related functions.
+/   1: Enable relative path. f_chdir() and f_chdrive() are available.
 /   2: f_getcwd() function is available in addition to 1.
-/
-/  Note that directory items read via f_readdir() are affected by this option. */
+*/
 
 
 /*---------------------------------------------------------------------------/
@@ -155,7 +154,7 @@
 
 #define _STR_VOLUME_ID	0
 #define _VOLUME_STRS	"RAM","NAND","CF","SD1","SD2","USB1","USB2","USB3"
-/* _STR_VOLUME_ID option switches string volume ID feature.
+/* _STR_VOLUME_ID switches string support of volume ID.
 /  When _STR_VOLUME_ID is set to 1, also pre-defined strings can be used as drive
 /  number in the path name. _VOLUME_STRS defines the drive ID strings for each
 /  logical drives. Number of items must be equal to _VOLUMES. Valid characters for
@@ -163,11 +162,12 @@
 
 
 #define	_MULTI_PARTITION	0
-/* This option switches multi-partition feature. By default (0), each logical drive
-/  number is bound to the same physical drive number and only an FAT volume found on
-/  the physical drive will be mounted. When multi-partition feature is enabled (1),
-/  each logical drive number is bound to arbitrary physical drive and partition
-/  listed in the VolToPart[]. Also f_fdisk() funciton will be available. */
+/* This option switches support of multi-partition on a physical drive.
+/  By default (0), each logical drive number is bound to the same physical drive
+/  number and only an FAT volume found on the physical drive will be mounted.
+/  When multi-partition is enabled (1), each logical drive number can be bound to
+/  arbitrary physical drive and partition listed in the VolToPart[]. Also f_fdisk()
+/  funciton will be available. */
 
 
 #define	_MIN_SS		512
@@ -181,8 +181,8 @@
 
 
 #define	_USE_TRIM	0
-/* This option switches ATA-TRIM feature. (0:Disable or 1:Enable)
-/  To enable Trim feature, also CTRL_TRIM command should be implemented to the
+/* This option switches support of ATA-TRIM. (0:Disable or 1:Enable)
+/  To enable Trim function, also CTRL_TRIM command should be implemented to the
 /  disk_ioctl() function. */
 
 
@@ -203,40 +203,53 @@
 / System Configurations
 /---------------------------------------------------------------------------*/
 
+#define	_FS_TINY	1
+/* This option switches tiny buffer configuration. (0:Normal or 1:Tiny)
+/  At the tiny configuration, size of the file object (FIL) is reduced _MAX_SS bytes.
+/  Instead of private sector buffer eliminated from the file object, common sector
+/  buffer in the file system object (FATFS) is used for the file data transfer. */
+
+
+#define _FS_EXFAT	0
+/* This option switches support of exFAT file system in addition to the traditional
+/  FAT file system. (0:Disable or 1:Enable) To enable exFAT, also LFN must be enabled.
+/  Note that enabling exFAT discards C89 compatibility. */
+
+
 #define _FS_NORTC	0
-#define _NORTC_MON	2
+#define _NORTC_MON	3
 #define _NORTC_MDAY	1
-#define _NORTC_YEAR	2015
-/* The _FS_NORTC option switches timestamp feature. If the system does not have
-/  an RTC function or valid timestamp is not needed, set _FS_NORTC to 1 to disable
-/  the timestamp feature. All objects modified by FatFs will have a fixed timestamp
-/  defined by _NORTC_MON, _NORTC_MDAY and _NORTC_YEAR.
-/  When timestamp feature is enabled (_FS_NORTC	== 0), get_fattime() function need
-/  to be added to the project to read current time form RTC. _NORTC_MON,
+#define _NORTC_YEAR	2016
+/* The option _FS_NORTC switches timestamp functiton. If the system does not have
+/  any RTC function or valid timestamp is not needed, set _FS_NORTC = 1 to disable
+/  the timestamp function. All objects modified by FatFs will have a fixed timestamp
+/  defined by _NORTC_MON, _NORTC_MDAY and _NORTC_YEAR in local time.
+/  To enable timestamp function (_FS_NORTC = 0), get_fattime() function need to be
+/  added to the project to get current time form real-time clock. _NORTC_MON,
 /  _NORTC_MDAY and _NORTC_YEAR have no effect. 
-/  These options have no effect at read-only configuration (_FS_READONLY == 1). */
+/  These options have no effect at read-only configuration (_FS_READONLY = 1). */
 
 
 #define	_FS_LOCK	0
-/* The _FS_LOCK option switches file lock feature to control duplicated file open
+/* The option _FS_LOCK switches file lock function to control duplicated file open
 /  and illegal operation to open objects. This option must be 0 when _FS_READONLY
 /  is 1.
 /
-/  0:  Disable file lock feature. To avoid volume corruption, application program
+/  0:  Disable file lock function. To avoid volume corruption, application program
 /      should avoid illegal open, remove and rename to the open objects.
-/  >0: Enable file lock feature. The value defines how many files/sub-directories
+/  >0: Enable file lock function. The value defines how many files/sub-directories
 /      can be opened simultaneously under file lock control. Note that the file
-/      lock feature is independent of re-entrancy. */
+/      lock control is independent of re-entrancy. */
 
 
 #define _FS_REENTRANT	0
 #define _FS_TIMEOUT		1000
 #define	_SYNC_t			HANDLE
-/* The _FS_REENTRANT option switches the re-entrancy (thread safe) of the FatFs
+/* The option _FS_REENTRANT switches the re-entrancy (thread safe) of the FatFs
 /  module itself. Note that regardless of this option, file access to different
 /  volume is always re-entrant and volume control functions, f_mount(), f_mkfs()
 /  and f_fdisk() function, are always not re-entrant. Only file/directory access
-/  to the same volume is under control of this feature.
+/  to the same volume is under control of this function.
 /
 /   0: Disable re-entrancy. _FS_TIMEOUT and _SYNC_t have no effect.
 /   1: Enable re-entrancy. Also user provided synchronization handlers,
@@ -246,29 +259,8 @@
 /
 /  The _FS_TIMEOUT defines timeout period in unit of time tick.
 /  The _SYNC_t defines O/S dependent sync object type. e.g. HANDLE, ID, OS_EVENT*,
-/  SemaphoreHandle_t and etc.. */
+/  SemaphoreHandle_t and etc.. A header file for O/S definitions needs to be
+/  included somewhere in the scope of ff.c. */
 
 
-#define _WORD_ACCESS	0
-/* The _WORD_ACCESS option is an only platform dependent option. It defines
-/  which access method is used to the word data on the FAT volume.
-/
-/   0: Byte-by-byte access. Always compatible with all platforms.
-/   1: Word access. Do not choose this unless under both the following conditions.
-/
-/  * Address misaligned memory access is always allowed to ALL instructions.
-/  * Byte order on the memory is little-endian.
-/
-/  If it is the case, _WORD_ACCESS can also be set to 1 to reduce code size.
-/  Following table shows allowable settings of some processor types.
-/
-/   ARM7TDMI    0           ColdFire    0           V850E       0
-/   Cortex-M3   0           Z80         0/1         V850ES      0/1
-/   Cortex-M0   0           x86         0/1         TLCS-870    0/1
-/   AVR         0/1         RX600(LE)   0/1         TLCS-900    0/1
-/   AVR32       0           RL78        0           R32C        0
-/   PIC18       0/1         SH-2        0           M16C        0/1
-/   PIC24       0           H8S         0           MSP430      0
-/   PIC32       0           H8/300H     0           8051        0/1
-*/
-
+/*--- End of configuration options ---*/
Index: kernel/GCAM.c
===================================================================
--- kernel/GCAM.c	(revision 334)
+++ kernel/GCAM.c	(working copy)
@@ -109,6 +109,24 @@
 	return name;
 }
 
+u8 GCAMCARDIsValid( u8 *mem )
+{
+	u8 valid = 0;
+	switch(TRIGame)
+	{
+		case TRI_GP1:
+		case TRI_GP2:
+			valid = (memcmp(mem, "MKA", 3) == 0);
+			break;
+		case TRI_AX:
+			valid = (memcmp(mem+0x8A, "SEGABGG", 7) == 0);
+			break;
+		default:
+			break;
+	}
+	return valid;
+}
+			
 void GCAMCARDCleanStatus( u32 status )
 {
 	if(status < 0x96)
@@ -335,13 +353,20 @@
 								FIL fi;
 								if( f_open_char( &fi, GCAMGetCARDName(), FA_READ|FA_OPEN_EXISTING ) == FR_OK )
 								{
-									if( fi.fsize > 0 )
+									if( fi.obj.objsize > 0 && fi.obj.objsize <= 0xD0 )
 									{
-										CARDMemorySize = fi.fsize;
-										if( TRIGame == TRI_AX )
-											CARDBit = 2;
-										else
-											CARDBit = 1;
+										u8 *cmem = (u8*)malloca( fi.obj.objsize, 32 );
+										u32 read;
+										f_read( &fi, cmem, fi.obj.objsize, &read );
+										if(GCAMCARDIsValid(cmem))
+										{
+											CARDMemorySize = fi.obj.objsize;
+											if( TRIGame == TRI_AX )
+												CARDBit = 2;
+											else
+												CARDBit = 1;
+										}
+										free(cmem);
 									}
 									f_close(&fi);
 								}
@@ -393,14 +418,22 @@
 							FIL cf;
 							if( f_open_char( &cf, GCAMGetCARDName(), FA_READ|FA_OPEN_EXISTING ) == FR_OK )
 							{
-								if( CARDMemorySize == 0 )
-									CARDMemorySize = cf.fsize;
-
-								u32 read;
-								f_read( &cf, CARDMemory, CARDMemorySize, &read );
+								if( cf.obj.objsize > 0 && cf.obj.objsize <= 0xD0 )
+								{
+									u8 *cmem = (u8*)malloca( cf.obj.objsize, 32 );
+									u32 read;
+									f_read( &cf, cmem, cf.obj.objsize, &read );
+									if(GCAMCARDIsValid(cmem))
+									{
+										if( CARDMemorySize == 0 )
+											CARDMemorySize = cf.obj.objsize;
+										memcpy(CARDMemory, cmem, CARDMemorySize);
+										sync_after_write(CARDMemory, CARDMemorySize);
+										CARDIsInserted = 1;
+									}
+									free(cmem);
+								}
 								f_close( &cf );
-								sync_after_write(CARDMemory, CARDMemorySize);
-								CARDIsInserted = 1;
 							}
 
 							CARDReadPacket[POff++] = 0x02;	// SUB CMD
@@ -448,22 +481,8 @@
 		#ifdef DEBUG_CARD
 							dbgprintf("CARDWrite: %u\n", CARDMemorySize );
 		#endif
-							u32 CARDIsValid;
-							switch(TRIGame)
+							if(GCAMCARDIsValid(CARDMemory))
 							{
-								case TRI_GP1:
-								case TRI_GP2:
-									CARDIsValid = (memcmp(CARDMemory, "MKA", 3) == 0);
-									break;
-								case TRI_AX:
-									CARDIsValid = (memcmp(CARDMemory+0x8A, "SEGABGG", 7) == 0);
-									break;
-								default:
-									CARDIsValid = 0;
-									break;
-							}
-							if(CARDIsValid)
-							{
 								DIFinishAsync(); //DONT ever try todo file i/o async
 								FIL cf;
 								if( f_open_char( &cf, GCAMGetCARDName(), FA_WRITE|FA_CREATE_ALWAYS ) == FR_OK )
Index: kernel/global.h
===================================================================
--- kernel/global.h	(revision 334)
+++ kernel/global.h	(working copy)
@@ -11,6 +11,7 @@
 //#define CARDDEBUG 1
 #define AUDIOSTREAM 1
 #define PATCHALL	1
+//#define PERFMON 1
 
 //#define DEBUG_ES	1
 #define DEBUG_HID	1
@@ -189,7 +190,9 @@
 	TRI_GP1,
 	TRI_GP2,
 	TRI_AX,
+	TRI_VS3,
 	TRI_VS4,
+	TRI_YAK,
 	TRI_SB,
 } TRIGames;
 
Index: kernel/HID.c
===================================================================
--- kernel/HID.c	(revision 334)
+++ kernel/HID.c	(working copy)
@@ -37,7 +37,7 @@
 #define ControlMessage 18
 #define InterruptMessage 19
 
-static u8 ss_led_pattern[8] = {0x0, 0x02, 0x04, 0x08, 0x10, 0x12, 0x14, 0x18};
+static const u8 ss_led_pattern[8] = {0x0, 0x02, 0x04, 0x08, 0x10, 0x12, 0x14, 0x18};
 
 s32 HIDHandle = -1;
 u32 PS3LedSet = 0;
@@ -55,14 +55,13 @@
 u32 RawRumbleDataLen = 0;
 u32 RumbleTransferLen = 0;
 u32 RumbleTransfers = 0;
-u32 HIDEnabled = 0;
-unsigned char rawData[] =
+static const unsigned char rawData[] =
 {
-    0x01, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xFF, 0x27, 0x10, 0x00, 0x32, 
-    0xFF, 0x27, 0x10, 0x00, 0x32, 0xFF, 0x27, 0x10, 0x00, 0x32, 0xFF, 0x27, 0x10, 0x00, 0x32, 0x00, 
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 
-} ;
+	0x01, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xFF, 0x27, 0x10, 0x00, 0x32, 
+	0xFF, 0x27, 0x10, 0x00, 0x32, 0xFF, 0x27, 0x10, 0x00, 0x32, 0xFF, 0x27, 0x10, 0x00, 0x32, 0x00, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00,
+};
 
 struct _usb_msg readreq ALIGNED(32);
 struct _usb_msg writereq ALIGNED(32);
@@ -272,11 +271,11 @@
 			dbgprintf("HID:Failed to open config file:%u\r\n", ret );
 		else
 		{
-			Data = (char*)malloc( f.fsize + 1 );
+			Data = (char*)malloc( f.obj.objsize + 1 );
 			if(Data)
 			{
-				f_read( &f, Data, f.fsize, &read );
-				Data[f.fsize] = 0x00;	//null terminate the file
+				f_read( &f, Data, f.obj.objsize, &read );
+				Data[f.obj.objsize] = 0x00;	//null terminate the file
 			}
 			f_close(&f);
 		}
@@ -554,11 +553,6 @@
 	return 0;
 }
 
-void HIDEnable()
-{
-	HIDEnabled = 1;
-}
-
 void HIDClose()
 {
 	IOS_Close(HIDHandle);
@@ -783,64 +777,74 @@
 	str += strlen(entryname); // Skip '='
 
 	char *strEnd = strchr( str, 0x0A );
+	u32 ret = 0;
+	u32 i;
 
-	if( Entry == 0 )
+	switch (Entry)
 	{
-		return atox(str);
+		case 0:
+			ret = atox(str);
+			break;
 
-	} else if ( Entry == 1 ) {
+		case 1:
+			str = strstr( str, "," );
+			if( str == (char*)NULL || str > strEnd )
+			{
+				dbgprintf("No \",\" found in entry.\r\n");
+				break;
+			}
 
-		str = strstr( str, "," );
-		if( str == (char*)NULL || str > strEnd )
-		{
-			dbgprintf("No \",\" found in entry.\r\n");
-			return 0;
-		}
+			str++; //Skip ,
 
-		str++; //Skip ,
+			ret = atox(str);
+			break;
 
-		return atox(str);
-	} else if ( Entry == 2 ) {
+		case 2:
+			str = strstr( str, "," );
+			if( str == (char*)NULL || str > strEnd )
+			{
+				dbgprintf("No \",\" found in entry.\r\n");
+				break;
+			}
 
-		str = strstr( str, "," );
-		if( str == (char*)NULL || str > strEnd )
-		{
-			dbgprintf("No \",\" found in entry.\r\n");
-			return 0;
-		}
+			str++; //Skip the first ,
 
-		str++; //Skip the first ,
+			str = strstr( str, "," );
+			if( str == (char*)NULL || str > strEnd )
+			{
+				dbgprintf("No \",\" found in entry.\r\n");
+				break;
+			}
 
-		str = strstr( str, "," );
-		if( str == (char*)NULL || str > strEnd )
-		{
-			dbgprintf("No \",\" found in entry.\r\n");
-			return 0;
-		}
+			str++; //Skip the second ,
 
-		str++; //Skip the second ,
+			ret = atox(str);
+			break;
 
-		return atox(str);
-	} else if ( Entry == 3 ) {
-		u32 i;
-		for(i = 0; i < RawRumbleDataLen; ++i)
-		{
-			RawRumbleDataOn[i] = atox(str);
-			str = strstr( str, "," )+1;
-		}
-	} else if ( Entry == 4 ) {
-		u32 i;
-		for(i = 0; i < RawRumbleDataLen; ++i)
-		{
-			RawRumbleDataOff[i] = atox(str);
-			str = strstr( str, "," )+1;
-		}
+		case 3:
+			for(i = 0; i < RawRumbleDataLen; ++i)
+			{
+				RawRumbleDataOn[i] = atox(str);
+				str = strstr( str, "," )+1;
+			}
+			break;
+
+		case 4:
+			for(i = 0; i < RawRumbleDataLen; ++i)
+			{
+				RawRumbleDataOff[i] = atox(str);
+				str = strstr( str, "," )+1;
+			}
+			break;
+
+		default:
+			break;
 	}
 
-	return 0;
+	return ret;
 }
 
-int atoi(char *s)
+static int atoi(char *s)
 {
 	int i=0;
 	int val = 0;
@@ -852,6 +856,7 @@
 	}
 	return val;
 }
+
 u32 ConfigGetDecValue( char *Data, const char *EntryName, u32 Entry )
 {
 	char entryname[128];
@@ -867,47 +872,54 @@
 	str += strlen(entryname); // Skip '='
 
 	char *strEnd = strchr( str, 0x0A );
+	u32 ret = 0;
 
-	if( Entry == 0 )
+	switch (Entry)
 	{
-		return atoi(str);
+		case 0:
+			ret = atoi(str);
+			break;
 
-	} else if ( Entry == 1 ) {
+		case 1:
+			str = strstr( str, "," );
+			if( str == (char*)NULL || str > strEnd )
+			{
+				dbgprintf("No \",\" found in entry.\r\n");
+				break;
+			}
 
-		str = strstr( str, "," );
-		if( str == (char*)NULL || str > strEnd )
-		{
-			dbgprintf("No \",\" found in entry.\r\n");
-			return 0;
-		}
+			str++; //Skip ,
 
-		str++; //Skip ,
+			ret = atoi(str);
+			break;
 
-		return atoi(str);
-	} else if ( Entry == 2 ) {
+		case 2:
+			str = strstr( str, "," );
+			if( str == (char*)NULL  || str > strEnd )
+			{
+				dbgprintf("No \",\" found in entry.\r\n");
+				break;
+			}
 
-		str = strstr( str, "," );
-		if( str == (char*)NULL  || str > strEnd )
-		{
-			dbgprintf("No \",\" found in entry.\r\n");
-			return 0;
-		}
+			str++; //Skip the first ,
 
-		str++; //Skip the first ,
+			str = strstr( str, "," );
+			if( str == (char*)NULL  || str > strEnd )
+			{
+				dbgprintf("No \",\" found in entry.\r\n");
+				break;
+			}
 
-		str = strstr( str, "," );
-		if( str == (char*)NULL  || str > strEnd )
-		{
-			dbgprintf("No \",\" found in entry.\r\n");
-			return 0;
-		}
+			str++; //Skip the second ,
 
-		str++; //Skip the second ,
+			ret = atoi(str);
+			break;
 
-		return atoi(str);
+		default:
+			break;
 	}
 
-	return 0;
+	return ret;
 }
 
 void HIDUpdateRegisters(u32 LoaderRequest)
Index: kernel/HID.h
===================================================================
--- kernel/HID.h	(revision 334)
+++ kernel/HID.h	(working copy)
@@ -99,7 +99,6 @@
 
 void HIDInit();
 s32 HIDOpen();
-void HIDEnable();
 void HIDClose();
 void HIDUpdateRegisters(u32 LoaderRequest);
 void HIDGCInit( void );
Index: kernel/integer.h
===================================================================
--- kernel/integer.h	(revision 334)
+++ kernel/integer.h	(working copy)
@@ -9,25 +9,30 @@
 
 #include <windows.h>
 #include <tchar.h>
+typedef unsigned __int64 QWORD;
 
+
 #else			/* Embedded platform */
 
-/* This type MUST be 8 bit */
+/* These types MUST be 16-bit or 32-bit */
+typedef int				INT;
+typedef unsigned int	UINT;
+
+/* This type MUST be 8-bit */
 typedef unsigned char	BYTE;
 
-/* These types MUST be 16 bit */
+/* These types MUST be 16-bit */
 typedef short			SHORT;
 typedef unsigned short	WORD;
 typedef unsigned short	WCHAR;
 
-/* These types MUST be 16 bit or 32 bit */
-typedef int				INT;
-typedef unsigned int	UINT;
-
-/* These types MUST be 32 bit */
+/* These types MUST be 32-bit */
 typedef long			LONG;
 typedef unsigned long	DWORD;
 
+/* This type MUST be 64-bit (Remove this for C89 compatibility) */
+typedef unsigned long long QWORD;
+
 #endif
 
 #endif
Index: kernel/ISO.c
===================================================================
--- kernel/ISO.c	(revision 334)
+++ kernel/ISO.c	(working copy)
@@ -64,6 +64,8 @@
 	s32 ret = f_open_char( &GameFile, ConfigGetGamePath(), FA_READ|FA_OPEN_EXISTING );
 	if( ret != FR_OK )
 		return false;
+
+#if _USE_FASTSEEK
 	/* Setup table */
 	u32 tblsize = 4; //minimum default size
 	GameFile.cltbl = malloc(tblsize * sizeof(DWORD));
@@ -78,6 +80,7 @@
 		GameFile.cltbl[0] = tblsize;
 		f_lseek(&GameFile, CREATE_LINKMAP);
 	}
+#endif /* _USE_FASTSEEK */
 
 	/* Setup direct reader */
 	ISOFileOpen = 1;
@@ -106,8 +109,10 @@
 	if(ISOFileOpen)
 	{
 		f_close( &GameFile );
+#if _USE_FASTSEEK
 		free(GameFile.cltbl);
 		GameFile.cltbl = NULL;
+#endif /* _USE_FASTSEEK */
 	}
 	ISOFileOpen = 0;
 }
Index: kernel/JVSIO.c
===================================================================
--- kernel/JVSIO.c	(revision 334)
+++ kernel/JVSIO.c	(working copy)
@@ -18,6 +18,9 @@
 extern vu8 m_msg[0x80];
 
 extern vu32 TRIGame;
+vu32 TRICoinOffset = 0;
+vu32 AXTimerOffset = 0;
+void *TRICoinOffsetAligned = 0;
 static const char *TRI_SegaChar = "SEGA ENTERPRISES,LTD.;I/O BD JVS;837-13551;Ver1.00";
 static const char *TRI_NamcoChar = "namco ltd.;FCA-1;Ver1.01;JPN,Multipurpose + Rotary Encoder";
 static const u32 TRI_DefaultCoinCount = 9;
@@ -42,57 +45,18 @@
 	//																DataIn[DataPos+6],
 	//																DataIn[DataPos+7] );
 
-	switch(TRIGame)
+	if(TRICoinOffset)
 	{
-		case TRI_GP1:
-		{
-			sync_before_read( (void*)0x00577760, 0x20 );
-			write32( 0x00577760, TRI_DefaultCoinCount ); // MGP credits
-			sync_after_write( (void*)0x00577760,0x20 );
-		} break;
-		case TRI_GP2:
-		{
-			sync_before_read( (void*)0x00690AC0, 0x20 );
-			write32( 0x00690AC0, TRI_DefaultCoinCount ); // MGP2 credits
-			sync_after_write( (void*)0x00690AC0, 0x20 );
-		} break;
-		case TRI_AX:
-		{
-			sync_before_read( (void*)0x00400DE0, 0x20 );
-			write32( 0x00400DE8, TRI_DefaultCoinCount ); // FZeroAX credits
-			sync_after_write( (void*)0x00400DE0, 0x20 );
-
-			sync_before_read( (void*)0x003CD6A0, 0x20 );
-			write32( 0x003CD6A0, 0x00001734 );	// FZeroAX menu timer to 99
-			sync_after_write( (void*)0x003CD6A0, 0x20 );
-
-			//sync_before_read( (void*)0x003BC400, 0x20 );
-			//write32( 0x003BC400, 0x803BB940 );	// Crash hack
-			//sync_after_write( (void*)0x003BC400, 0x20 );
-
-			//sync_before_read( (void*)0x03CFBE0, 0x20 );
-			//u32 val = read32( 0x03CFBF4 ) & 0xFFFF00FF;
-			//write32( 0x03CFBF4, val | 0x0400 ); //Difficulty=Hardest
-			//sync_after_write( (void*)0x03CFBE0, 0x20 );
-		} break;
-		case TRI_VS4:
-		{
-			if( read32( 0x0210C08 ) == 0x386000A8 )	// EXPORT
-			{
-				sync_before_read( (void*)0x064C6A0, 0x20 );
-				write32( 0x064C6B0, TRI_DefaultCoinCount ); // credits
-				sync_after_write( (void*)0x064C6A0, 0x20 );
-			}
-			if( read32( 0x024E888 ) == 0x386000A8 ) // JAPAN
-			{
-				sync_before_read( (void*)0x0694BA0, 0x20 );
-				write32( 0x0694BB0, TRI_DefaultCoinCount ); // credits
-				sync_after_write( (void*)0x0694BA0, 0x20 );
-			}
-		} break;
-		default:
-			break;
+		sync_before_read( TRICoinOffsetAligned, 0x20 );
+		write32( TRICoinOffset, TRI_DefaultCoinCount );
+		sync_after_write( TRICoinOffsetAligned, 0x20 );
 	}
+	if(AXTimerOffset)
+	{
+		sync_before_read( (void*)AXTimerOffset, 0x20 );
+		write32( AXTimerOffset, 0x00001734 );	// FZeroAX menu timer to 99
+		sync_after_write( (void*)AXTimerOffset, 0x20 );
+	}
 
 	JVSIOMessage();
 
@@ -121,7 +85,7 @@
 			case 0x10:
 			{
 				addDataByte(1);
-				if( TRIGame == TRI_VS4 )
+				if( TRIGame == TRI_VS3 || TRIGame == TRI_VS4 )
 					addDataString(TRI_SegaChar);
 				else
 					addDataString(TRI_NamcoChar);
@@ -170,6 +134,16 @@
 				addDataByte(1);
 				switch(TRIGame)
 				{
+					case TRI_YAK:
+					case TRI_VS3:
+					{
+						// 2 Player, 1 Coin slot, no Analog-in
+						addDataBuffer((void *)"\x01\x02\x09\x00", 4);
+						addDataBuffer((void *)"\x02\x01\x00\x00", 4);
+						addDataBuffer((void *)"\x03\x00\x00\x00", 4);
+						addDataBuffer((void *)"\x10\x01\x00\x00", 4);
+						addDataBuffer((void *)"\x00\x00\x00\x00", 4);
+					} break;
 					case TRI_VS4:
 					{
 						// 2 Player, 1 Coin slot, 4 Analog-in
@@ -284,6 +258,26 @@
 									PlayerData[0] |= 0x10; // Paddle Right
 							}
 							break;
+						case TRI_VS3:
+							if( PadBuff[i].button & PAD_BUTTON_START )
+								PlayerData[0] |= 0x80; // Start
+							if( PadBuff[i].triggerRight > 0x44 )
+								PlayerData[0] |= 0x40; // Service button
+							if( PadBuff[i].stickY > 0x30 )
+								PlayerData[0] |= 0x20; // Move Up
+							if( PadBuff[i].stickY < -0x30 )
+								PlayerData[0] |= 0x10; // Move Down
+							if( PadBuff[i].stickX < -0x30 )
+								PlayerData[0] |= 0x08; // Move Right
+							if( PadBuff[i].stickX > 0x30 )
+								PlayerData[0] |= 0x04; // Move Left
+							if( PadBuff[i].button & PAD_BUTTON_A )
+								PlayerData[0] |= 0x02; // Long Pass
+							if( PadBuff[i].button & PAD_BUTTON_X )
+								PlayerData[0] |= 0x01; // Shoot
+							if( PadBuff[i].button & PAD_BUTTON_B )
+								PlayerData[1] |= 0x80; // Short Pass
+							break;
 						case TRI_VS4:
 							if( PadBuff[i].button & PAD_BUTTON_START )
 								PlayerData[0] |= 0x80; // Start
@@ -295,15 +289,35 @@
 								PlayerData[0] |= 0x08; // Tactics (M)
 							if( PadBuff[i].button & PAD_BUTTON_DOWN )
 								PlayerData[0] |= 0x04; // Tactics (D)
-							if( PadBuff[i].button & PAD_BUTTON_Y )
+							if( PadBuff[i].button & PAD_BUTTON_B )
 								PlayerData[0] |= 0x02; // Short Pass
+							if( PadBuff[i].button & PAD_BUTTON_A )
+								PlayerData[0] |= 0x01; // Long Pass
 							if( PadBuff[i].button & PAD_BUTTON_X )
-								PlayerData[0] |= 0x01; // Long Pass
-							if( PadBuff[i].button & PAD_BUTTON_A )
 								PlayerData[1] |= 0x80; // Shoot
-							if( PadBuff[i].button & PAD_BUTTON_B )
+							if( PadBuff[i].button & PAD_BUTTON_Y )
 								PlayerData[1] |= 0x40; // Dash
 							break;
+						case TRI_YAK:
+							if( PadBuff[i].button & PAD_BUTTON_START )
+								PlayerData[0] |= 0x80; // Start
+							if( PadBuff[i].triggerRight > 0x44 )
+								PlayerData[0] |= 0x40; // Service button
+							if( PadBuff[i].stickY > 0x30 )
+								PlayerData[0] |= 0x20; // Move Up
+							if( PadBuff[i].stickY < -0x30 )
+								PlayerData[0] |= 0x10; // Move Down
+							if( PadBuff[i].stickX < -0x30 )
+								PlayerData[0] |= 0x08; // Move Right
+							if( PadBuff[i].stickX > 0x30 )
+								PlayerData[0] |= 0x04; // Move Left
+							if( PadBuff[i].button & PAD_BUTTON_A )
+								PlayerData[0] |= 0x02; // A
+							if( PadBuff[i].button & PAD_BUTTON_B )
+								PlayerData[0] |= 0x01; // B
+							if( PadBuff[i].button & PAD_BUTTON_X )
+								PlayerData[1] |= 0x80; // Gekitou
+							break;
 						default:
 							break;
 					}
@@ -334,56 +348,52 @@
 			{
 				addDataByte(1);	// status
 				int players = *jvs_io++;
-
+				int analogVals = 1;
 				for( i=0; i < players; ++i )
 				{
-					int val1 = 0, val2 = 0;
+					int val = 0;
 					switch(TRIGame)
 					{
 						case TRI_GP1:
 						case TRI_GP2:
 							if(i == 0)
-								val1 = PadBuff[0].stickX + 0x80; // Steering
+								val = PadBuff[0].stickX + 0x80; // Steering
 							else if(i == 1)
-								val1 = PadBuff[0].triggerRight >> 1; //Gas
+								val = PadBuff[0].triggerRight >> 1; //Gas
 							else if(i == 2)
-								val1 = PadBuff[0].triggerLeft >> 1; //Brake
+								val = PadBuff[0].triggerLeft >> 1; //Brake
 							break;
 						case TRI_AX:
 							if(i == 0)
-								val1 = PadBuff[0].stickX + 0x80; // Steering X
+								val = PadBuff[0].stickX + 0x80; // Steering X
 							else if(i == 1)
-								val1 = PadBuff[0].stickY + 0x80; // Steering Y
+								val = PadBuff[0].stickY + 0x80; // Steering Y
 							else if(i == 4) {
-								if(PadBuff[0].button & PAD_BUTTON_A) val1 = 0x7F; //Gas
+								if(PadBuff[0].button & PAD_BUTTON_A) val = 0xFF; //Gas
 							} else if(i == 5) {
-								if(PadBuff[0].button & PAD_BUTTON_B) val1 = 0x7F; //Brake
+								if(PadBuff[0].button & PAD_BUTTON_B) val = 0xFF; //Brake
 							}
 							break;
 						case TRI_VS4:
 							if(i == 0)
-								val1 = -PadBuff[0].stickY + 0x7F; // Analog Y
+								val = -PadBuff[0].stickY + 0x7F; // Analog Y
 							else if(i == 1)
-								val1 = PadBuff[0].stickX + 0x80; // Analog X
+								val = PadBuff[0].stickX + 0x80; // Analog X
 							else if(i == 2)
-								val1 = -PadBuff[1].stickY + 0x7F; // Analog Y (P2)
+								val = -PadBuff[1].stickY + 0x7F; // Analog Y (P2)
 							else if(i == 3)
-								val1 = PadBuff[1].stickX + 0x80; // Analog X (P2)
+								val = PadBuff[1].stickX + 0x80; // Analog X (P2)
 							break;
 						default:
+							analogVals = 0;
 							break;
 					}
-					/*if (i < 4)
-						val = 0x7FFF;
-					else if (i < 6)
-						val = 42 * 0x101;
-					else
-						val = 0;*/
-
-					unsigned char player_data[2] = {val1, val2};
-
-					addDataByte( player_data[0] );
-					addDataByte( player_data[1] );
+					if(analogVals)
+					{
+						unsigned char player_data[2] = {val, 0};
+						addDataByte( player_data[0] );
+						addDataByte( player_data[1] );
+					}
 				}
 
 			} break;
Index: kernel/kernel.ld
===================================================================
--- kernel/kernel.ld	(revision 334)
+++ kernel/kernel.ld	(working copy)
@@ -4,13 +4,16 @@
 ENTRY(_start)
 
 __stack_size = 0x2000;
-__phy_stack_addr = 0x12F86000 + __stack_size;
+__phy_stack_addr = 0x12F96000 + __stack_size;
 
 __di_stack_size = 0x1000;
 __di_stack_addr = __phy_stack_addr + __di_stack_size;
 
+__realdi_stack_size = 0x400;
+__realdi_stack_addr = __di_stack_addr + __realdi_stack_size;
+
 __hid_read_stack_size = 0x400;
-__hid_read_stack_addr = __di_stack_addr + __hid_read_stack_size;
+__hid_read_stack_addr = __realdi_stack_addr + __hid_read_stack_size;
 
 __hid_change_stack_size = 0x400;
 __hid_change_stack_addr = __hid_read_stack_addr + __hid_change_stack_size;
@@ -23,8 +26,8 @@
 
 MEMORY {
 
-	code		: ORIGIN = 0x20F00000,	LENGTH = 0x28000
-	data		: ORIGIN = 0x20F28000,	LENGTH = 0x58000
+	code		: ORIGIN = 0x20F00000,	LENGTH = 0x30000
+	data		: ORIGIN = 0x20F30000,	LENGTH = 0x60000
 	stack		: ORIGIN = 0x20106000,	LENGTH = 0x09000
 }
 
@@ -31,8 +34,8 @@
 PHDRS
 {
 	code  PT_LOAD AT ( 0x12F00000 );
-	data  PT_LOAD AT ( 0x12F28000 );
-	stack PT_LOAD AT ( 0x12F86000 );
+	data  PT_LOAD AT ( 0x12F30000 );
+	stack PT_LOAD AT ( 0x12F96000 );
 }
 
 SECTIONS
@@ -54,7 +57,7 @@
 		. = ALIGN(4);
 	} >code :code
 
-	.rodata (0x20F28000) : AT( 0x12F28000 )
+	.rodata (0x20F30000) : AT( 0x12F30000 )
 	{
 		*(.rodata)
 		*all.rodata*(*)
@@ -64,7 +67,7 @@
 		. = ALIGN(4);
 	} >data :data
 
-	.data (0x20F28000 + SIZEOF(.rodata)) : AT( 0x12F28000 + SIZEOF(.rodata) )
+	.data (0x20F30000 + SIZEOF(.rodata)) : AT( 0x12F30000 + SIZEOF(.rodata) )
 	{
 		*(.data)
 		*(.data.*)
@@ -72,7 +75,7 @@
 		. = ALIGN(4);
 	} >data :data
 
-	.bss (0x20F28000 + SIZEOF(.rodata) + SIZEOF(.data)) : AT( 0x12F28000 + SIZEOF(.rodata) + SIZEOF(.data) )
+	.bss (0x20F30000 + SIZEOF(.rodata) + SIZEOF(.data)) : AT( 0x12F30000 + SIZEOF(.rodata) + SIZEOF(.data) )
 	{
 		__bss_start = . ;
 		*(.dynbss)
@@ -83,7 +86,7 @@
 		__bss_end = . ;
 	} >data :data
 
-	.stack (0x20106000) : AT( 0x12F86000 )
+	.stack (0x20106000) : AT( 0x12F96000 )
 	{
 		__stack_end = .;
 		. = . +__stack_size;
Index: kernel/main.c
===================================================================
--- kernel/main.c	(revision 334)
+++ kernel/main.c	(working copy)
@@ -23,6 +23,7 @@
 #include "common.h"
 #include "alloc.h"
 #include "DI.h"
+#include "RealDI.h"
 #include "ES.h"
 #include "SI.h"
 #include "BT.h"
@@ -36,10 +37,11 @@
 #include "diskio.h"
 #include "usbstorage.h"
 #include "SDI.h"
+#define DI_STACK_SIZE 0x400
 
 //#undef DEBUG
 
-u32 RealDiscCMD = 0;
+bool access_led = false;
 u32 USBReadTimer = 0;
 extern u32 s_size;
 extern u32 s_cnt;
@@ -50,6 +52,7 @@
 
 extern u32 SI_IRQ;
 extern bool DI_IRQ, EXI_IRQ;
+extern u32 WaitForRealDisc;
 extern struct ipcmessage DI_CallbackMsg;
 extern u32 DI_MessageQueue;
 extern vu32 DisableSIPatch;
@@ -132,26 +135,7 @@
 
 	//Verification if we can read from disc
 	if(memcmp(ConfigGetGamePath(), "di", 3) == 0)
-	{
-		ClearRealDiscBuffer();
-		u32 Length = 0x20;
-		RealDiscCMD = DIP_CMD_NORMAL;
-		u8 *TmpBuf = ReadRealDisc(&Length, 0, false);
-		if(IsGCGame((u32)TmpBuf) == false)
-		{
-			Length = 0x800;
-			RealDiscCMD = DIP_CMD_DVDR;
-			TmpBuf = ReadRealDisc(&Length, 0, false);
-			if(IsGCGame((u32)TmpBuf) == false)
-			{
-				dbgprintf("No GC Disc!\r\n");
-				BootStatusError(-2, -2);
-				mdelay(4000);
-				Shutdown();
-			}
-		}
-		dbgprintf("DI:Reading real disc with command 0x%02X\r\n", RealDiscCMD);
-	}
+		RealDI_Init(); //will shutdown on fail
 
 	BootStatus(3, 0, 0);
 	fatfs = (FATFS*)malloca( sizeof(FATFS), 32 );
@@ -227,15 +211,6 @@
 	GCAMInit();
 
 	EXIInit();
-
-	ret = Check_Cheats();
-	if(ret < 0 )
-	{
-		dbgprintf("Check_Cheats failed\r\n" );
-		BootStatusError(-10, ret);
-		mdelay(4000);
-		Shutdown();
-	}
 	
 	BootStatus(11, s_size, s_cnt);
 
@@ -258,15 +233,23 @@
 	u32 DiscChangeTimer = Now;
 	u32 ResetTimer = Now;
 	u32 InterruptTimer = Now;
+#ifdef PERFMON
+	u32 loopCnt = 0;
+	u32 loopPrintTimer = Now;
+#endif
 	USBReadTimer = Now;
 	u32 Reset = 0;
 	bool SaveCard = false;
-	if( ConfigGetConfig(NIN_CFG_LED) )
+
+	//enable ios led use
+	access_led = ConfigGetConfig(NIN_CFG_LED);
+	if(access_led)
 	{
 		set32(HW_GPIO_ENABLE, GPIO_SLOT_LED);
 		clear32(HW_GPIO_DIR, GPIO_SLOT_LED);
 		clear32(HW_GPIO_OWNER, GPIO_SLOT_LED);
 	}
+	
 	set32(HW_GPIO_ENABLE, GPIO_SENSOR_BAR);
 	clear32(HW_GPIO_DIR, GPIO_SENSOR_BAR);
 	clear32(HW_GPIO_OWNER, GPIO_SENSOR_BAR);
@@ -294,8 +277,15 @@
 	while (1)
 	{
 		_ahbMemFlush(0);
-
-		//Does interrupts again if needed
+#ifdef PERFMON
+		loopCnt++;
+		if(TimerDiffTicks(loopPrintTimer) > 1898437)
+		{
+			dbgprintf("%08i\r\n",loopCnt);
+			loopPrintTimer = read32(HW_TIMER);
+			loopCnt = 0;
+		}
+#endif		//Does interrupts again if needed
 		if(TimerDiffTicks(InterruptTimer) > 15820) //about 120 times a second
 		{
 			sync_before_read((void*)INT_BASE, 0x80);
@@ -334,8 +324,12 @@
 				SaveCard = false;
 			}
 		}
-		else if(UseUSB && TimerDiffSeconds(USBReadTimer) > 149) /* Read random sector every 2 mins 30 secs */
+		else if(UseUSB && TimerDiffSeconds(USBReadTimer) > 109) /* Read random sector every 1 min 50 secs */
 		{
+			if( ConfigGetConfig(NIN_CFG_HID) )
+		{}
+		else
+		{
 			DIFinishAsync(); //if something is still running
 			DI_CallbackMsg.result = -1;
 			sync_after_write(&DI_CallbackMsg, 0x20);
@@ -343,16 +337,36 @@
 			DIFinishAsync();
 			USBReadTimer = read32(HW_TIMER);
 		}
-		udelay(10); //wait for other threads
+		}
+		udelay(20); //wait for other threads
 
-		//Baten Kaitos save hax
-		/*if( read32(0) == 0x474B4245 )
+		if( WaitForRealDisc == 1 )
 		{
-			if( read32( 0x0073E640 ) == 0xFFFFFFFF )
+			if(RealDI_NewDisc())
 			{
-				write32( 0x0073E640, 0 );
+				DiscChangeTimer = read32(HW_TIMER);
+				WaitForRealDisc = 2; //do another flush round, safety!
 			}
-		}*/
+		}
+		else if( WaitForRealDisc == 2 )
+		{
+			if(TimerDiffSeconds(DiscChangeTimer))
+			{
+				//identify disc after flushing everything
+				RealDI_Identify(false);
+				//clear our fake regs again
+				sync_before_read((void*)DI_BASE, 0x40);
+				write32(DI_IMM, 0);
+				write32(DI_COVER, 0);
+				sync_after_write((void*)DI_BASE, 0x40);
+				//mask and clear interrupts
+				write32( DIP_STATUS, 0x54 );
+				//disable cover irq which DIP enabled
+				write32( DIP_COVER, 4 );
+				DIInterrupt();
+				WaitForRealDisc = 0;
+			}
+		}
 
 		if ( DiscChangeIRQ == 1 )
 		{
@@ -387,6 +401,7 @@
 		vu32 reset_status = read32(RESET_STATUS);
 		if (reset_status == 0x1DEA)
 		{
+			dbgprintf("Game Exit\r\n");
 			write32(RESET_STATUS, 0);
 			sync_after_write((void*)RESET_STATUS, 0x20);
 			DIFinishAsync();
@@ -396,7 +411,7 @@
 		{
 			if (Reset == 0)
 			{
-				dbgprintf("Fake Reset IRQ\n");
+				dbgprintf("Fake Reset IRQ\r\n");
 				write32( RSW_INT, 0x2 ); // Reset irq
 				sync_after_write( (void*)RSW_INT, 0x20 );
 				write32(HW_IPC_ARMCTRL, (1 << 0) | (1 << 4)); //throw irq
@@ -474,9 +489,6 @@
 		wait_for_ppc(1);
 	}
 
-	if( ConfigGetConfig(NIN_CFG_LED) )
-		clear32(HW_GPIO_OUT, GPIO_SLOT_LED);
-
 	if( ConfigGetConfig(NIN_CFG_MEMCARDEMU) )
 		EXIShutdown();
 
@@ -496,6 +508,8 @@
 		USBStorage_Shutdown();
 	else
 		SDHCShutdown();
+//make sure drive led is off before quitting
+	if( access_led ) clear32(HW_GPIO_OUT, GPIO_SLOT_LED);
 
 //make sure we set that back to the original
 	write32(HW_PPCSPEED, ori_ppcspeed);
Index: kernel/Makefile
===================================================================
--- kernel/Makefile	(revision 334)
+++ kernel/Makefile	(working copy)
@@ -4,7 +4,7 @@
 LD	=	$(PREFIX)gcc
 STRIP =	$(PREFIX)strip
 
-CFLAGS	=	-mbig-endian -O2 -g -I. -Wall -mcpu=arm926ej-s -msoft-float -mfloat-abi=soft -fdata-sections -ffunction-sections \
+CFLAGS	=	-mbig-endian -O3 -g -I. -Wall -mcpu=arm926ej-s -msoft-float -mfloat-abi=soft -fdata-sections -ffunction-sections \
 	-fno-builtin-toupper -fno-builtin-memcpy -fno-builtin-memset -fno-builtin-memcmp -fno-builtin-malloc -fno-builtin-free
 
 ASFLAGS	=	-mbig-endian -mcpu=arm926ej-s
@@ -11,8 +11,8 @@
 LDFLAGS	=	-nostartfiles -nodefaultlibs -mbig-endian -Wl,--gc-sections,-T,kernel.ld,-Map,kernel.map -n
 
 TARGET	=	kernel.elf
-OBJECTS	=	start.o common.o alloc.o GCAM.o JVSIO.o JVSIOMessage.o FST.o DI.o Patch.o PatchTimers.o PatchWidescreen.o ISO.o \
-			Stream.o adp.o EXI.o SI.o option/ccsbcs.o ff.o HID.o diskio.o Config.o utils_asm.o ES.o NAND.o main.o syscalls.o \
+OBJECTS	=	start.o common.o alloc.o GCAM.o JVSIO.o JVSIOMessage.o FST.o DI.o RealDI.o Patch.o PatchTimers.o TRI.o PatchWidescreen.o \
+			ISO.o Stream.o adp.o EXI.o SI.o option/ccsbcs.o ff.o HID.o diskio.o Config.o utils_asm.o ES.o NAND.o main.o syscalls.o \
 			ReadSpeed.o vsprintf.o string.o prs.o SDI.o usb.o usbstorage.o
 BINFILE = ../loader/data/kernel.bin
 
Index: kernel/option/ccsbcs.c
===================================================================
--- kernel/option/ccsbcs.c	(revision 334)
+++ kernel/option/ccsbcs.c	(working copy)
@@ -1,28 +1,24 @@
 /*------------------------------------------------------------------------*/
-/* Unicode - Local code bidirectional converter  (C)ChaN, 2012            */
+/* Unicode - Local code bidirectional converter  (C)ChaN, 2015            */
 /* (SBCS code pages)                                                      */
 /*------------------------------------------------------------------------*/
-/*  437   U.S. (OEM)
-/   720   Arabic (OEM)
-/   1256  Arabic (Windows)
-/   737   Greek (OEM)
-/   1253  Greek (Windows)
-/   1250  Central Europe (Windows)
-/   775   Baltic (OEM)
-/   1257  Baltic (Windows)
-/   850   Multilingual Latin 1 (OEM)
-/   852   Latin 2 (OEM)
-/   1252  Latin 1 (Windows)
-/   855   Cyrillic (OEM)
-/   1251  Cyrillic (Windows)
-/   866   Russian (OEM)
-/   857   Turkish (OEM)
-/   1254  Turkish (Windows)
-/   858   Multilingual Latin 1 + Euro (OEM)
-/   862   Hebrew (OEM)
-/   1255  Hebrew (Windows)
-/   874   Thai (OEM, Windows)
-/   1258  Vietnam (OEM, Windows)
+/*  437   U.S.
+/   720   Arabic
+/   737   Greek
+/   771   KBL
+/   775   Baltic
+/   850   Latin 1
+/   852   Latin 2
+/   855   Cyrillic
+/   857   Turkish
+/   860   Portuguese
+/   861   Icelandic
+/   862   Hebrew
+/   863   Canadian French
+/   864   Arabic
+/   865   Nordic
+/   866   Russian
+/   869   Greek 2
 */
 
 #include "../ff.h"
@@ -32,22 +28,14 @@
 #define _TBLDEF 1
 static
 const WCHAR Tbl[] = {	/*  CP437(0x80-0xFF) to Unicode conversion table */
-	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7,
-	0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x00C4, 0x00C5,
-	0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9,
-	0x00FF, 0x00D6, 0x00DC, 0x00A2, 0x00A3, 0x00A5, 0x20A7, 0x0192,
-	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA,
-	0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
-	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
-	0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
-	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
-	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
-	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B,
-	0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
-	0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4,
-	0x03A6, 0x0398, 0x03A9, 0x03B4, 0x221E, 0x03C6, 0x03B5, 0x2229,
-	0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248,
-	0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0
+	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x00C4, 0x00C5,
+	0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9, 0x00FF, 0x00D6, 0x00DC, 0x00A2, 0x00A3, 0x00A5, 0x20A7, 0x0192,
+	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
+	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
+	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
+	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
+	0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4, 0x03A6, 0x0398, 0x03A9, 0x03B4, 0x221E, 0x03C6, 0x03B5, 0x2229,
+	0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248, 0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0
 };
 
 #elif _CODE_PAGE == 720
@@ -54,22 +42,14 @@
 #define _TBLDEF 1
 static
 const WCHAR Tbl[] = {	/*  CP720(0x80-0xFF) to Unicode conversion table */
-	0x0000, 0x0000, 0x00E9, 0x00E2, 0x0000, 0x00E0, 0x0000, 0x00E7,
-	0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x0000, 0x0000, 0x0000,
-	0x0000, 0x0651, 0x0652, 0x00F4, 0x00A4, 0x0640, 0x00FB, 0x00F9,
-	0x0621, 0x0622, 0x0623, 0x0624, 0x00A3, 0x0625, 0x0626, 0x0627,
-	0x0628, 0x0629, 0x062A, 0x062B, 0x062C, 0x062D, 0x062E, 0x062F,
-	0x0630, 0x0631, 0x0632, 0x0633, 0x0634, 0x0635, 0x00AB, 0x00BB,
-	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
-	0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
-	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
-	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
-	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B,
-	0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
-	0x0636, 0x0637, 0x0638, 0x0639, 0x063A, 0x0641, 0x00B5, 0x0642,
-	0x0643, 0x0644, 0x0645, 0x0646, 0x0647, 0x0648, 0x0649, 0x064A,
-	0x2261, 0x064B, 0x064C, 0x064D, 0x064E, 0x064F, 0x0650, 0x2248,
-	0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0
+	0x0000, 0x0000, 0x00E9, 0x00E2, 0x0000, 0x00E0, 0x0000, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0651, 0x0652, 0x00F4, 0x00A4, 0x0640, 0x00FB, 0x00F9, 0x0621, 0x0622, 0x0623, 0x0624, 0x00A3, 0x0625, 0x0626, 0x0627,
+	0x0628, 0x0629, 0x062A, 0x062B, 0x062C, 0x062D, 0x062E, 0x062F, 0x0630, 0x0631, 0x0632, 0x0633, 0x0634, 0x0635, 0x00AB, 0x00BB,
+	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
+	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
+	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
+	0x0636, 0x0637, 0x0638, 0x0639, 0x063A, 0x0641, 0x00B5, 0x0642, 0x0643, 0x0644, 0x0645, 0x0646, 0x0647, 0x0648, 0x0649, 0x064A,
+	0x2261, 0x064B, 0x064C, 0x064D, 0x064E, 0x064F, 0x0650, 0x2248, 0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0
 };
 
 #elif _CODE_PAGE == 737
@@ -76,44 +56,42 @@
 #define _TBLDEF 1
 static
 const WCHAR Tbl[] = {	/*  CP737(0x80-0xFF) to Unicode conversion table */
-	0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397, 0x0398,
-	0x0399, 0x039A, 0x039B, 0x039C, 0x039D, 0x039E, 0x039F, 0x03A0,
-	0x03A1, 0x03A3, 0x03A4, 0x03A5, 0x03A6, 0x03A7, 0x03A8, 0x03A9,
-	0x03B1, 0x03B2, 0x03B3, 0x03B4, 0x03B5, 0x03B6, 0x03B7, 0x03B8,
-	0x03B9, 0x03BA, 0x03BB, 0x03BC, 0x03BD, 0x03BE, 0x03BF, 0x03C0,
-	0x03C1, 0x03C3, 0x03C2, 0x03C4, 0x03C5, 0x03C6, 0x03C7, 0x03C8,
-	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
-	0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
-	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
-	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
-	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B,
-	0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
-	0x03C9, 0x03AC, 0x03AD, 0x03AE, 0x03CA, 0x03AF, 0x03CC, 0x03CD,
-	0x03CB, 0x03CE, 0x0386, 0x0388, 0x0389, 0x038A, 0x038C, 0x038E,
-	0x038F, 0x00B1, 0x2265, 0x2264, 0x03AA, 0x03AB, 0x00F7, 0x2248,
-	0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0
+	0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397, 0x0398, 0x0399, 0x039A, 0x039B, 0x039C, 0x039D, 0x039E, 0x039F, 0x03A0,
+	0x03A1, 0x03A3, 0x03A4, 0x03A5, 0x03A6, 0x03A7, 0x03A8, 0x03A9, 0x03B1, 0x03B2, 0x03B3, 0x03B4, 0x03B5, 0x03B6, 0x03B7, 0x03B8,
+	0x03B9, 0x03BA, 0x03BB, 0x03BC, 0x03BD, 0x03BE, 0x03BF, 0x03C0, 0x03C1, 0x03C3, 0x03C2, 0x03C4, 0x03C5, 0x03C6, 0x03C7, 0x03C8,
+	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
+	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
+	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
+	0x03C9, 0x03AC, 0x03AD, 0x03AE, 0x03CA, 0x03AF, 0x03CC, 0x03CD, 0x03CB, 0x03CE, 0x0386, 0x0388, 0x0389, 0x038A, 0x038C, 0x038E,
+	0x038F, 0x00B1, 0x2265, 0x2264, 0x03AA, 0x03AB, 0x00F7, 0x2248, 0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0
 };
 
+#elif _CODE_PAGE == 771
+#define _TBLDEF 1
+static
+const WCHAR Tbl[] = {	/*  CP771(0x80-0xFF) to Unicode conversion table */
+	0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417, 0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E, 0x041F,
+	0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427, 0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E, 0x042F,
+	0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437, 0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F,
+	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x2558, 0x2510,
+	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
+	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x0104, 0x0105, 0x010C, 0x010D,
+	0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447, 0x0448, 0x0449, 0x044A, 0x044B, 0x044C, 0x044D, 0x044E, 0x044F,
+	0x0118, 0x0119, 0x0116, 0x0117, 0x012E, 0x012F, 0x0160, 0x0161, 0x0172, 0x0173, 0x016A, 0x016B, 0x017D, 0x017E, 0x25A0, 0x00A0
+};
+
 #elif _CODE_PAGE == 775
 #define _TBLDEF 1
 static
 const WCHAR Tbl[] = {	/*  CP775(0x80-0xFF) to Unicode conversion table */
-	0x0106, 0x00FC, 0x00E9, 0x0101, 0x00E4, 0x0123, 0x00E5, 0x0107,
-	0x0142, 0x0113, 0x0156, 0x0157, 0x012B, 0x0179, 0x00C4, 0x00C5,
-	0x00C9, 0x00E6, 0x00C6, 0x014D, 0x00F6, 0x0122, 0x00A2, 0x015A,
-	0x015B, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x00D7, 0x00A4,
-	0x0100, 0x012A, 0x00F3, 0x017B, 0x017C, 0x017A, 0x201D, 0x00A6,
-	0x00A9, 0x00AE, 0x00AC, 0x00BD, 0x00BC, 0x0141, 0x00AB, 0x00BB,
-	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x0104, 0x010C, 0x0118,
-	0x0116, 0x2563, 0x2551, 0x2557, 0x255D, 0x012E, 0x0160, 0x2510,
-	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x0172, 0x016A,
-	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x017D,
-	0x0105, 0x010D, 0x0119, 0x0117, 0x012F, 0x0161, 0x0173, 0x016B,
-	0x017E, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
-	0x00D3, 0x00DF, 0x014C, 0x0143, 0x00F5, 0x00D5, 0x00B5, 0x0144,
-	0x0136, 0x0137, 0x013B, 0x013C, 0x0146, 0x0112, 0x0145, 0x2019,
-	0x00AD, 0x00B1, 0x201C, 0x00BE, 0x00B6, 0x00A7, 0x00F7, 0x201E,
-	0x00B0, 0x2219, 0x00B7, 0x00B9, 0x00B3, 0x00B2, 0x25A0, 0x00A0
+	0x0106, 0x00FC, 0x00E9, 0x0101, 0x00E4, 0x0123, 0x00E5, 0x0107, 0x0142, 0x0113, 0x0156, 0x0157, 0x012B, 0x0179, 0x00C4, 0x00C5,
+	0x00C9, 0x00E6, 0x00C6, 0x014D, 0x00F6, 0x0122, 0x00A2, 0x015A, 0x015B, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x00D7, 0x00A4,
+	0x0100, 0x012A, 0x00F3, 0x017B, 0x017C, 0x017A, 0x201D, 0x00A6, 0x00A9, 0x00AE, 0x00AC, 0x00BD, 0x00BC, 0x0141, 0x00AB, 0x00BB,
+	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x0104, 0x010C, 0x0118, 0x0116, 0x2563, 0x2551, 0x2557, 0x255D, 0x012E, 0x0160, 0x2510,
+	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x0172, 0x016A, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x017D,
+	0x0105, 0x010D, 0x0119, 0x0117, 0x012F, 0x0161, 0x0173, 0x016B, 0x017E, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
+	0x00D3, 0x00DF, 0x014C, 0x0143, 0x00F5, 0x00D5, 0x00B5, 0x0144, 0x0136, 0x0137, 0x013B, 0x013C, 0x0146, 0x0112, 0x0145, 0x2019,
+	0x00AD, 0x00B1, 0x201C, 0x00BE, 0x00B6, 0x00A7, 0x00F7, 0x201E, 0x00B0, 0x2219, 0x00B7, 0x00B9, 0x00B3, 0x00B2, 0x25A0, 0x00A0
 };
 
 #elif _CODE_PAGE == 850
@@ -120,22 +98,14 @@
 #define _TBLDEF 1
 static
 const WCHAR Tbl[] = {	/*  CP850(0x80-0xFF) to Unicode conversion table */
-	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7,
-	0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x00C4, 0x00C5,
-	0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9,
-	0x00FF, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x00D7, 0x0192,
-	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA,
-	0x00BF, 0x00AE, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
-	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00C1, 0x00C2, 0x00C0,
-	0x00A9, 0x2563, 0x2551, 0x2557, 0x255D, 0x00A2, 0x00A5, 0x2510,
-	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x00E3, 0x00C3,
-	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x00A4,
-	0x00F0, 0x00D0, 0x00CA, 0x00CB, 0x00C8, 0x0131, 0x00CD, 0x00CE,
-	0x00CF, 0x2518, 0x250C, 0x2588, 0x2584, 0x00A6, 0x00CC, 0x2580,
-	0x00D3, 0x00DF, 0x00D4, 0x00D2, 0x00F5, 0x00D5, 0x00B5, 0x00FE,
-	0x00DE, 0x00DA, 0x00DB, 0x00D9, 0x00FD, 0x00DD, 0x00AF, 0x00B4,
-	0x00AD, 0x00B1, 0x2017, 0x00BE, 0x00B6, 0x00A7, 0x00F7, 0x00B8,
-	0x00B0, 0x00A8, 0x00B7, 0x00B9, 0x00B3, 0x00B2, 0x25A0, 0x00A0
+	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x00C4, 0x00C5,
+	0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9, 0x00FF, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x00D7, 0x0192,
+	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x00AE, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
+	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00C1, 0x00C2, 0x00C0, 0x00A9, 0x2563, 0x2551, 0x2557, 0x255D, 0x00A2, 0x00A5, 0x2510,
+	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x00E3, 0x00C3, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x00A4,
+	0x00F0, 0x00D0, 0x00CA, 0x00CB, 0x00C8, 0x0131, 0x00CD, 0x00CE, 0x00CF, 0x2518, 0x250C, 0x2588, 0x2584, 0x00A6, 0x00CC, 0x2580,
+	0x00D3, 0x00DF, 0x00D4, 0x00D2, 0x00F5, 0x00D5, 0x00B5, 0x00FE, 0x00DE, 0x00DA, 0x00DB, 0x00D9, 0x00FD, 0x00DD, 0x00AF, 0x00B4,
+	0x00AD, 0x00B1, 0x2017, 0x00BE, 0x00B6, 0x00A7, 0x00F7, 0x00B8, 0x00B0, 0x00A8, 0x00B7, 0x00B9, 0x00B3, 0x00B2, 0x25A0, 0x00A0
 };
 
 #elif _CODE_PAGE == 852
@@ -142,22 +112,14 @@
 #define _TBLDEF 1
 static
 const WCHAR Tbl[] = {	/*  CP852(0x80-0xFF) to Unicode conversion table */
-	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x016F, 0x0107, 0x00E7,
-	0x0142, 0x00EB, 0x0150, 0x0151, 0x00EE, 0x0179, 0x00C4, 0x0106,
-	0x00C9, 0x0139, 0x013A, 0x00F4, 0x00F6, 0x013D, 0x013E, 0x015A,
-	0x015B, 0x00D6, 0x00DC, 0x0164, 0x0165, 0x0141, 0x00D7, 0x010D,
-	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x0104, 0x0105, 0x017D, 0x017E,
-	0x0118, 0x0119, 0x00AC, 0x017A, 0x010C, 0x015F, 0x00AB, 0x00BB,
-	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00C1, 0x00C2, 0x011A,
-	0x015E, 0x2563, 0x2551, 0x2557, 0x255D, 0x017B, 0x017C, 0x2510,
-	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x0102, 0x0103,
-	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x00A4,
-	0x0111, 0x0110, 0x010E, 0x00CB, 0x010F, 0x0147, 0x00CD, 0x00CE,
-	0x011B, 0x2518, 0x250C, 0x2588, 0x2584, 0x0162, 0x016E, 0x2580,
-	0x00D3, 0x00DF, 0x00D4, 0x0143, 0x0144, 0x0148, 0x0160, 0x0161,
-	0x0154, 0x00DA, 0x0155, 0x0170, 0x00FD, 0x00DD, 0x0163, 0x00B4,
-	0x00AD, 0x02DD, 0x02DB, 0x02C7, 0x02D8, 0x00A7, 0x00F7, 0x00B8,
-	0x00B0, 0x00A8, 0x02D9, 0x0171, 0x0158, 0x0159, 0x25A0, 0x00A0
+	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x016F, 0x0107, 0x00E7, 0x0142, 0x00EB, 0x0150, 0x0151, 0x00EE, 0x0179, 0x00C4, 0x0106,
+	0x00C9, 0x0139, 0x013A, 0x00F4, 0x00F6, 0x013D, 0x013E, 0x015A, 0x015B, 0x00D6, 0x00DC, 0x0164, 0x0165, 0x0141, 0x00D7, 0x010D,
+	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x0104, 0x0105, 0x017D, 0x017E, 0x0118, 0x0119, 0x00AC, 0x017A, 0x010C, 0x015F, 0x00AB, 0x00BB,
+	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00C1, 0x00C2, 0x011A, 0x015E, 0x2563, 0x2551, 0x2557, 0x255D, 0x017B, 0x017C, 0x2510,
+	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x0102, 0x0103, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x00A4,
+	0x0111, 0x0110, 0x010E, 0x00CB, 0x010F, 0x0147, 0x00CD, 0x00CE, 0x011B, 0x2518, 0x250C, 0x2588, 0x2584, 0x0162, 0x016E, 0x2580,
+	0x00D3, 0x00DF, 0x00D4, 0x0143, 0x0144, 0x0148, 0x0160, 0x0161, 0x0154, 0x00DA, 0x0155, 0x0170, 0x00FD, 0x00DD, 0x0163, 0x00B4,
+	0x00AD, 0x02DD, 0x02DB, 0x02C7, 0x02D8, 0x00A7, 0x00F7, 0x00B8, 0x00B0, 0x00A8, 0x02D9, 0x0171, 0x0158, 0x0159, 0x25A0, 0x00A0
 };
 
 #elif _CODE_PAGE == 855
@@ -164,22 +126,14 @@
 #define _TBLDEF 1
 static
 const WCHAR Tbl[] = {	/*  CP855(0x80-0xFF) to Unicode conversion table */
-	0x0452, 0x0402, 0x0453, 0x0403, 0x0451, 0x0401, 0x0454, 0x0404,
-	0x0455, 0x0405, 0x0456, 0x0406, 0x0457, 0x0407, 0x0458, 0x0408,
-	0x0459, 0x0409, 0x045A, 0x040A, 0x045B, 0x040B, 0x045C, 0x040C,
-	0x045E, 0x040E, 0x045F, 0x040F, 0x044E, 0x042E, 0x044A, 0x042A,
-	0x0430, 0x0410, 0x0431, 0x0411, 0x0446, 0x0426, 0x0434, 0x0414,
-	0x0435, 0x0415, 0x0444, 0x0424, 0x0433, 0x0413, 0x00AB, 0x00BB,
-	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x0445, 0x0425, 0x0438,
-	0x0418, 0x2563, 0x2551, 0x2557, 0x255D, 0x0439, 0x0419, 0x2510,
-	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x043A, 0x041A,
-	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x00A4,
-	0x043B, 0x041B, 0x043C, 0x041C, 0x043D, 0x041D, 0x043E, 0x041E,
-	0x043F, 0x2518, 0x250C, 0x2588, 0x2584, 0x041F, 0x044F, 0x2580,
-	0x042F, 0x0440, 0x0420, 0x0441, 0x0421, 0x0442, 0x0422, 0x0443,
-	0x0423, 0x0436, 0x0416, 0x0432, 0x0412, 0x044C, 0x042C, 0x2116,
-	0x00AD, 0x044B, 0x042B, 0x0437, 0x0417, 0x0448, 0x0428, 0x044D,
-	0x042D, 0x0449, 0x0429, 0x0447, 0x0427, 0x00A7, 0x25A0, 0x00A0
+	0x0452, 0x0402, 0x0453, 0x0403, 0x0451, 0x0401, 0x0454, 0x0404, 0x0455, 0x0405, 0x0456, 0x0406, 0x0457, 0x0407, 0x0458, 0x0408,
+	0x0459, 0x0409, 0x045A, 0x040A, 0x045B, 0x040B, 0x045C, 0x040C, 0x045E, 0x040E, 0x045F, 0x040F, 0x044E, 0x042E, 0x044A, 0x042A,
+	0x0430, 0x0410, 0x0431, 0x0411, 0x0446, 0x0426, 0x0434, 0x0414, 0x0435, 0x0415, 0x0444, 0x0424, 0x0433, 0x0413, 0x00AB, 0x00BB,
+	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x0445, 0x0425, 0x0438, 0x0418, 0x2563, 0x2551, 0x2557, 0x255D, 0x0439, 0x0419, 0x2510,
+	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x043A, 0x041A, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x00A4,
+	0x043B, 0x041B, 0x043C, 0x041C, 0x043D, 0x041D, 0x043E, 0x041E, 0x043F, 0x2518, 0x250C, 0x2588, 0x2584, 0x041F, 0x044F, 0x2580,
+	0x042F, 0x0440, 0x0420, 0x0441, 0x0421, 0x0442, 0x0422, 0x0443, 0x0423, 0x0436, 0x0416, 0x0432, 0x0412, 0x044C, 0x042C, 0x2116,
+	0x00AD, 0x044B, 0x042B, 0x0437, 0x0417, 0x0448, 0x0428, 0x044D, 0x042D, 0x0449, 0x0429, 0x0447, 0x0427, 0x00A7, 0x25A0, 0x00A0
 };
 
 #elif _CODE_PAGE == 857
@@ -186,321 +140,141 @@
 #define _TBLDEF 1
 static
 const WCHAR Tbl[] = {	/*  CP857(0x80-0xFF) to Unicode conversion table */
-	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7,
-	0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x0131, 0x00C4, 0x00C5,
-	0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9,
-	0x0130, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x015E, 0x015F,
-	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x011E, 0x011F,
-	0x00BF, 0x00AE, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
-	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00C1, 0x00C2, 0x00C0,
-	0x00A9, 0x2563, 0x2551, 0x2557, 0x255D, 0x00A2, 0x00A5, 0x2510,
-	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x00E3, 0x00C3,
-	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x00A4,
-	0x00BA, 0x00AA, 0x00CA, 0x00CB, 0x00C8, 0x0000, 0x00CD, 0x00CE,
-	0x00CF, 0x2518, 0x250C, 0x2588, 0x2584, 0x00A6, 0x00CC, 0x2580,
-	0x00D3, 0x00DF, 0x00D4, 0x00D2, 0x00F5, 0x00D5, 0x00B5, 0x0000,
-	0x00D7, 0x00DA, 0x00DB, 0x00D9, 0x00EC, 0x00FF, 0x00AF, 0x00B4,
-	0x00AD, 0x00B1, 0x0000, 0x00BE, 0x00B6, 0x00A7, 0x00F7, 0x00B8,
-	0x00B0, 0x00A8, 0x00B7, 0x00B9, 0x00B3, 0x00B2, 0x25A0, 0x00A0
+	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x0131, 0x00C4, 0x00C5,
+	0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9, 0x0130, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x015E, 0x015F,
+	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x011E, 0x011F, 0x00BF, 0x00AE, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
+	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00C1, 0x00C2, 0x00C0, 0x00A9, 0x2563, 0x2551, 0x2557, 0x255D, 0x00A2, 0x00A5, 0x2510,
+	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x00E3, 0x00C3, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x00A4,
+	0x00BA, 0x00AA, 0x00CA, 0x00CB, 0x00C8, 0x0000, 0x00CD, 0x00CE, 0x00CF, 0x2518, 0x250C, 0x2588, 0x2584, 0x00A6, 0x00CC, 0x2580,
+	0x00D3, 0x00DF, 0x00D4, 0x00D2, 0x00F5, 0x00D5, 0x00B5, 0x0000, 0x00D7, 0x00DA, 0x00DB, 0x00D9, 0x00EC, 0x00FF, 0x00AF, 0x00B4,
+	0x00AD, 0x00B1, 0x0000, 0x00BE, 0x00B6, 0x00A7, 0x00F7, 0x00B8, 0x00B0, 0x00A8, 0x00B7, 0x00B9, 0x00B3, 0x00B2, 0x25A0, 0x00A0
 };
 
-#elif _CODE_PAGE == 858
+#elif _CODE_PAGE == 860
 #define _TBLDEF 1
 static
-const WCHAR Tbl[] = {	/*  CP858(0x80-0xFF) to Unicode conversion table */
-	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7,
-	0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x00C4, 0x00C5,
-	0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9,
-	0x00FF, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x00D7, 0x0192,
-	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA,
-	0x00BF, 0x00AE, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
-	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00C1, 0x00C2, 0x00C0,
-	0x00A9, 0x2563, 0x2551, 0x2557, 0x2550, 0x00A2, 0x00A5, 0x2510,
-	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x00E3, 0x00C3,
-	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x00A4,
-	0x00F0, 0x00D0, 0x00CA, 0x00CB, 0x00C8, 0x20AC, 0x00CD, 0x00CE,
-	0x00CF, 0x2518, 0x250C, 0x2588, 0x2584, 0x00C6, 0x00CC, 0x2580,
-	0x00D3, 0x00DF, 0x00D4, 0x00D2, 0x00F5, 0x00D5, 0x00B5, 0x00FE,
-	0x00DE, 0x00DA, 0x00DB, 0x00D9, 0x00FD, 0x00DD, 0x00AF, 0x00B4,
-	0x00AD, 0x00B1, 0x2017, 0x00BE, 0x00B6, 0x00A7, 0x00F7, 0x00B8,
-	0x00B0, 0x00A8, 0x00B7, 0x00B9, 0x00B3, 0x00B2, 0x25A0, 0x00A0
+const WCHAR Tbl[] = {	/*  CP860(0x80-0xFF) to Unicode conversion table */
+	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E3, 0x00E0, 0x00C1, 0x00E7, 0x00EA, 0x00CA, 0x00E8, 0x00CD, 0x00D4, 0x00EC, 0x00C3, 0x00C2,
+	0x00C9, 0x00C0, 0x00C8, 0x00F4, 0x00F5, 0x00F2, 0x00DA, 0x00F9, 0x00CC, 0x00D5, 0x00DC, 0x00A2, 0x00A3, 0x00D9, 0x20A7, 0x00D3,
+	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x00D2, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
+	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x2558, 0x2510,
+	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
+	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
+	0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4, 0x03A6, 0x0398, 0x03A9, 0x03B4, 0x221E, 0x03C6, 0x03B5, 0x2229,
+	0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248, 0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0
 };
 
-#elif _CODE_PAGE == 862
+#elif _CODE_PAGE == 861
 #define _TBLDEF 1
 static
-const WCHAR Tbl[] = {	/*  CP862(0x80-0xFF) to Unicode conversion table */
-	0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7,
-	0x05D8, 0x05D9, 0x05DA, 0x05DB, 0x05DC, 0x05DD, 0x05DE, 0x05DF,
-	0x05E0, 0x05E1, 0x05E2, 0x05E3, 0x05E4, 0x05E5, 0x05E6, 0x05E7,
-	0x05E8, 0x05E9, 0x05EA, 0x00A2, 0x00A3, 0x00A5, 0x20A7, 0x0192,
-	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA,
-	0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
-	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
-	0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
-	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
-	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
-	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B,
-	0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
-	0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4,
-	0x03A6, 0x0398, 0x03A9, 0x03B4, 0x221E, 0x03C6, 0x03B5, 0x2229,
-	0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248,
-	0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0
+const WCHAR Tbl[] = {	/*  CP861(0x80-0xFF) to Unicode conversion table */
+	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E6, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00D0, 0x00F0, 0x00DE, 0x00C4, 0x00C5,
+	0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00FE, 0x00FB, 0x00DD, 0x00FD, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x20A7, 0x0192,
+	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00C1, 0x00CD, 0x00D3, 0x00DA, 0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
+	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
+	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
+	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
+	0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4, 0x03A6, 0x0398, 0x03A9, 0x03B4, 0x221E, 0x03C6, 0x03B5, 0x2229,
+	0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248, 0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0
 };
 
-#elif _CODE_PAGE == 866
+#elif _CODE_PAGE == 862
 #define _TBLDEF 1
 static
-const WCHAR Tbl[] = {	/*  CP866(0x80-0xFF) to Unicode conversion table */
-	0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417,
-	0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E, 0x041F,
-	0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427,
-	0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E, 0x042F,
-	0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437,
-	0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F,
-	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
-	0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
-	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
-	0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
-	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B,
-	0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
-	0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447,
-	0x0448, 0x0449, 0x044A, 0x044B, 0x044C, 0x044D, 0x044E, 0x044F,
-	0x0401, 0x0451, 0x0404, 0x0454, 0x0407, 0x0457, 0x040E, 0x045E,
-	0x00B0, 0x2219, 0x00B7, 0x221A, 0x2116, 0x00A4, 0x25A0, 0x00A0
+const WCHAR Tbl[] = {	/*  CP862(0x80-0xFF) to Unicode conversion table */
+	0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7, 0x05D8, 0x05D9, 0x05DA, 0x05DB, 0x05DC, 0x05DD, 0x05DE, 0x05DF,
+	0x05E0, 0x05E1, 0x05E2, 0x05E3, 0x05E4, 0x05E5, 0x05E6, 0x05E7, 0x05E8, 0x05E9, 0x05EA, 0x00A2, 0x00A3, 0x00A5, 0x20A7, 0x0192,
+	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
+	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
+	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
+	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
+	0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4, 0x03A6, 0x0398, 0x03A9, 0x03B4, 0x221E, 0x03C6, 0x03B5, 0x2229,
+	0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248, 0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0
 };
 
-#elif _CODE_PAGE == 874
+#elif _CODE_PAGE == 863
 #define _TBLDEF 1
 static
-const WCHAR Tbl[] = {	/*  CP874(0x80-0xFF) to Unicode conversion table */
-	0x20AC, 0x0000, 0x0000, 0x0000, 0x0000, 0x2026, 0x0000, 0x0000,
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-	0x00A0, 0x0E01, 0x0E02, 0x0E03, 0x0E04, 0x0E05, 0x0E06, 0x0E07,
-	0x0E08, 0x0E09, 0x0E0A, 0x0E0B, 0x0E0C, 0x0E0D, 0x0E0E, 0x0E0F,
-	0x0E10, 0x0E11, 0x0E12, 0x0E13, 0x0E14, 0x0E15, 0x0E16, 0x0E17,
-	0x0E18, 0x0E19, 0x0E1A, 0x0E1B, 0x0E1C, 0x0E1D, 0x0E1E, 0x0E1F,
-	0x0E20, 0x0E21, 0x0E22, 0x0E23, 0x0E24, 0x0E25, 0x0E26, 0x0E27,
-	0x0E28, 0x0E29, 0x0E2A, 0x0E2B, 0x0E2C, 0x0E2D, 0x0E2E, 0x0E2F,
-	0x0E30, 0x0E31, 0x0E32, 0x0E33, 0x0E34, 0x0E35, 0x0E36, 0x0E37,
-	0x0E38, 0x0E39, 0x0E3A, 0x0000, 0x0000, 0x0000, 0x0000, 0x0E3F,
-	0x0E40, 0x0E41, 0x0E42, 0x0E43, 0x0E44, 0x0E45, 0x0E46, 0x0E47,
-	0x0E48, 0x0E49, 0x0E4A, 0x0E4B, 0x0E4C, 0x0E4D, 0x0E4E, 0x0E4F,
-	0x0E50, 0x0E51, 0x0E52, 0x0E53, 0x0E54, 0x0E55, 0x0E56, 0x0E57,
-	0x0E58, 0x0E59, 0x0E5A, 0x0E5B, 0x0000, 0x0000, 0x0000, 0x0000
+const WCHAR Tbl[] = {	/*  CP863(0x80-0xFF) to Unicode conversion table */
+	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00C2, 0x00E0, 0x00B6, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x2017, 0x00C0,
+	0x00C9, 0x00C8, 0x00CA, 0x00F4, 0x00CB, 0x00CF, 0x00FB, 0x00F9, 0x00A4, 0x00D4, 0x00DC, 0x00A2, 0x00A3, 0x00D9, 0x00DB, 0x0192,
+	0x00A6, 0x00B4, 0x00F3, 0x00FA, 0x00A8, 0x00BB, 0x00B3, 0x00AF, 0x00CE, 0x3210, 0x00AC, 0x00BD, 0x00BC, 0x00BE, 0x00AB, 0x00BB,
+	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
+	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
+	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
+	0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4, 0x03A6, 0x0398, 0x03A9, 0x03B4, 0x221E, 0x03C6, 0x03B5, 0x2219,
+	0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248, 0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0
 };
 
-#elif _CODE_PAGE == 1250
+#elif _CODE_PAGE == 864
 #define _TBLDEF 1
 static
-const WCHAR Tbl[] = {	/*  CP1250(0x80-0xFF) to Unicode conversion table */
-	0x20AC, 0x0000, 0x201A, 0x0000, 0x201E, 0x2026, 0x2020, 0x2021,
-	0x0000, 0x2030, 0x0160, 0x2039, 0x015A, 0x0164, 0x017D, 0x0179,
-	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
-	0x0000, 0x2122, 0x0161, 0x203A, 0x015B, 0x0165, 0x017E, 0x017A,
-	0x00A0, 0x02C7, 0x02D8, 0x0141, 0x00A4, 0x0104, 0x00A6, 0x00A7,
-	0x00A8, 0x00A9, 0x015E, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x017B,
-	0x00B0, 0x00B1, 0x02DB, 0x0142, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
-	0x00B8, 0x0105, 0x015F, 0x00BB, 0x013D, 0x02DD, 0x013E, 0x017C,
-	0x0154, 0x00C1, 0x00C2, 0x0102, 0x00C4, 0x0139, 0x0106, 0x00C7,
-	0x010C, 0x00C9, 0x0118, 0x00CB, 0x011A, 0x00CD, 0x00CE, 0x010E,
-	0x0110, 0x0143, 0x0147, 0x00D3, 0x00D4, 0x0150, 0x00D6, 0x00D7,
-	0x0158, 0x016E, 0x00DA, 0x0170, 0x00DC, 0x00DD, 0x0162, 0x00DF,
-	0x0155, 0x00E1, 0x00E2, 0x0103, 0x00E4, 0x013A, 0x0107, 0x00E7,
-	0x010D, 0x00E9, 0x0119, 0x00EB, 0x011B, 0x00ED, 0x00EE, 0x010F,
-	0x0111, 0x0144, 0x0148, 0x00F3, 0x00F4, 0x0151, 0x00F6, 0x00F7,
-	0x0159, 0x016F, 0x00FA, 0x0171, 0x00FC, 0x00FD, 0x0163, 0x02D9
+const WCHAR Tbl[] = {	/*  CP864(0x80-0xFF) to Unicode conversion table */
+	0x00B0, 0x00B7, 0x2219, 0x221A, 0x2592, 0x2500, 0x2502, 0x253C, 0x2524, 0x252C, 0x251C, 0x2534, 0x2510, 0x250C, 0x2514, 0x2518,
+	0x03B2, 0x221E, 0x03C6, 0x00B1, 0x00BD, 0x00BC, 0x2248, 0x00AB, 0x00BB, 0xFEF7, 0xFEF8, 0x0000, 0x0000, 0xFEFB, 0xFEFC, 0x0000,
+	0x00A0, 0x00AD, 0xFE82, 0x00A3, 0x00A4, 0xFE84, 0x0000, 0x20AC, 0xFE8E, 0xFE8F, 0xFE95, 0xFE99, 0x060C, 0xFE9D, 0xFEA1, 0xFEA5,
+	0x0660, 0x0661, 0x0662, 0x0663, 0x0664, 0x0665, 0x0666, 0x0667, 0x0668, 0x0669, 0xFED1, 0x061B, 0xFEB1, 0xFEB5, 0xFEB9, 0x061F,
+	0x00A2, 0xFE80, 0xFE81, 0xFE83, 0xFE85, 0xFECA, 0xFE8B, 0xFE8D, 0xFE91, 0xFE93, 0xFE97, 0xFE9B, 0xFE9F, 0xFEA3, 0xFEA7, 0xFEA9,
+	0xFEAB, 0xFEAD, 0xFEAF, 0xFEB3, 0xFEB7, 0xFEBB, 0xFEBF, 0xFEC1, 0xFEC5, 0xFECB, 0xFECF, 0x00A6, 0x00AC, 0x00F7, 0x00D7, 0xFEC9,
+	0x0640, 0xFED3, 0xFED7, 0xFEDB, 0xFEDF, 0xFEE3, 0xFEE7, 0xFEEB, 0xFEED, 0xFEEF, 0xFEF3, 0xFEBD, 0xFECC, 0xFECE, 0xFECD, 0xFEE1,
+	0xFE7D, 0x0651, 0xFEE5, 0xFEE9, 0xFEEC, 0xFEF0, 0xFEF2, 0xFED0, 0xFED5, 0xFEF5, 0xFEF6, 0xFEDD, 0xFED9, 0xFEF1, 0x25A0, 0x0000
 };
 
-#elif _CODE_PAGE == 1251
+#elif _CODE_PAGE == 865
 #define _TBLDEF 1
 static
-const WCHAR Tbl[] = {	/*  CP1251(0x80-0xFF) to Unicode conversion table */
-	0x0402, 0x0403, 0x201A, 0x0453, 0x201E, 0x2026, 0x2020, 0x2021,
-	0x20AC, 0x2030, 0x0409, 0x2039, 0x040A, 0x040C, 0x040B, 0x040F,
-	0x0452, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
-	0x0000, 0x2111, 0x0459, 0x203A, 0x045A, 0x045C, 0x045B, 0x045F,
-	0x00A0, 0x040E, 0x045E, 0x0408, 0x00A4, 0x0490, 0x00A6, 0x00A7,
-	0x0401, 0x00A9, 0x0404, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x0407,
-	0x00B0, 0x00B1, 0x0406, 0x0456, 0x0491, 0x00B5, 0x00B6, 0x00B7,
-	0x0451, 0x2116, 0x0454, 0x00BB, 0x0458, 0x0405, 0x0455, 0x0457,
-	0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417,
-	0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E, 0x041F,
-	0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427,
-	0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E, 0x042F,
-	0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437,
-	0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F,
-	0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447,
-	0x0448, 0x0449, 0x044A, 0x044B, 0x044C, 0x044D, 0x044E, 0x044F
+const WCHAR Tbl[] = {	/*  CP865(0x80-0xFF) to Unicode conversion table */
+	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x00C4, 0x00C5,
+	0x00C5, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9, 0x00FF, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x20A7, 0x0192,
+	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00A4,
+	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x2558, 0x2510,
+	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
+	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
+	0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4, 0x03A6, 0x0398, 0x03A9, 0x03B4, 0x221E, 0x03C6, 0x03B5, 0x2229,
+	0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248, 0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0
 };
 
-#elif _CODE_PAGE == 1252
+#elif _CODE_PAGE == 866
 #define _TBLDEF 1
 static
-const WCHAR Tbl[] = {	/*  CP1252(0x80-0xFF) to Unicode conversion table */
-	0x20AC, 0x0000, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,
-	0x02C6, 0x2030, 0x0160, 0x2039, 0x0152, 0x0000, 0x017D, 0x0000,
-	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
-	0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0x0000, 0x017E, 0x0178,
-	0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7,
-	0x00A8, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
-	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
-	0x00B8, 0x00B9, 0x00BA, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF,
-	0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x00C7,
-	0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF,
-	0x00D0, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7,
-	0x00D8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x00DD, 0x00DE, 0x00DF,
-	0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7,
-	0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF,
-	0x00F0, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7,
-	0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x00FF
+const WCHAR Tbl[] = {	/*  CP866(0x80-0xFF) to Unicode conversion table */
+	0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417, 0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E, 0x041F,
+	0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427, 0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E, 0x042F,
+	0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437, 0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F,
+	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
+	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
+	0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
+	0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447, 0x0448, 0x0449, 0x044A, 0x044B, 0x044C, 0x044D, 0x044E, 0x044F,
+	0x0401, 0x0451, 0x0404, 0x0454, 0x0407, 0x0457, 0x040E, 0x045E, 0x00B0, 0x2219, 0x00B7, 0x221A, 0x2116, 0x00A4, 0x25A0, 0x00A0
 };
 
-#elif _CODE_PAGE == 1253
+#elif _CODE_PAGE == 869
 #define _TBLDEF 1
 static
-const WCHAR Tbl[] = {	/*  CP1253(0x80-0xFF) to Unicode conversion table */
-	0x20AC, 0x0000, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,
-	0x0000, 0x2030, 0x0000, 0x2039, 0x000C, 0x0000, 0x0000, 0x0000,
-	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
-	0x0000, 0x2122, 0x0000, 0x203A, 0x0000, 0x0000, 0x0000, 0x0000,
-	0x00A0, 0x0385, 0x0386, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7,
-	0x00A8, 0x00A9, 0x0000, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x2015,
-	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x0384, 0x00B5, 0x00B6, 0x00B7,
-	0x0388, 0x0389, 0x038A, 0x00BB, 0x038C, 0x00BD, 0x038E, 0x038F,
-	0x0390, 0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397,
-	0x0398, 0x0399, 0x039A, 0x039B, 0x039C, 0x039D, 0x039E, 0x039F,
-	0x03A0, 0x03A1, 0x0000, 0x03A3, 0x03A4, 0x03A5, 0x03A6, 0x03A7,
-	0x03A8, 0x03A9, 0x03AA, 0x03AD, 0x03AC, 0x03AD, 0x03AE, 0x03AF,
-	0x03B0, 0x03B1, 0x03B2, 0x03B3, 0x03B4, 0x03B5, 0x03B6, 0x03B7,
-	0x03B8, 0x03B9, 0x03BA, 0x03BB, 0x03BC, 0x03BD, 0x03BE, 0x03BF,
-	0x03C0, 0x03C1, 0x03C2, 0x03C3, 0x03C4, 0x03C5, 0x03C6, 0x03C7,
-	0x03C8, 0x03C9, 0x03CA, 0x03CB, 0x03CC, 0x03CD, 0x03CE, 0x0000
+const WCHAR Tbl[] = {	/*  CP869(0x80-0xFF) to Unicode conversion table */
+	0x00B7, 0x00B7, 0x00B7, 0x00B7, 0x00B7, 0x00B7, 0x0386, 0x00B7, 0x00B7, 0x00AC, 0x00A6, 0x2018, 0x2019, 0x0388, 0x2015, 0x0389,
+	0x038A, 0x03AA, 0x038C, 0x00B7, 0x00B7, 0x038E, 0x03AB, 0x00A9, 0x038F, 0x00B2, 0x00B3, 0x03AC, 0x00A3, 0x03AD, 0x03AE, 0x03AF,
+	0x03CA, 0x0390, 0x03CC, 0x03CD, 0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397, 0x00BD, 0x0398, 0x0399, 0x00AB, 0x00BB,
+	0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x039A, 0x039B, 0x039C, 0x039D, 0x2563, 0x2551, 0x2557, 0x255D, 0x039E, 0x039F, 0x2510,
+	0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x0A30, 0x03A1, 0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x03A3,
+	0x03A4, 0x03A5, 0x03A6, 0x03A7, 0x03A8, 0x03A9, 0x03B1, 0x03B2, 0x03B3, 0x2518, 0x250C, 0x2588, 0x2584, 0x03B4, 0x03B5, 0x2580,
+	0x03B6, 0x03B7, 0x03B8, 0x03B9, 0x03BA, 0x03BB, 0x03BC, 0x03BD, 0x03BE, 0x03BF, 0x03C0, 0x03C1, 0x03C3, 0x03C2, 0x03C4, 0x0384,
+	0x00AD, 0x00B1, 0x03C5, 0x03C6, 0x03C7, 0x00A7, 0x03C8, 0x0385, 0x00B0, 0x00A8, 0x03C9, 0x03CB, 0x03B0, 0x03CE, 0x25A0, 0x00A0
 };
 
-#elif _CODE_PAGE == 1254
-#define _TBLDEF 1
-static
-const WCHAR Tbl[] = {	/*  CP1254(0x80-0xFF) to Unicode conversion table */
-	0x20AC, 0x0000, 0x210A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,
-	0x02C6, 0x2030, 0x0160, 0x2039, 0x0152, 0x0000, 0x0000, 0x0000,
-	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
-	0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0x0000, 0x0000, 0x0178,
-	0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7,
-	0x00A8, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
-	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
-	0x00B8, 0x00B9, 0x00BA, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF,
-	0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x00C7,
-	0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF,
-	0x011E, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7,
-	0x00D8, 0x00D9, 0x00DA, 0x00BD, 0x00DC, 0x0130, 0x015E, 0x00DF,
-	0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7,
-	0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF,
-	0x011F, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7,
-	0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x0131, 0x015F, 0x00FF
-};
-
-#elif _CODE_PAGE == 1255
-#define _TBLDEF 1
-static
-const WCHAR Tbl[] = {	/*  CP1255(0x80-0xFF) to Unicode conversion table */
-	0x20AC, 0x0000, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,
-	0x02C6, 0x2030, 0x0000, 0x2039, 0x0000, 0x0000, 0x0000, 0x0000,
-	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
-	0x02DC, 0x2122, 0x0000, 0x203A, 0x0000, 0x0000, 0x0000, 0x0000,
-	0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7,
-	0x00A8, 0x00A9, 0x00D7, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
-	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
-	0x00B8, 0x00B9, 0x00F7, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF,
-	0x05B0, 0x05B1, 0x05B2, 0x05B3, 0x05B4, 0x05B5, 0x05B6, 0x05B7,
-	0x05B8, 0x05B9, 0x0000, 0x05BB, 0x05BC, 0x05BD, 0x05BE, 0x05BF,
-	0x05C0, 0x05C1, 0x05C2, 0x05C3, 0x05F0, 0x05F1, 0x05F2, 0x05F3,
-	0x05F4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-	0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7,
-	0x05D8, 0x05D9, 0x05DA, 0x05DB, 0x05DC, 0x05DD, 0x05DE, 0x05DF,
-	0x05E0, 0x05E1, 0x05E2, 0x05E3, 0x05E4, 0x05E5, 0x05E6, 0x05E7,
-	0x05E8, 0x05E9, 0x05EA, 0x0000, 0x0000, 0x200E, 0x200F, 0x0000
-};
-
-#elif _CODE_PAGE == 1256
-#define _TBLDEF 1
-static
-const WCHAR Tbl[] = {	/*  CP1256(0x80-0xFF) to Unicode conversion table */
-	0x20AC, 0x067E, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,
-	0x02C6, 0x2030, 0x0679, 0x2039, 0x0152, 0x0686, 0x0698, 0x0688,
-	0x06AF, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
-	0x06A9, 0x2122, 0x0691, 0x203A, 0x0153, 0x200C, 0x200D, 0x06BA,
-	0x00A0, 0x060C, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7,
-	0x00A8, 0x00A9, 0x06BE, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
-	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
-	0x00B8, 0x00B9, 0x061B, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x061F,
-	0x06C1, 0x0621, 0x0622, 0x0623, 0x0624, 0x0625, 0x0626, 0x0627,
-	0x0628, 0x0629, 0x062A, 0x062B, 0x062C, 0x062D, 0x062E, 0x062F,
-	0x0630, 0x0631, 0x0632, 0x0633, 0x0634, 0x0635, 0x0636, 0x00D7,
-	0x0637, 0x0638, 0x0639, 0x063A, 0x0640, 0x0640, 0x0642, 0x0643,
-	0x00E0, 0x0644, 0x00E2, 0x0645, 0x0646, 0x0647, 0x0648, 0x00E7,
-	0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x0649, 0x064A, 0x00EE, 0x00EF,
-	0x064B, 0x064C, 0x064D, 0x064E, 0x00F4, 0x064F, 0x0650, 0x00F7,
-	0x0651, 0x00F9, 0x0652, 0x00FB, 0x00FC, 0x200E, 0x200F, 0x06D2
-};
-
-#elif _CODE_PAGE == 1257
-#define _TBLDEF 1
-static
-const WCHAR Tbl[] = {	/*  CP1257(0x80-0xFF) to Unicode conversion table */
-	0x20AC, 0x0000, 0x201A, 0x0000, 0x201E, 0x2026, 0x2020, 0x2021,
-	0x0000, 0x2030, 0x0000, 0x2039, 0x0000, 0x00A8, 0x02C7, 0x00B8,
-	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
-	0x0000, 0x2122, 0x0000, 0x203A, 0x0000, 0x00AF, 0x02DB, 0x0000,
-	0x00A0, 0x0000, 0x00A2, 0x00A3, 0x00A4, 0x0000, 0x00A6, 0x00A7,
-	0x00D8, 0x00A9, 0x0156, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
-	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
-	0x00B8, 0x00B9, 0x0157, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00E6,
-	0x0104, 0x012E, 0x0100, 0x0106, 0x00C4, 0x00C5, 0x0118, 0x0112,
-	0x010C, 0x00C9, 0x0179, 0x0116, 0x0122, 0x0136, 0x012A, 0x013B,
-	0x0160, 0x0143, 0x0145, 0x00D3, 0x014C, 0x00D5, 0x00D6, 0x00D7,
-	0x0172, 0x0141, 0x015A, 0x016A, 0x00DC, 0x017B, 0x017D, 0x00DF,
-	0x0105, 0x012F, 0x0101, 0x0107, 0x00E4, 0x00E5, 0x0119, 0x0113,
-	0x010D, 0x00E9, 0x017A, 0x0117, 0x0123, 0x0137, 0x012B, 0x013C,
-	0x0161, 0x0144, 0x0146, 0x00F3, 0x014D, 0x00F5, 0x00F6, 0x00F7,
-	0x0173, 0x014E, 0x015B, 0x016B, 0x00FC, 0x017C, 0x017E, 0x02D9
-};
-
-#elif _CODE_PAGE == 1258
-#define _TBLDEF 1
-static
-const WCHAR Tbl[] = {	/*  CP1258(0x80-0xFF) to Unicode conversion table */
-	0x20AC, 0x0000, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,
-	0x02C6, 0x2030, 0x0000, 0x2039, 0x0152, 0x0000, 0x0000, 0x0000,
-	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
-	0x02DC, 0x2122, 0x0000, 0x203A, 0x0153, 0x0000, 0x0000, 0x0178,
-	0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7,
-	0x00A8, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
-	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
-	0x00B8, 0x00B9, 0x00BA, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF,
-	0x00C0, 0x00C1, 0x00C2, 0x0102, 0x00C4, 0x00C5, 0x00C6, 0x00C7,
-	0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x0300, 0x00CD, 0x00CE, 0x00CF,
-	0x0110, 0x00D1, 0x0309, 0x00D3, 0x00D4, 0x01A0, 0x00D6, 0x00D7,
-	0x00D8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x01AF, 0x0303, 0x00DF,
-	0x00E0, 0x00E1, 0x00E2, 0x0103, 0x00E4, 0x00E5, 0x00E6, 0x00E7,
-	0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x0301, 0x00ED, 0x00EE, 0x00EF,
-	0x0111, 0x00F1, 0x0323, 0x00F3, 0x00F4, 0x01A1, 0x00F6, 0x00F7,
-	0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x01B0, 0x20AB, 0x00FF
-};
-
 #endif
 
 
 #if !_TBLDEF || !_USE_LFN
-#error This file is not needed in current configuration. Remove from the project.
+#error This file is not needed at current configuration. Remove from the project.
 #endif
 
 
+
+
 WCHAR ff_convert (	/* Converted character, Returns zero on error */
 	WCHAR	chr,	/* Character code to be converted */
-	UINT	dir		/* 0: Unicode to OEMCP, 1: OEMCP to Unicode */
+	UINT	dir		/* 0: Unicode to OEM code, 1: OEM code to Unicode */
 )
 {
 	WCHAR c;
@@ -510,10 +284,10 @@
 		c = chr;
 
 	} else {
-		if (dir) {		/* OEMCP to Unicode */
+		if (dir) {		/* OEM code to Unicode */
 			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 
-		} else {		/* Unicode to OEMCP */
+		} else {		/* Unicode to OEM code */
 			for (c = 0; c < 0x80; c++) {
 				if (chr == Tbl[c]) break;
 			}
@@ -525,16 +299,90 @@
 }
 
 
-WCHAR ff_wtoupper (	/* Upper converted character */
-	WCHAR chr		/* Input character */
+
+WCHAR ff_wtoupper (	/* Returns upper converted character */
+	WCHAR chr		/* Unicode character to be upper converted (BMP only) */
 )
 {
-	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
-	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
-	int i;
+	/* Compressed upper conversion table */
+	static const WCHAR cvt1[] = {	/* U+0000 - U+0FFF */
+		/* Basic Latin */
+		0x0061,0x031A,
+		/* Latin-1 Supplement */
+		0x00E0,0x0317,  0x00F8,0x0307,  0x00FF,0x0001,0x0178,
+		/* Latin Extended-A */
+		0x0100,0x0130,  0x0132,0x0106,  0x0139,0x0110,  0x014A,0x012E,  0x0179,0x0106,
+		/* Latin Extended-B */
+		0x0180,0x004D,0x0243,0x0181,0x0182,0x0182,0x0184,0x0184,0x0186,0x0187,0x0187,0x0189,0x018A,0x018B,0x018B,0x018D,0x018E,0x018F,0x0190,0x0191,0x0191,0x0193,0x0194,0x01F6,0x0196,0x0197,0x0198,0x0198,0x023D,0x019B,0x019C,0x019D,0x0220,0x019F,0x01A0,0x01A0,0x01A2,0x01A2,0x01A4,0x01A4,0x01A6,0x01A7,0x01A7,0x01A9,0x01AA,0x01AB,0x01AC,0x01AC,0x01AE,0x01AF,0x01AF,0x01B1,0x01B2,0x01B3,0x01B3,0x01B5,0x01B5,0x01B7,0x01B8,0x01B8,0x01BA,0x01BB,0x01BC,0x01BC,0x01BE,0x01F7,0x01C0,0x01C1,0x01C2,0x01C3,0x01C4,0x01C5,0x01C4,0x01C7,0x01C8,0x01C7,0x01CA,0x01CB,0x01CA,
+		0x01CD,0x0110,  0x01DD,0x0001,0x018E,  0x01DE,0x0112,  0x01F3,0x0003,0x01F1,0x01F4,0x01F4,  0x01F8,0x0128,
+		0x0222,0x0112,  0x023A,0x0009,0x2C65,0x023B,0x023B,0x023D,0x2C66,0x023F,0x0240,0x0241,0x0241,  0x0246,0x010A,
+		/* IPA Extensions */
+		0x0253,0x0040,0x0181,0x0186,0x0255,0x0189,0x018A,0x0258,0x018F,0x025A,0x0190,0x025C,0x025D,0x025E,0x025F,0x0193,0x0261,0x0262,0x0194,0x0264,0x0265,0x0266,0x0267,0x0197,0x0196,0x026A,0x2C62,0x026C,0x026D,0x026E,0x019C,0x0270,0x0271,0x019D,0x0273,0x0274,0x019F,0x0276,0x0277,0x0278,0x0279,0x027A,0x027B,0x027C,0x2C64,0x027E,0x027F,0x01A6,0x0281,0x0282,0x01A9,0x0284,0x0285,0x0286,0x0287,0x01AE,0x0244,0x01B1,0x01B2,0x0245,0x028D,0x028E,0x028F,0x0290,0x0291,0x01B7,
+		/* Greek, Coptic */
+		0x037B,0x0003,0x03FD,0x03FE,0x03FF,  0x03AC,0x0004,0x0386,0x0388,0x0389,0x038A,  0x03B1,0x0311,
+		0x03C2,0x0002,0x03A3,0x03A3,  0x03C4,0x0308,  0x03CC,0x0003,0x038C,0x038E,0x038F,  0x03D8,0x0118,
+		0x03F2,0x000A,0x03F9,0x03F3,0x03F4,0x03F5,0x03F6,0x03F7,0x03F7,0x03F9,0x03FA,0x03FA,
+		/* Cyrillic */
+		0x0430,0x0320,  0x0450,0x0710,  0x0460,0x0122,  0x048A,0x0136,  0x04C1,0x010E,  0x04CF,0x0001,0x04C0,  0x04D0,0x0144,
+		/* Armenian */
+		0x0561,0x0426,
 
+		0x0000
+	};
+	static const WCHAR cvt2[] = {	/* U+1000 - U+FFFF */
+		/* Phonetic Extensions */
+		0x1D7D,0x0001,0x2C63,
+		/* Latin Extended Additional */
+		0x1E00,0x0196,  0x1EA0,0x015A,
+		/* Greek Extended */
+		0x1F00,0x0608,  0x1F10,0x0606,  0x1F20,0x0608,  0x1F30,0x0608,  0x1F40,0x0606,
+		0x1F51,0x0007,0x1F59,0x1F52,0x1F5B,0x1F54,0x1F5D,0x1F56,0x1F5F,  0x1F60,0x0608,
+		0x1F70,0x000E,0x1FBA,0x1FBB,0x1FC8,0x1FC9,0x1FCA,0x1FCB,0x1FDA,0x1FDB,0x1FF8,0x1FF9,0x1FEA,0x1FEB,0x1FFA,0x1FFB,
+		0x1F80,0x0608,  0x1F90,0x0608,  0x1FA0,0x0608,  0x1FB0,0x0004,0x1FB8,0x1FB9,0x1FB2,0x1FBC,
+		0x1FCC,0x0001,0x1FC3,  0x1FD0,0x0602,  0x1FE0,0x0602,  0x1FE5,0x0001,0x1FEC,  0x1FF2,0x0001,0x1FFC,
+		/* Letterlike Symbols */
+		0x214E,0x0001,0x2132,
+		/* Number forms */
+		0x2170,0x0210,  0x2184,0x0001,0x2183,
+		/* Enclosed Alphanumerics */
+		0x24D0,0x051A,  0x2C30,0x042F,
+		/* Latin Extended-C */
+		0x2C60,0x0102,  0x2C67,0x0106, 0x2C75,0x0102,
+		/* Coptic */
+		0x2C80,0x0164,
+		/* Georgian Supplement */
+		0x2D00,0x0826,
+		/* Full-width */
+		0xFF41,0x031A,
 
-	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
+		0x0000
+	};
+	const WCHAR *p;
+	WCHAR bc, nc, cmd;
 
-	return tbl_lower[i] ? tbl_upper[i] : chr;
+
+	p = chr < 0x1000 ? cvt1 : cvt2;
+	for (;;) {
+		bc = *p++;								/* Get block base */
+		if (!bc || chr < bc) break;
+		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
+		if (chr < bc + nc) {	/* In the block? */
+			switch (cmd) {
+			case 0:	chr = p[chr - bc]; break;		/* Table conversion */
+			case 1:	chr -= (chr - bc) & 1; break;	/* Case pairs */
+			case 2: chr -= 16; break;				/* Shift -16 */
+			case 3:	chr -= 32; break;				/* Shift -32 */
+			case 4:	chr -= 48; break;				/* Shift -48 */
+			case 5:	chr -= 26; break;				/* Shift -26 */
+			case 6:	chr += 8; break;				/* Shift +8 */
+			case 7: chr -= 80; break;				/* Shift -80 */
+			case 8:	chr -= 0x1C60; break;			/* Shift -0x1C60 */
+			}
+			break;
+		}
+		if (!cmd) p += nc;
+	}
+
+	return chr;
 }
+
Index: kernel/Patch.c
===================================================================
--- kernel/Patch.c	(revision 334)
+++ kernel/Patch.c	(working copy)
@@ -3,7 +3,7 @@
 Nintendont (Kernel) - Playing Gamecubes in Wii mode on a Wii U
 
 Copyright (C) 2013  crediar
-Copyright (C) 2014  FIX94
+Copyright (C) 2014 - 2016 FIX94
 
 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
@@ -27,6 +27,7 @@
 #include "PatchCodes.h"
 #include "PatchWidescreen.h"
 #include "PatchTimers.h"
+#include "TRI.h"
 #include "Config.h"
 #include "global.h"
 #include "patches.c"
@@ -34,11 +35,12 @@
 #include "ISO.h"
 #include "SI.h"
 #include "EXI.h"
-#include "GCAM.h"
+#include "codehandler.h"
 //#define DEBUG_DSP  // Very slow!! Replace with raw dumps?
 
-#define GAME_ID		(read32(0))
-#define TITLE_ID	(GAME_ID >> 8)
+u32 GAME_ID	= 0;
+u16 GAME_ID6 = 0;
+u32 TITLE_ID = 0;
 
 #define PATCH_OFFSET_START (0x3000 - (sizeof(u32) * 3))
 #define PATCH_OFFSET_ENTRY PATCH_OFFSET_START - FakeEntryLoad_size
@@ -46,8 +48,8 @@
 vu32 Region = 0;
 vu32 useipl = 0, useipltri = 0;
 vu32 DisableSIPatch = 0, DisableEXIPatch = 0;
-vu32 TRIGame = TRI_NONE;
-extern u32 SystemRegion;
+extern vu32 TRIGame;
+
 #define PRS_DOL     0x131C0000
 #define PRS_EXTRACT 0x131C0020
 
@@ -79,14 +81,25 @@
 vu32 TRI_BackupAvailable = 0;
 vu32 GameEntry = 0, FirstLine = 0;
 u32 AppLoaderSize = 0;
+u32 MAT2patched = 0;
 
 static char cheatPath[255];
 extern u32 prs_decompress(void* source,void* dest);
 extern u32 prs_decompress_size(void* source);
 
+static FuncPattern curFunc;
+
+#ifndef DEBUG_PATCH
+#define dbgprintf(...)
+#else
 extern int dbgprintf( const char *fmt, ...);
+#endif
 
-const unsigned char DSPHashes[][0x14] =
+extern u32 UseReadLimit;
+extern u32 RealDiscCMD;
+u32 IsN64Emu = 0;
+
+static const unsigned char DSPHashes[][0x14] =
 {
 	{
 		0xC9, 0x7D, 0x1E, 0xD0, 0x71, 0x90, 0x47, 0x3F, 0x6A, 0x66, 0x42, 0xB2, 0x7E, 0x4A, 0xDB, 0xCD, 0xB6, 0xF8, 0x8E, 0xC3,			//	0 Dolphin=0x86840740=Zelda WW
@@ -136,15 +149,18 @@
 	{
 		0x9F, 0x3C, 0x9F, 0x9E, 0x05, 0xC7, 0xD5, 0x0B, 0x38, 0x49, 0x2F, 0x2C, 0x68, 0x75, 0x30, 0xFD, 0xE8, 0x6F, 0x9B, 0xCA,			//	15 Dolphin=0x3389a79e=Metroid Prime Trilogy Wii (Needed?)
 	},
+	{
+		0x13, 0x07, 0xEF, 0xAF, 0x7E, 0x66, 0x96, 0x60, 0xCE, 0x00, 0x2B, 0x89, 0x6E, 0x7E, 0xD4, 0xE7, 0xD8, 0x0F, 0x11, 0xF7,			//	16 Dolphin=0xdf059f68=Pikmin US Demo (Unknown to Dolphin)
+	},
 };
 
-const unsigned char DSPPattern[][0x10] =
+static const unsigned char DSPPattern[][0x10] =
 {
 	{
 		0x02, 0x9F, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x02, 0xFF, 0x00, 0x00, 0x02, 0xFF, 0x00, 0x00,		//	0 Hash 12, 1, 0, 5, 8
 	},
 	{
-		0x02, 0x9F, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x02, 0xFF, 0x00, 0x00, 0x02, 0xFF, 0x00, 0x00,		//	1 Hash 14, 13, 11, 10
+		0x02, 0x9F, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x02, 0xFF, 0x00, 0x00, 0x02, 0xFF, 0x00, 0x00,		//	1 Hash 14, 13, 11, 10, 16
 	},
 	{
 		0x00, 0x00, 0x00, 0x00, 0x02, 0x9F, 0x0C, 0x10, 0x02, 0x9F, 0x0C, 0x1F, 0x02, 0x9F, 0x0C, 0x3B,		//	2 Hash 2
@@ -173,7 +189,7 @@
 	u32 SHA1;
 } DspMatch;
 
-const DspMatch DspMatches[] =
+static const DspMatch DspMatches[] =
 {
 	// Order Patterns together by increasing Length
 	// Length, Pattern,   SHA1
@@ -186,6 +202,7 @@
 	{ 0x00001760,    1,     13 },
 	{ 0x000017E0,    1,     11 },
 	{ 0x00001A00,    1,     10 },
+	{ 0x00001B80,    1,     16 },
 	{ 0x000019E0,    2,      2 },
 	{ 0x00001EC0,    3,      3 },
 	{ 0x00001F20,    4,      4 },
@@ -195,7 +212,7 @@
 };
 
 #define AX_DSP_NO_DUP3 (0xFFFF)
-void PatchAX_Dsp(u32 ptr, u32 Dup1, u32 Dup2, u32 Dup3, u32 Dup2Offset)
+static void PatchAX_Dsp(u32 ptr, u32 Dup1, u32 Dup2, u32 Dup3, u32 Dup2Offset)
 {
 	static const u32 MoveLength = 0x22;
 	static const u32 CopyLength = 0x12;
@@ -273,7 +290,7 @@
 	return;
 }
 
-void PatchZelda_Dsp(u32 DspAddress, u32 PatchAddr, u32 OrigAddress, bool Split, bool KeepOrig)
+static void PatchZelda_Dsp(u32 DspAddress, u32 PatchAddr, u32 OrigAddress, bool Split, bool KeepOrig)
 {
 	u32 Tmp = R32(DspAddress + (OrigAddress + 0) * 2); // original instructions at OrigAddress
 	if (Split)
@@ -296,7 +313,7 @@
 	W32(DspAddress + (PatchAddr + 4) * 2, Tmp);
 	W32(DspAddress + (OrigAddress + 0) * 2, 0x02BF0000 | PatchAddr);  // call PatchAddr
 }
-void PatchZeldaInPlace_Dsp(u32 DspAddress, u32 OrigAddress)
+static void PatchZeldaInPlace_Dsp(u32 DspAddress, u32 OrigAddress)
 {
 	W32(DspAddress + (OrigAddress + 0) * 2, 0x009AFFFF); // lri $AX0.H, #0xffff
 	W32(DspAddress + (OrigAddress + 2) * 2, 0x2AD62AD7); // srs @ACEAH, $AX0.H/srs @ACEAL, $AX0.H
@@ -303,7 +320,7 @@
 	W32(DspAddress + (OrigAddress + 4) * 2, 0x02601000); // ori $AC0.M, 0x1000
 }
 
-void DoDSPPatch( char *ptr, u32 Version )
+static void DoDSPPatch( char *ptr, u32 Version )
 {
 	switch (Version)
 	{
@@ -389,6 +406,12 @@
 		{
 			PatchAX_Dsp( (u32)ptr, 0x69E, 0x753, AX_DSP_NO_DUP3, 0xA4 );
 		} break;
+		case 16:	// Pikmin US Demo (Unknown to Dolphin)
+		{
+			// DB8 - unused
+			PatchZelda_Dsp( (u32)ptr, 0x0DB8, 0x00CD, false, false );
+			PatchZelda_Dsp( (u32)ptr, 0x0DB8, 0x0118, false, false );  // same orig instructions
+		} break;
 		default:
 		{
 		} break;
@@ -399,10 +422,8 @@
 {
 	if( read32(Offset) != CurrentValue )
 	{
-		#ifdef DEBUG_PATCH
 		//if( ShowAssert)
 			//dbgprintf("AssertFailed: Offset:%08X is:%08X should:%08X\r\n", Offset, read32(Offset), CurrentValue );
-		#endif
 		return false;
 	}
 
@@ -423,16 +444,19 @@
 	newval|= 0x48000001;
 	*(vu32*)src = newval;
 }
+
 /*
 	This area gets used by IOS, this workaround fixes that problem.
 */
-u32 Pach31A0Backup = 0;
-void Patch31A0( void )
+u32 Patch31A0Backup = 0;
+static void Patch31A0( void )
 {
-	if(Pach31A0Backup == 0)
+	if(Patch31A0Backup == 0)
 		return;
 	u32 PatchOffset = PATCH_OFFSET_START;
-	if(DOLMinOff < 0x31A0)
+	//From Russia with Love stores data here not code so
+	//do NOT add a jump in there, it would break the game
+	if(TITLE_ID != 0x474C5A && DOLMinOff < 0x31A0)
 	{
 		//backup data
 		u32 CurBuf = read32(0x319C);
@@ -443,9 +467,7 @@
 			u32 Orig = CurBuf;
 			u32 NewAddr = (((s16)(CurBuf & 0xFFFC)) + 0x319C - PatchOffset);
 			CurBuf = (CurBuf & 0xFFFF0003) | NewAddr;
-#ifdef DEBUG_PATCH
 			dbgprintf("319C:Changed 0x%08X to 0x%08X\r\n", Orig, CurBuf);
-#endif
 		}
 		else if ((CurBuf & 0xFC000002) == 0x48000000)
 		{
@@ -454,23 +476,19 @@
 			if(BaseAddr & 0x2000000) BaseAddr |= 0xFC000000;
 			u32 NewAddr = (((s32)BaseAddr) + 0x319C - PatchOffset) & 0x3FFFFFC;
 			CurBuf = (CurBuf & 0xFC000003) | NewAddr;
-#ifdef DEBUG_PATCH
 			dbgprintf("319C:Changed 0x%08X to 0x%08X\r\n", Orig, CurBuf);
-#endif
 		}
 		write32(PatchOffset, CurBuf);
 		PatchOffset += 4;
 	}
 
-	u32 CurBuf = Pach31A0Backup;
+	u32 CurBuf = Patch31A0Backup;
 	if ((CurBuf & 0xFC000002) == 0x40000000)
 	{
 		u32 Orig = CurBuf;
 		u32 NewAddr = (((s16)(CurBuf & 0xFFFC)) + 0x31A0 - PatchOffset);
 		CurBuf = (CurBuf & 0xFFFF0003) | NewAddr;
-#ifdef DEBUG_PATCH
 		dbgprintf("31A0:Changed 0x%08X to 0x%08X\r\n", Orig, CurBuf);
-#endif
 	}
 	else if ((CurBuf & 0xFC000002) == 0x48000000)
 	{
@@ -479,9 +497,7 @@
 		if(BaseAddr & 0x2000000) BaseAddr |= 0xFC000000;
 		u32 NewAddr = (((s32)BaseAddr) + 0x31A0 - PatchOffset) & 0x3FFFFFC;
 		CurBuf = (CurBuf & 0xFC000003) | NewAddr;
-#ifdef DEBUG_PATCH
 		dbgprintf("31A0:Changed 0x%08X to 0x%08X\r\n", Orig, CurBuf);
-#endif
 	}
 	write32(PatchOffset, CurBuf);
 	if(P2C(GameEntry) == 0x31A0) //terrible case
@@ -733,32 +749,24 @@
 			LISReg = 32;
 	}
 
-#ifdef DEBUG_PATCH
 	dbgprintf("Patch:[SI] applied %u times\r\n", SIPatched);
 	if( DisableEXIPatch ) dbgprintf("Patch:[EXI] applied %u times\r\n", EXIPatched);
 	dbgprintf("Patch:[AI] applied %u times\r\n", AIPatched);
 	dbgprintf("Patch:[DI] applied %u times\r\n", DIPatched);
-	#endif
 }
 
-u32 piReg = 0;
-bool PatchProcessorInterface( u32 BufAt0, u32 Buffer )
+static u32 piReg = 0;
+static inline bool PatchProcessorInterface( u32 BufAt0, u32 Buffer )
 {
 	/* Pokemon XD - PI_FIFO_WP Direct */
 	if(BufAt0 == 0x80033014 && (read32(Buffer+12) & 0xFC00FFFF) == 0x540037FE) //extrwi rZ, rY, 1,5
 	{
 		// Extract WRAPPED bit
-		#ifdef DEBUG_PATCH
 		u32 op = read32(Buffer+12);
-		#else
-		read32(Buffer+12);
-		#endif
 		W16(Buffer+14, 0x1FFE);
-		#ifdef DEBUG_PATCH
 		u32 src = (op >> 21) & 0x1F; //rY
 		u32 dst = (op >> 16) & 0x1F; //rZ
 		dbgprintf( "Patch:[PI_FIFO_WP PKM] extrwi r%i,r%i,1,2 (0x%08X)\r\n", dst, src, Buffer+12 );
-		#endif
 		return true;
 	}
 	/* Dolphin SDK - GX __piReg */
@@ -789,10 +797,8 @@
 					{
 						// Keep WRAPPED bit
 						W16(piRegBuf+lPtr+2, 0x00C2);
-						#ifdef DEBUG_PATCH
 						u32 lDst = (op >> 16) & 0x1F; //rZ
 						dbgprintf( "Patch:[PI_FIFO_WP] rlwinm r%i,r%i,0,3,1 (0x%08X)\r\n", lDst, lSrc, piRegBuf+lPtr );
-						#endif
 						return true;
 					}
 				}
@@ -803,10 +809,8 @@
 					{
 						// Extract WRAPPED bit
 						W16(piRegBuf+lPtr+2, 0x1FFE);
-						#ifdef DEBUG_PATCH
 						u32 lDst = (op >> 16) & 0x1F; //rZ
 						dbgprintf( "Patch:[PI_FIFO_WP] extrwi r%i,r%i,1,2 (0x%08X)\r\n", lDst, lSrc, piRegBuf+lPtr );
-						#endif
 						return true;
 					}
 				}
@@ -829,10 +833,8 @@
 					{
 						// Keep WRAPPED bit
 						W16(piRegBuf+sPtr+2, 0x00C2);
-						#ifdef DEBUG_PATCH
 						sSrc = (read32(piRegBuf+sPtr) >> 21) & 0x1F;
 						dbgprintf( "Patch:[PI_FIFO_WP] rlwinm r%i,r%i,0,3,1 (0x%08X)\r\n", sReg, sSrc, piRegBuf+sPtr );
-						#endif
 						return true;
 					}
 				}
@@ -889,13 +891,88 @@
 	}
 }
 
-bool GameNeedsHook()
+static bool IsPokemonDemo()
 {
+	if( (DOLSize == 4101476 && DOLMinOff == 0x3100 && DOLMaxOff == 0x4CCFE0 &&
+		read32(0x27EA58) == 0x504F4BE9 && read32(0x27EA5C) == 0x4D4F4E20) || //Colosseum EUR
+		(DOLSize == 4336100 && DOLMinOff == 0x3100 && DOLMaxOff == 0x4F14C0 &&
+		read32(0x2F89DC) == 0x504F4B65 && read32(0x2F89E0) == 0x4D4F4E20) || //Pokemon XD USA
+		(DOLSize == 4548516 && DOLMinOff == 0x3100 && DOLMaxOff == 0x520D20 &&
+		read32(0x2F3AE4) == 0x504F4B65 && read32(0x2F3AE8) == 0x4D4F4E20) )  //Pokemon XD EUR
+	{
+		dbgprintf("Patch:Detected Pokemon Demo, using memset patches\r\n");
+		return true;
+	}
+	return false;
+}
+
+static bool DemoNeedsPaperMarioDMA()
+{
+	if( (DOLSize == 3983396 && DOLMinOff == 0x3100 && DOLMaxOff == 0x41E4E0 &&
+		read32(0x2BB458) == 0x50415045 && read32(0x2BB45C) == 0x52435241) || //Paper Mario RPG JAP
+		(DOLSize == 3984836 && DOLMinOff == 0x3100 && DOLMaxOff == 0x41EA80 &&
+		read32(0x2BB818) == 0x50415045 && read32(0x2BB81C) == 0x52435241) || //Paper Mario 2 USA
+		(DOLSize == 4019876 && DOLMinOff == 0x3100 && DOLMaxOff == 0x429140 &&
+		read32(0x2BF4C0) == 0x50415045 && read32(0x2BF4C4) == 0x52435241) || //Paper Mario TTYD USA
+		(DOLSize == 4068836 && DOLMinOff == 0x3100 && DOLMaxOff == 0x4359C0 &&
+		read32(0x2CAF00) == 0x50415045 && read32(0x2CAF04) == 0x52435241) )  //Paper Mario TTYD EUR
+	{
+		dbgprintf("Patch:Known Problematic Demo, using ARStartDMA_PM\r\n");
+		return true;
+	}
+	return false;
+}
+
+static bool DemoNeedsPostRequest()
+{
+	if( (DOLSize == 4107972 && DOLMinOff == 0x3100 && DOLMaxOff == 0x412760 &&
+		read32(0x3768E0) == 0x53756E73 && read32(0x3768E4) == 0x68696E65) || //Sunshine JAP
+		(DOLSize == 4123684 && DOLMinOff == 0x3100 && DOLMaxOff == 0x416460 &&
+		read32(0x3A61AC) == 0x53756E73 && read32(0x3A61B0) == 0x68696E65) || //Sunshine EUR
+		(DOLSize == 4124068 && DOLMinOff == 0x3100 && DOLMaxOff == 0x4165E0 &&
+		read32(0x3A632C) == 0x53756E73 && read32(0x3A6330) == 0x68696E65) || //Sunshine USA
+		(DOLSize == 3731268 && DOLMinOff == 0x3100 && DOLMaxOff == 0x4CD360 &&
+		read32(0x377900) == 0x4D616E73 && read32(0x377904) == 0x696F6E00) || //Luigis Mansion EUR
+		(DOLSize == 3808868 && DOLMinOff == 0x3100 && DOLMaxOff == 0x4DFE80 &&
+		read32(0x38AAD0) == 0x4D616E73 && read32(0x38AAD4) == 0x696F6E00) || //Luigis Mansion USA
+		(DOLSize == 3102820 && DOLMinOff == 0x3100 && DOLMaxOff == 0x3EC180 &&
+		read32(0x2AA53C) == 0x50696B6D && read32(0x2AA540) == 0x696E2064) || //Pikmin EUR
+		(DOLSize == 3110372 && DOLMinOff == 0x3100 && DOLMaxOff == 0x3EE780 &&
+		read32(0x2AC2BC) == 0x50696B6D && read32(0x2AC2C0) == 0x696E2064) )  //Pikmin USA
+	{
+		dbgprintf("Patch:Known Problematic Demo, using ARQPostRequest\r\n");
+		return true;
+	}
+	return false;
+}
+
+static bool DemoNeedsHookPatch()
+{
+	if( (DOLSize == 2044804 && DOLMinOff == 0x3100 && DOLMaxOff == 0x2EE600 &&
+		read32(0x1A9CA8) == 0x4A4F4520 && read32(0x1A9CAC) == 0x4D555354) || //Viewtiful Joe USA
+		(DOLSize == 2044804 && DOLMinOff == 0x3100 && DOLMaxOff == 0x2EE600 &&
+		read32(0x1A9CE8) == 0x4A4F4520 && read32(0x1A9CEC) == 0x4D555354) || //Viewtiful Joe JAP
+		(DOLSize == 2556708 && DOLMinOff == 0x3100 && DOLMaxOff == 0x3732A0 &&
+		read32(0x20A1D0) == 0x4A4F4520 && read32(0x20A1D4) == 0x4D555354) || //Viewtiful Joe EUR
+		(DOLSize == 2176260 && DOLMinOff == 0x3100 && DOLMaxOff == 0x2D99A0 &&
+		read32(0x1CF268) == 0x62696F68 && read32(0x1CF26C) == 0x617A6172) || //Biohazard 4 JAP
+		(DOLSize == 2177508 && DOLMinOff == 0x3100 && DOLMaxOff == 0x2FDCE0 &&
+		read32(0x1D2A00) == 0x62696F68 && read32(0x1D2A04) == 0x617A6172) )  //Resident Evil 4 USA
+	{
+		dbgprintf("Patch:Known Problematic Demo, using ARStartDMA_Hook\r\n");
+		return true;
+	}
+	return false;
+}
+
+static bool GameNeedsHook()
+{
 	if( (TITLE_ID) == 0x473258 )	// Sonic Gems Collection
 		return (DOLSize != 1440100 && DOLSize != 1439812); //Everything except Sonic Fighters
 
 	return( (TITLE_ID) == 0x474234 ||	// Burnout 2
 			(TITLE_ID) == 0x47564A ||	// Viewtiful Joe
+			(TITLE_ID) == 0x474145 ||	// Doubutsu no Mori e+
 			(TITLE_ID) == 0x474146 ||	// Animal Crossing
 			(TITLE_ID) == 0x475852 ||	// Mega Man X Command Mission
 			(TITLE_ID) == 0x474832 ||	// NFS: HP2
@@ -902,7 +979,6 @@
 			(TITLE_ID) == 0x474156 ||	// Avatar Last Airbender
 			(TITLE_ID) == 0x47484E ||	// Hunter the Reckoning
 			(TITLE_ID) == 0x473442 ||	// Resident Evil 4
-			(TITLE_ID) == 0x503442 ||	// Resident Evil 4 (Demo)
 			(TITLE_ID) == 0x474856 ||	// Disneys Hide and Sneak
 			(TITLE_ID) == 0x474353 ||	// Street Racing Syndicate
 			(TITLE_ID) == 0x474241 ||	// NBA 2k2
@@ -912,10 +988,11 @@
 			(TITLE_ID) == 0x47504C ||	// Piglet's Big Game
 			(TITLE_ID) == 0x475951 ||	// Mario Superstar Baseball
 			(TITLE_ID) == 0x47534F ||	// Sonic Mega Collection
-			(GAME_ID) == 0x4747504A);	// SD Gundam Gashapon Wars
+			(GAME_ID) == 0x4747504A ||	// SD Gundam Gashapon Wars
+			DemoNeedsHookPatch() );
 }
 
-bool PADSwitchRequired()
+static inline bool PADSwitchRequired()
 {
 	return( (TITLE_ID) == 0x47434F ||	// Call of Duty
 			(TITLE_ID) == 0x475449 ||	// Tiger Woods PGA Tour 2003
@@ -922,7 +999,7 @@
 			(TITLE_ID) == 0x475734 );	// Tiger Woods PGA Tour 2004
 }
 
-bool PADForceConnected()
+static inline bool PADForceConnected()
 {
 	return( (TITLE_ID) == 0x474C5A ); // 007 From Russia With Love
 }
@@ -933,7 +1010,7 @@
 
 	memset32( FunctionPattern, 0, sizeof(FuncPattern) );
 
-	for( i = 0; i < Length; i+=4 )
+	for( i = 0; i <= Length; i+=4 )
 	{
 		u32 word = *(u32*)(Data + i);
 
@@ -990,7 +1067,8 @@
 	//dbgprintf("New Checksum: %04X %04X\r\n", *c1, *c2 );
 }
 
-char *getVidStr(u32 in)
+#ifdef DEBUG_PATCH
+static const char *getVidStr(u32 in)
 {
 	switch(in)
 	{
@@ -1009,7 +1087,6 @@
 	}
 }
 
-#ifdef DEBUG_PATCH
 static inline void printvidpatch(u32 ori_v, u32 new_v, u32 addr)
 {
 	dbgprintf("Patch:Replaced %s with %s (0x%08X)\r\n", getVidStr(ori_v), getVidStr(new_v), addr );
@@ -1024,7 +1101,7 @@
 #define printpatchfound(...)
 #endif
 
-int GotoFuncStart(int i, u32 Buffer)
+static int GotoFuncStart(int i, u32 Buffer)
 {
 	while( read32(Buffer + i - 4) != 0x4E800020 )
 		i -= 4;
@@ -1031,7 +1108,7 @@
 	return i;
 }
 
-int GotoFuncEnd(int i, u32 Buffer)
+static int GotoFuncEnd(int i, u32 Buffer)
 {
 	do {
 		i += 4; //known function, skip over it
@@ -1038,44 +1115,8 @@
 	} while( read32(Buffer + i) != 0x4E800020 );
 	return i;
 }
-void *OurBase = (void*)0x13002780;
-void TRIWriteSettings(char *name, void *GameBase, u32 size)
-{
-	sync_before_read_align32(GameBase, size);
-	sync_before_read_align32(OurBase, size);
-	if((memcmp(OurBase, GameBase, size) != 0) && (memcmp(GameBase, "SB", 2) == 0))
-	{
-		dbgprintf("TRI:Writing Settings\r\n");
-		memcpy(OurBase, GameBase, size);
-		FIL backup;
-		if(f_open_char(&backup, name, FA_WRITE | FA_CREATE_ALWAYS) == FR_OK)
-		{
-			u32 wrote;
-			f_write(&backup, OurBase, size, &wrote);
-			f_close(&backup);
-		}
-		sync_after_write_align32(OurBase, size);
-		TRI_BackupAvailable = 1;
-	}
-}
-void TRIReadSettings(char *name, u32 size)
-{
-	FIL backup;
-	if (f_open_char(&backup, name, FA_OPEN_EXISTING | FA_READ) == FR_OK)
-	{
-		if(backup.fsize == size)
-		{
-			dbgprintf("TRI:Reading Settings\r\n");
-			u32 read;
-			f_read(&backup, OurBase, size, &read);
-			sync_after_write_align32(OurBase, size);
-			TRI_BackupAvailable = 1;
-		}
-		f_close(&backup);
-	}
-}
 
-bool fileExist( char *path )
+static bool fileExist( char *path )
 {
 	FIL fd;
 	if( f_open_char( &fd, path, FA_OPEN_EXISTING|FA_READ ) == FR_OK )
@@ -1099,27 +1140,23 @@
 	u32 value = 0;
 
 	// PSO 1&2 / III
+	u32 isPSO = 0;
 	if (((TITLE_ID) == 0x47504F) || ((TITLE_ID) == 0x475053))
 	{
+		isPSO = 1;
 		if((PSOHack & PSO_STATE_SWITCH) && DiscOffset > 0)
 		{
-			#ifdef DEBUG_PATCH
 			dbgprintf("PSO:psov3.dol\r\n");
-			#endif
 			PSOHack = PSO_STATE_LOAD | PSO_STATE_NOENTRY;
 		}
 		if(Length == 0x318E0 && read32((u32)Buffer+0x318B0) == 0x4CBEBC20)
 		{
-			#ifdef DEBUG_PATCH
 			dbgprintf("PSO:switcher.dol\r\n");
-			#endif
 			PSOHack = PSO_STATE_LOAD | PSO_STATE_SWITCH;
 		}
 		else if(Length == 0x1B8A0 && read32((u32)Buffer+0x12E0C) == 0x7FA4E378)
 		{
-			#ifdef DEBUG_PATCH
 			dbgprintf("PSO:switcherD.dol\r\n");
-			#endif
 			PSOHack = PSO_STATE_LOAD | PSO_STATE_SWITCH;
 		}
 		else if((Length == 0x19580 && read32((u32)Buffer+0x19560) == 0xC8BFAF78) || //PSO Plus
@@ -1126,9 +1163,7 @@
 				(Length == 0x19EA0 && read32((u32)Buffer+0x19E80) == 0x24C7E996) || //PSO 3 PAL
 				(Length == 0x1A2C0 && read32((u32)Buffer+0x1A2A0) == 0xE2BEE1FF))   //PSO 3 NTSC
 		{
-			#ifdef DEBUG_PATCH
 			dbgprintf("PSO:switcher.prs\r\n");
-			#endif
 			PSOHack = PSO_STATE_LOAD | PSO_STATE_PSR | PSO_STATE_SWITCH;
 		}
 	}
@@ -1144,9 +1179,7 @@
 				} break;
 				case 0x00003100:	// Datel DOL
 				{
-#ifdef DEBUG_PATCH
 					dbgprintf("Patch:Datel loading dol:0x%p %u\r\n", Buffer, Length);
-#endif
 					DOLSize = Length;
 					DOLMinOff = (u32)Buffer;
 					DOLMaxOff = DOLMinOff + Length;
@@ -1224,9 +1257,9 @@
 				//	DOLMinOff = (u32)Buffer;
 				//	DOLMaxOff = (u32)Buffer + DOLSize;
 				//}
-#ifdef DEBUG_DI
+//#ifdef DEBUG_DI
 				dbgprintf("DIP:DOL Size:%d MinOff:0x%08X MaxOff:0x%08X\r\n", DOLSize, DOLMinOff, DOLMaxOff );
-#endif
+//#endif
 				/* Hack Position */
 				GameEntry = dol->entrypoint;
 				if (!(PSOHack & PSO_STATE_NOENTRY))
@@ -1276,9 +1309,9 @@
 			}
 			DOLMinOff -= 0x80000000;
 			DOLMaxOff -= 0x80000000;
-#ifdef DEBUG_DI
+//#ifdef DEBUG_DI
 			dbgprintf("DIP:ELF Size:%d MinOff:0x%08X MaxOff:0x%08X\r\n", DOLSize, DOLMinOff, DOLMaxOff );
-#endif
+//#endif
 			/* Hack Position */
 			GameEntry = ehdr->e_entry;
 			ehdr->e_entry = PATCH_OFFSET_ENTRY + 0x80000000;
@@ -1294,7 +1327,7 @@
 			NewVal |= 0x48000000;
 			FirstLine = read32((u32)Buffer+0xB4);
 			write32((u32)Buffer+0xB4, NewVal);
-			dbgprintf("DIP:Hacked ELF FirstLine:0x%08X MinOff:0x%08X MaxOff:0x%08X\r\n", FirstLine, DOLMinOff, DOLMaxOff );
+			dbgprintf("DIP:Hacked ELF FirstLine:0x%08X Size:%d MinOff:0x%08X MaxOff:0x%08X\r\n", FirstLine, DOLSize, DOLMinOff, DOLMaxOff );
 			PatchState |= PATCH_STATE_LOAD;
 		}
 	}
@@ -1306,10 +1339,7 @@
 		DOLMinOff = (u32)Buffer;
 		DOLMaxOff = DOLMinOff + Length;
 		/* Make sure to backup ingame settings */
-		if(TRIGame == TRI_VS4)
-			TRIWriteSettings("/saves/VS4settings.bin", (void*)0x69E4E0, 0x2B);
-		else if(TRIGame == TRI_AX)
-			TRIWriteSettings("/saves/AXsettings.bin", (void*)0x3CFBD0, 0x2B);
+		TRIBackupSettings();
 	}
 
 	if( TRIGame == TRI_SB && Length == 0x1C0 && *((vu8*)Buffer+0x0F) == 0x06 )
@@ -1330,7 +1360,7 @@
 	{
 		PatchBL(PatchCopy(SonicRidersCopy, SonicRidersCopy_size), SONICRIDERS_HOOK_NTSCJ);
 		dbgprintf("Patch:Patched Sonic Riders _Main.rel NTSC-J\r\n");
-	}
+	}
 	else if( (GAME_ID) == 0x47584550 && (u32)Buffer == SONICRIDERS_BASE_PAL
 		&& Length == 0x80000 && read32(SONICRIDERS_HOOK_PAL) == 0x7CFF3B78 )
 	{
@@ -1337,9 +1367,9 @@
 		PatchBL(PatchCopy(SonicRidersCopy, SonicRidersCopy_size), SONICRIDERS_HOOK_PAL);
 		dbgprintf("Patch:Patched Sonic Riders _Main.rel PAL\r\n");
 	}
-	else if( (TITLE_ID) == 0x474842 && useipl == 0 )
+	else if( ((TITLE_ID) == 0x474842 || (TITLE_ID) == 0x47505A) && useipl == 0 )
 	{
-		/* Agressive Timer Patches for The Hobbit */
+		/* Agressive Timer Patches for The Hobbit and Nintendo Puzzle Collection */
 		u32 t;
 		for(t = 0; t < Length; t+=4) //make sure its patched at all times
 			PatchTimers(read32((u32)Buffer+t), (u32)Buffer+t);
@@ -1347,6 +1377,8 @@
 
 	if (!(PatchState & PATCH_STATE_PATCH))
 		return;
+	u32 DSPHandlerNeeded = 1;
+	IsN64Emu = 0;
 	piReg = 0;
 
 	sync_after_write(Buffer, Length);
@@ -1354,10 +1386,8 @@
 	Buffer = (char*)DOLMinOff;
 	Length = DOLMaxOff - DOLMinOff;
 
-#ifdef DEBUG_PATCH
 	dbgprintf("Patch:Offset:0x%08X EOffset:0x%08X Length:%08X\r\n", Buffer, DOLMaxOff, Length );
-	dbgprintf("Patch:Game ID = %x\r\n", read32(0));
-#endif
+	dbgprintf("Patch:Game ID = %x\r\n", GAME_ID);
 
 	sync_before_read(Buffer, Length);
 
@@ -1385,297 +1415,125 @@
 
 	u32 DatelTimerAddr = PatchCopy(DatelTimer, DatelTimer_size);
 
-	if(( TITLE_ID == 0x475858 ) || ( TITLE_ID == 0x474336 ))
+	TRISetupGames();
+	if(TRIGame == TRI_NONE)
 	{
-		// patch out initial memset(0x1800, 0, 0x1800)
-		if( (read32(0) & 0xFF) == 0x4A )	// JAP
-			write32( 0x560C, 0x60000000 );
-		else								// EUR/USA
-			write32( 0x5614, 0x60000000 );
+		if(( TITLE_ID == 0x475858 ) || ( TITLE_ID == 0x474336 ) // Colosseum and XD
+			|| ( GAME_ID == 0x5043534A && Length == 0x479900 ) // Colosseum Bonus
+			|| IsPokemonDemo() )
+		{
+			dbgprintf("Patch:[Pokemon memset] applied\r\n");
+			// patch out initial memset(0x1800, 0, 0x1800)
+			if( (read32(0) & 0xFF) == 0x4A )	// JAP
+				write32( 0x560C, 0x60000000 );
+			else								// EUR/USA
+				write32( 0x5614, 0x60000000 );
 
-		// patch memset to jump to test function
-		write32(0x00005498, 0x4BFFABF0);
+			// patch memset to jump to test function
+			write32(0x00005498, 0x4BFFABF0);
 
-		// patch in test < 0x3000 function
-		write32(0x00000088, 0x3D008000);
-		write32(0x0000008C, 0x61083000);
-		write32(0x00000090, 0x7C044000);
-		write32(0x00000094, 0x4180542C);
-		write32(0x00000098, 0x90E40004);
-		write32(0x0000009C, 0x48005400);
+			// patch in test < 0x3000 function
+			write32(0x00000088, 0x3D008000);
+			write32(0x0000008C, 0x61083000);
+			write32(0x00000090, 0x7C044000);
+			write32(0x00000094, 0x4180542C);
+			write32(0x00000098, 0x90E40004);
+			write32(0x0000009C, 0x48005400);
 
-		// skips __start init of debugger mem
-		write32(0x00003194, 0x48000028);
-	}
-
-	if( read32(0x023D240) == 0x386000A8 )
-	{
-		dbgprintf("TRI:Mario Kart GP1\r\n");
-		TRIGame = TRI_GP1;
-		SystemRegion = REGION_JAPAN;
-
-		//Unlimited CARD uses
-		write32( 0x01F5C44, 0x60000000 );
-
-		//Disable cam
-		write32( 0x00790A0, 0x98650025 );
-
-		//Disable CARD
-		//write32( 0x00790B4, 0x98650023 );
-		//write32( 0x00790CC, 0x98650023 );
-
-		//Disable wheel/handle
-		write32( 0x007909C, 0x98650022 );
-
-		//VS wait
-		write32( 0x00BE10C, 0x4800002C );
-
-		//cam loop
-		write32( 0x009F1E0, 0x60000000 );
-
-		//Enter test mode (anti-freeze)
-		write32( 0x0031BF0, 0x60000000 );
-		//Allow test menu if requested
-		PatchBL( PatchCopy(CheckTestMenu, CheckTestMenu_size), 0x31BF4 );
-
-		//Remove some menu timers
-		write32( 0x0019BFF8, 0x60000000 ); //card check
-		write32( 0x001BCAA8, 0x60000000 ); //want to make a card
-		write32( 0x00195748, 0x60000000 ); //card view
-		write32( 0x000CFABC, 0x60000000 ); //select game mode
-		write32( 0x000D9F14, 0x60000000 ); //select character
-		write32( 0x001A8CF8, 0x60000000 ); //select cup
-		write32( 0x001A89B8, 0x60000000 ); //select round
-		write32( 0x001A36CC, 0x60000000 ); //select item pack (card)
-		write32( 0x001A2A10, 0x60000000 ); //select item (card)
-		write32( 0x001B9724, 0x60000000 ); //continue
-		write32( 0x001E61B4, 0x60000000 ); //rewrite rank
-		write32( 0x001A822C, 0x60000000 ); //select course p1 (time attack)
-		write32( 0x001A7F0C, 0x60000000 ); //select course p2 (time attack)
-		write32( 0x000D6234, 0x60000000 ); //enter name (time attack, card)
-		write32( 0x001BF1DC, 0x60000000 ); //save record p1 (time attack on card)
-		write32( 0x001BF1DC, 0x60000000 ); //save record p2 (time attack on card)
-		write32( 0x000E01B4, 0x60000000 ); //select record place (time attack on card)
-
-		//Modify to regular GX pattern to patch later
-		write32( 0x363660, 0x00 ); //NTSC Interlaced
-
-		//Test Menu Interlaced
-		//memcpy( (void*)0x036369C, (void*)0x040EB88, 0x3C );
-
-		//PAD Hook for control updates
-		PatchBL(PatchCopy(PADReadGP, PADReadGP_size), 0x3C2A0 );
-
-		//some report check skip
-		//write32( 0x00307CC, 0x60000000 );
-
-		//memcpy( (void*)0x00330BC, OSReportDM, sizeof(OSReportDM) );
-		//memcpy( (void*)0x0030710, OSReportDM, sizeof(OSReportDM) );
-		//memcpy( (void*)0x0030760, OSReportDM, sizeof(OSReportDM) );
-		//memcpy( (void*)0x020CBCC, OSReportDM, sizeof(OSReportDM) );	// UNkReport
-		//memcpy( (void*)0x02281B8, OSReportDM, sizeof(OSReportDM) );	// UNkReport4
-	}
-	else if (read32(0x02856EC) == 0x386000A8)
-	{
-		dbgprintf("TRI:Mario Kart GP2\r\n");
-		TRIGame = TRI_GP2;
-		SystemRegion = REGION_JAPAN;
-
-		//Unlimited CARD uses
-		write32( 0x00A02F8, 0x60000000 );
-
-		//Enter test mode (anti-freeze)
-		write32( 0x002E340, 0x60000000 );
-		//Allow test menu if requested
-		PatchBL( PatchCopy(CheckTestMenu, CheckTestMenu_size), 0x2E344 );
-
-		//Disable wheel
-		write32( 0x007909C, 0x98650022 );
-
-		//Disable CARD
-		//write32( 0x0073BF4, 0x98650023 );
-		//write32( 0x0073C10, 0x98650023 );
-
-		//Disable cam
-		write32( 0x0073BD8, 0x98650025 );
-
-		//Disable red item button
-		write32( 0x0073C98, 0x98BF0045 );
-
-		//VS wait patch 
-		write32( 0x0084FC4, 0x4800000C );
-		write32( 0x0085000, 0x60000000 );
-
-		//Game vol
-		//write32( 0x00790E8, 0x39000009 );
-
-		//Attract vol
-		//write32( 0x00790F4, 0x38C0000C );
-
-		//Disable Commentary (sets volume to 0 )
-		//write32( 0x001B6510, 0x38800000 );
-
-		//Patches the analog input count
-		write32( 0x000392F4, 0x38000003 );
-
-		//Remove some menu timers (thanks conanac)
-		write32( 0x001C1074, 0x60000000 ); //card check
-		write32( 0x001C0174, 0x60000000 ); //want to make a card
-		write32( 0x00232818, 0x60000000 ); //card view
-		write32( 0x001C1A08, 0x60000000 ); //select game mode
-		write32( 0x001C3380, 0x60000000 ); //select character
-		write32( 0x001D7594, 0x60000000 ); //select kart
-		write32( 0x001C7A7C, 0x60000000 ); //select cup
-		write32( 0x001C9ED8, 0x60000000 ); //select round
-		write32( 0x00237B3C, 0x60000000 ); //select item (card)
-		write32( 0x0024D35C, 0x60000000 ); //continue
-		write32( 0x0015F2F4, 0x60000000 ); //rewrite rank
-		write32( 0x001CF5DC, 0x60000000 ); //select course (time attack)
-		write32( 0x001BE248, 0x60000000 ); //enter name (time attack, card)
-		write32( 0x0021DFF0, 0x60000000 ); //save record (time attack on card)
-
-		//Make some menu timers invisible
-		write32( 0x001B7D2C, 0x60000000 );
-		write32( 0x00231CA0, 0x60000000 );
-
-		//Modify to regular GX pattern to patch later
-		write32( 0x3F1FD0, 0x00 ); //NTSC Interlaced
-
-		//PAD Hook for control updates
-		PatchBL(PatchCopy(PADReadGP, PADReadGP_size), 0x38A34 );
-
-		//memcpy( (void*)0x002CE3C, OSReportDM, sizeof(OSReportDM) );
-		//memcpy( (void*)0x002CE8C, OSReportDM, sizeof(OSReportDM) );
-		//write32( 0x002CEF8, 0x60000000 );
-	}
-	else if( read32(0x01851C4) == 0x386000A8 )
-	{
-		dbgprintf("TRI:F-Zero AX\r\n");
-		TRIGame = TRI_AX;
-		SystemRegion = REGION_JAPAN;
-		DISetDIMMVersion(0x12301777);
-
-		//Reset loop
-		write32( 0x01B5410, 0x60000000 );
-
-		//DBGRead fix
-		write32( 0x01BEF38, 0x60000000 );
-
-		//Disable CARD
-		//write32( 0x017B2BC, 0x38C00000 );
-
-		//Motor init patch
-		write32( 0x0175710, 0x60000000 );
-		write32( 0x0175714, 0x60000000 );
-		write32( 0x01756AC, 0x60000000 );
-
-		//patching system waiting stuff
-		write32( 0x0180DB8, 0x48000054 );
-		write32( 0x0180E1C, 0x48000054 );
-
-		//Network waiting
-		write32( 0x0180FD8, 0x4800004C );
-
-		//Goto Test menu
-		write32( 0x00DF3D0, 0x60000000 );
-		//Allow test menu if requested
-		PatchBL( PatchCopy(CheckTestMenu, CheckTestMenu_size), 0xDF3D4 );
-
-		//Replace Motor Init with Controller Setup
-		write32( 0x0024E034, 0x80180D5C );
-		write32( 0x0024E038, 0x80180BC0 );
-
-		//Call Important Init Function
-		PatchB( 0x000DA6D4, 0x00180D9C );
-
-		//Remove Overscan on first VIConfigure
-		write32( 0x001FBE54, 0x38C00000 );
-
-		//English
-		write32( 0x000DF698, 0x38000000 );
-
-		//Remove some menu timers (thanks dj_skual)
-		// (menu gets constantly removed in JVSIO.c)
-		write32( 0x0015B148, 0x60000000 ); //after race
-
-		//Make some menu timers invisible (thanks dj_skual)
-		write32( 0x0023759C, 0x40200000 ); //menu inner
-		write32( 0x002375D4, 0x40200000 ); //menu outer
-		write32( 0x00237334, 0x00000000 ); //after race inner
-		write32( 0x0023736C, 0x00000000 ); //after race outer
-
-		//Check for already existing settings
-		if(TRI_BackupAvailable == 0)
-			TRIReadSettings("/saves/AXsettings.bin", 0x2B);
-		//Custom backup handler
-		if(TRI_BackupAvailable == 1)
-			PatchB(PatchCopy(RestoreSettingsAX, RestoreSettingsAX_size), 0x17B490);
-
-		//Modify to regular GX pattern to patch later
-		u32 NTSC480ProgTri = 0x21D3EC;
-		write32(NTSC480ProgTri, 0x00); //NTSC Interlaced
-		write32(NTSC480ProgTri + 0x14, 0x01); //Mode DF
-
-		NTSC480ProgTri = 0x302AC0;
-		write32(NTSC480ProgTri, 0x00); //NTSC Interlaced
-		write32(NTSC480ProgTri + 0x14, 0x01); //Mode DF
-
-		//PAD Hook for control updates
-		PatchBL( PatchCopy(PADReadF, PADReadF_size), 0x1B4368 );
-
-		//memcpy( (void*)0x01CAACC, patch_fwrite_GC, sizeof(patch_fwrite_GC) );
-		//memcpy( (void*)0x01882C0, OSReportDM, sizeof(OSReportDM) );
-
-		//Unkreport
-		//PatchB( 0x01882C0, 0x0191B54 );
-		//PatchB( 0x01882C0, 0x01C53CC );
-		//PatchB( 0x01882C0, 0x01CC684 );
-	}
-	else if( read32( 0x0210C08 ) == 0x386000A8 )
-	{
-		dbgprintf("TRI:Virtua Striker 4 Ver 2006 (EXPORT)\r\n");
-		TRIGame = TRI_VS4;
-		SystemRegion = REGION_USA;
-		DISetDIMMVersion(0xA3A479);
-
-		//BOOT/FIRM version mismatch patch (not needed with SegaBoot)
-		write32( 0x0051924, 0x60000000 );
-
-		//Set menu timer to about 51 days
-		write32( 0x00CBB7C, 0x3C800FFF );
-
-		//Allow test menu if requested
-		PatchBL( PatchCopy(CheckTestMenuVS, CheckTestMenuVS_size), 0x3B804 );
-
-		//Check for already existing settings
-		if(TRI_BackupAvailable == 0)
-			TRIReadSettings("/saves/VS4settings.bin", 0x2B);
-		//Custom backup handler
-		if(TRI_BackupAvailable == 1)
-			PatchB(PatchCopy(RestoreSettingsVS, RestoreSettingsVS_size), 0x12BD4);
-
-		//Modify to regular GX pattern to patch later
-		write32( 0x26DD38, 0x00 ); //NTSC Interlaced
-
-		//PAD Hook for control updates
-		PatchBL(PatchCopy(PADReadVS, PADReadVS_size), 0x3C504 );
-
-		//memcpy( (void*)0x001C2B80, OSReportDM, sizeof(OSReportDM) );
-	}
-	else if(useipltri)
-	{
-		if( read32( 0x00055F98 ) == 0x386000A8 )
+			// skips __start init of debugger mem
+			write32(0x00003194, 0x48000028);
+		}
+		else if(read32(0xF278C) == 0x2F6D616A) //Majoras Mask NTSC-U
 		{
-			write32(0x000627A4, 0x3C808006); //lis r4, 0x8006
-			write32(0x000627AC, 0x6084E93C); //ori r4, r4, 0xE93C
-			write32(0x0006E93C, 0x01010A01); //modify 0x8006E93C for Free Play
-			dbgprintf("TRI:SegaBoot (Patched Free Play)\r\n");
+			dbgprintf("Patch:[Majoras Mask NTSC-U] applied\r\n");
+			//save up regs
+			u32 majora_save = PatchCopy(MajoraSaveRegs, MajoraSaveRegs_size);
+			PatchB(majora_save, 0x1CDD4);
+			PatchB(0x1CDD8, majora_save+MajoraSaveRegs_size-4);
+			//frees r28 and secures r10 for us
+			write32(0x1CE8C, 0x60000000);
+			write32(0x1CE90, 0x839D0000);
+			write32(0x1CE94, 0x7D3C4AAE);
+			//do audio streaming injection
+			u32 majora_as = PatchCopy(MajoraAudioStream, MajoraAudioStream_size);
+			PatchB(majora_as, 0x1CEA4);
+			PatchB(0x1CEA8, majora_as+MajoraAudioStream_size-4);
+			//load up regs (and jump back)
+			PatchB(PatchCopy(MajoraLoadRegs, MajoraLoadRegs_size), 0x1CF98);
+			DSPHandlerNeeded = 0;
+			IsN64Emu = 1;
 		}
-		else
-			dbgprintf("TRI:SegaBoot\r\n");
-		TRIGame = TRI_SB;
+		else if(read32(0xF624C) == 0x2F6D616A) //Majoras Mask NTSC-U
+		{
+			dbgprintf("Patch:[Majoras Mask NTSC-J] applied\r\n");
+			//save up regs
+			u32 majora_save = PatchCopy(MajoraSaveRegs, MajoraSaveRegs_size);
+			PatchB(majora_save, 0x1D448);
+			PatchB(0x1D44C, majora_save+MajoraSaveRegs_size-4);
+			//frees r28 and secures r10 for us
+			write32(0x1D500, 0x60000000);
+			write32(0x1D504, 0x839D0000);
+			write32(0x1D508, 0x7D3C4AAE);
+			//do audio streaming injection
+			u32 majora_as = PatchCopy(MajoraAudioStream, MajoraAudioStream_size);
+			PatchB(majora_as, 0x1D518);
+			PatchB(0x1D51C, majora_as+MajoraAudioStream_size-4);
+			//load up regs (and jump back)
+			PatchB(PatchCopy(MajoraLoadRegs, MajoraLoadRegs_size), 0x1D60C);
+			DSPHandlerNeeded = 0;
+			IsN64Emu = 1;
+		}
+		else if(read32(0xE16D8) == 0x2F6D616A) //Majoras Mask PAL
+		{
+			dbgprintf("Patch:[Majoras Mask PAL] applied\r\n");
+			//save up regs
+			u32 majora_save = PatchCopy(MajoraSaveRegs, MajoraSaveRegs_size);
+			PatchB(majora_save, 0x1D6B4);
+			PatchB(0x1D6B8, majora_save+MajoraSaveRegs_size-4);
+			//frees r28 and secures r10 for us
+			write32(0x1D76C, 0x60000000);
+			write32(0x1D770, 0x839D0000);
+			write32(0x1D774, 0x7D3C4AAE);
+			//do audio streaming injection
+			u32 majora_as = PatchCopy(MajoraAudioStream, MajoraAudioStream_size);
+			PatchB(majora_as, 0x1D784);
+			PatchB(0x1D788, majora_as+MajoraAudioStream_size-4);
+			//load up regs (and jump back)
+			PatchB(PatchCopy(MajoraLoadRegs, MajoraLoadRegs_size), 0x1D878);
+			DSPHandlerNeeded = 0;
+			IsN64Emu = 1;
+		}
+		else if(read32(0x1373E8) == 0x5A454C44) //Ocarina of Time NTSC-U
+		{
+			dbgprintf("Patch:[Ocarina of Time NTSC-U]\r\n");
+			IsN64Emu = 1;
+		}
+		else if(read32(0x134EE8) == 0x5A454C44) //Ocarina of Time NTSC-J
+		{
+			dbgprintf("Patch:[Ocarina of Time NTSC-J]\r\n");
+			IsN64Emu = 1;
+		}
+		else if(read32(0x181200) == 0x5A454C44) //Ocarina of Time PAL
+		{
+			dbgprintf("Patch:[Ocarina of Time PAL]\r\n");
+			IsN64Emu = 1;
+		}
+		else if(read32(0x1356B8) == 0x5A454C44) //OOT Bonus Disc NTSC-U
+		{
+			dbgprintf("Patch:[OOT Bonus Disc NTSC-U]\r\n");
+			IsN64Emu = 1;
+		}
+		else if(read32(0x18B178) == 0x5A454C44) //OOT Bonus Disc NTSC-J
+		{
+			dbgprintf("Patch:[OOT Bonus Disc NTSC-J]\r\n");
+			IsN64Emu = 1;
+		}
+		else if(read32(0x1582F0) == 0x5A454C44) //OOT Bonus Disc PAL
+		{
+			dbgprintf("Patch:[OOT Bonus Disc PAL]\r\n");
+			IsN64Emu = 1;
+		}
 	}
-
 	DisableEXIPatch = (TRIGame == TRI_NONE && ConfigGetConfig(NIN_CFG_MEMCARDEMU) == false);
 	DisableSIPatch = (TRIGame == TRI_NONE && ConfigGetConfig(NIN_CFG_NATIVE_SI));
 
@@ -1687,35 +1545,61 @@
 		PatchWide = false;
 
 	PatchFuncInterface( Buffer, Length );
-	sync_after_write( Buffer, Length );
-	sync_before_read( Buffer, Length );
 
-	u32 PatchCount = FPATCH_OSSleepThread | FPATCH_VideoModes;
+	u32 PatchCount = FPATCH_VideoModes | 
+		FPATCH_OSSleepThread | FPATCH_GXBegin | FPATCH_GXDrawDone;
 #ifdef CHEATS
-	if( IsWiiU )
+	if( (IsWiiU && ConfigGetConfig(NIN_CFG_CHEATS)) ||
+		(!IsWiiU && ConfigGetConfig(NIN_CFG_DEBUGGER|NIN_CFG_CHEATS)) )
 	{
-		if( ConfigGetConfig(NIN_CFG_CHEATS) )
-			PatchCount &= ~FPATCH_OSSleepThread;
+		PatchCount &= ~(
+			FPATCH_OSSleepThread | //Hook 1
+			//FPATCH_GXBegin //Hook 2, unstable!
+			FPATCH_GXDrawDone //Hook 3
+		);
 	}
-	else
-	{
-		if( ConfigGetConfig(NIN_CFG_DEBUGGER|NIN_CFG_CHEATS) )
-			PatchCount &= ~FPATCH_OSSleepThread;
-	}
 #endif
-	if( ConfigGetConfig(NIN_CFG_FORCE_PROG) || (ConfigGetVideoMode() & NIN_VID_FORCE) )
+	if( ConfigGetConfig(NIN_CFG_FORCE_PROG) || (ConfigGetVideoMode() & NIN_VID_FORCE) ||
+		(ConfigGetVideoOffset() != 0 && ConfigGetVideoOffset() >= -20 && ConfigGetVideoOffset() <= 20) ||
+		(ConfigGetVideoScale() != 0 && ConfigGetVideoScale() >= 40 && ConfigGetVideoScale() <= 120) )
 		PatchCount &= ~FPATCH_VideoModes;
-
+	/* Set up patch pattern lists */
+	FuncPatterns CurFPatternsList[PCODE_MAX];
+	u32 CurFPatternsListLen = 0;
+	u32 minPatternSize = 0xFFFFFFFF;
+	u32 maxPatternSize = 0;
 	u32 patitr;
 	for(patitr = 0; patitr < PCODE_MAX; ++patitr)
 	{
+		/* only handle used patterns */
+		if(AllFPatterns[patitr].patmode == PCODE_TRI && TRIGame == TRI_NONE)
+			continue;
+		if(AllFPatterns[patitr].patmode == PCODE_EXI && DisableEXIPatch)
+			continue;
+		if (AllFPatterns[patitr].patmode == PCODE_DATEL && Datel == 0)
+			continue;
+		if (AllFPatterns[patitr].patmode == PCODE_PSO && isPSO == 0)
+			continue;
+		if (AllFPatterns[patitr].patmode == PCODE_SI && DisableSIPatch)
+			continue;
+		/* clear from pervious patches */
 		FuncPattern *CurPatterns = AllFPatterns[patitr].pat;
 		u32 CurPatternsLen = AllFPatterns[patitr].patlen;
 		for( j=0; j < CurPatternsLen; ++j )
+		{
 			CurPatterns[j].Found = 0;
+			if(CurPatterns[j].Length < minPatternSize)
+				minPatternSize = CurPatterns[j].Length;
+			if(CurPatterns[j].Length > maxPatternSize)
+				maxPatternSize = CurPatterns[j].Length;
+		}
+		/* we use this pattern type */
+		CurFPatternsList[CurFPatternsListLen].pat = CurPatterns;
+		CurFPatternsList[CurFPatternsListLen].patlen = CurPatternsLen;
+		CurFPatternsListLen++;
 	}
 	/* Cheats */
-	u32 DebuggerHook = 0;
+	u32 DebuggerHook = 0, DebuggerHook2 = 0, DebuggerHook3 = 0;
 	/* SI Inited Patch */
 	u32 PADInitOffset = 0, SIInitOffset = 0;
 	/* DSP Patches */
@@ -1811,9 +1695,7 @@
 					u32 HwOffset = Offset;
 					if ((read32(Offset + 4) & 0xFFFF) == 0xD302)	// Loader
 						HwOffset = Offset + 4;
-					#ifdef DEBUG_PATCH
 					dbgprintf("Patch:[__DVDInterruptHandler]: 0x%08X (0x%08X)\r\n", Offset, HwOffset );
-					#endif
 					PatchBL(__DVDInterruptHandlerAddr, HwOffset);
 					PatchCount |= FPATCH_DVDIntrHandler;
 					i = GotoFuncEnd(i, (u32)Buffer);
@@ -1827,9 +1709,7 @@
 					u32 HwOffset = Offset;
 					if ((read32(Offset + 4) & 0xFFFF) == 0xD302)	// Loader
 						HwOffset = Offset + 4;
-					#ifdef DEBUG_PATCH
 					dbgprintf("Patch:[__DVDInterruptHandler]: 0x%08X (0x%08X)\r\n", Offset, HwOffset );
-					#endif
 					//PatchDiscInterface( (char*)Offset );
 					PatchBL(__DVDInterruptHandlerAddr, HwOffset);
 					PatchCount |= FPATCH_DVDIntrHandler;
@@ -1846,9 +1726,7 @@
 						HwOffset = Offset + 4;
 					else
 					{
-						#ifdef DEBUG_PATCH
 						dbgprintf("Patch:[__DVDInterruptHandler]: 0x%08X (0x%08X)\r\n", Offset, HwOffset );
-						#endif
 						// Save r0 (lr) before bl
 						u32 OrigData = read32(HwOffset);
 						write32(HwOffset, read32(HwOffset + 4));
@@ -1855,9 +1733,7 @@
 						write32(HwOffset + 4, OrigData);
 						HwOffset = Offset + 4;
 					}
-					#ifdef DEBUG_PATCH
 					dbgprintf("Patch:[__DVDInterruptHandler]: 0x%08X (0x%08X)\r\n", Offset, HwOffset );
-					#endif
 					//PatchDiscInterface( (char*)Offset );
 					PatchBL(__DVDInterruptHandlerAddr, HwOffset);
 					PatchCount |= FPATCH_DVDIntrHandler;
@@ -1876,6 +1752,19 @@
 					continue;
 				}
 			}
+			if( (PatchCount & FPATCH_getTiming) == 0 )
+			{
+				if( BufAt0 == 0x386500BE && BufAt4 == 0x4E800020 && read32((u32)Buffer+i+8) == 0x386500E4 &&
+					read32((u32)Buffer+i+12) == 0x4E800020 && read32((u32)Buffer+i+16) == 0x38600000 &&
+					read32((u32)Buffer+i+20) == 0x4E800020 )
+				{
+					printpatchfound("getTiming", NULL, (u32)Buffer + i + 16);
+					write32( (u32)Buffer + i + 16, 0x7CA32B78 ); //mr r5, r3
+					PatchCount |= FPATCH_getTiming;
+					i += 20;
+					continue;
+				}
+			}
 			if( (PatchCount & FPATCH_GXInit) == 0 )
 			{
 				if( BufAt0 == 0x3C80CC00 ) /* Release SDK */
@@ -1889,9 +1778,7 @@
 						else if( p1 && R16((u32)Buffer+j) == 0x90AD )
 						{
 							piReg = R16( (u32)Buffer + j + 2 );
-							#ifdef DEBUG_PATCH
 							dbgprintf("Patch:[GXInit] stw r5,-0x%X(r13) (0x%08X)\r\n", 0x10000 - piReg, (u32)Buffer + j + 2);
-							#endif
 							PatchCount |= FPATCH_GXInit;
 							i = GotoFuncEnd(j, (u32)Buffer);
 							break;
@@ -1910,9 +1797,7 @@
 						else if( p1 && R16((u32)Buffer+j) == 0x906D )
 						{
 							piReg = R16( (u32)Buffer + j + 2 );
-							#ifdef DEBUG_PATCH
 							dbgprintf("Patch:[GXInit DBG] stw r3,-0x%X(r13) (0x%08X)\r\n", 0x10000 - piReg, (u32)Buffer + j + 2);
-							#endif
 							PatchCount |= FPATCH_GXInit;
 							i = GotoFuncEnd(j, (u32)Buffer);
 							break;
@@ -1925,7 +1810,7 @@
 			{
 				if(BufAt0 == 0x38C00008 && read32((u32)Buffer+i+16) == 0x38800008 && read32((u32)Buffer+i+28) == 0x90DD0004)
 				{
-					printpatchfound("__CARDUnlock", NULL, (u32)Buffer + GotoFuncStart(i, (u32)Buffer));
+					printpatchfound("__CARDUnlock", "A", (u32)Buffer + GotoFuncStart(i, (u32)Buffer));
 					write32( (u32)Buffer+i, 0x3CC01000 ); //lis r6, 0x1000
 					write32( (u32)Buffer+i+28, 0x909D0004 ); //stw r4, 4(r29)
 					write32( (u32)Buffer+i+36, 0x90DD0008 ); //stw r6, 8(r29)
@@ -1933,6 +1818,30 @@
 					i = GotoFuncEnd(i, (u32)Buffer);
 					continue;
 				}
+				else if(BufAt0 == 0x38000008 && BufAt4 == 0x54A47820 && 
+					read32((u32)Buffer+i+20) == 0x901F0044 && read32((u32)Buffer+i+28) == 0x7C801A78 && 
+					read32((u32)Buffer+i+40) == 0x3B400000 && read32((u32)Buffer+i+60) == 0x38800008)
+				{
+					printpatchfound("__CARDUnlock", "IPL A", (u32)Buffer + GotoFuncStart(i, (u32)Buffer));
+					write32( (u32)Buffer+i, 0x38800008 ); //li r4, 8
+					write32( (u32)Buffer+i+4, 0x54A07820 ); //slwi r0, r5, 15
+					write32( (u32)Buffer+i+20, 0x909F0044 ); //stw r4, 0x44(r31)
+					write32( (u32)Buffer+i+28, 0x7C001A78 ); //xor r0, r0, r3
+					write32( (u32)Buffer+i+40, 0x3F401000 ); //lis r26, 0x1000
+					write32( (u32)Buffer+i+60, 0x3B400000 ); //li r26, 0
+					PatchCount |= FPATCH_CARDUnlock;
+					i = GotoFuncEnd(i, (u32)Buffer);
+					continue;
+				}
+				else if(BufAt0 == 0x38A00008 && read32((u32)Buffer+i+8) == 0x38000000 &&
+					read32((u32)Buffer+i+44) == 0x90BD0004 && read32((u32)Buffer+i+52) == 0x901D0008)
+				{
+					printpatchfound("__CARDUnlock", "IPL B", (u32)Buffer + GotoFuncStart(i, (u32)Buffer));
+					write32( (u32)Buffer+i+8, 0x3C001000 ); //lis r0, 0x1000
+					PatchCount |= FPATCH_CARDUnlock;
+					i = GotoFuncEnd(i, (u32)Buffer);
+					continue;
+				}
 				else if(BufAt0 == 0x38000008 && BufAt4 == 0x90180004 && 
 					read32((u32)Buffer+i+16) == 0x38000000 && read32((u32)Buffer+i+20) == 0x90180008)
 				{
@@ -1951,19 +1860,74 @@
 					( BufAt4 == 0x3C808000 || BufAt4 == 0x808400E4 ) &&
 					( read32((u32)Buffer + i + 8 ) == 0x38000004 || read32((u32)Buffer + i + 8 ) == 0x808400E4 ) )
 				{
-					int j = 12;
-
-					while( *(vu32*)(Buffer+i+j) != 0x4E800020 )
-						j+=4;
-
-					DebuggerHook = (u32)Buffer + i + j;
-					printpatchfound("Hook:OSSleepThread",NULL, DebuggerHook);
-
 					PatchCount |= FPATCH_OSSleepThread;
 					i = GotoFuncEnd(i, (u32)Buffer);
+					if(DebuggerHook == 0) DebuggerHook = (u32)Buffer + i;
+					else if(DebuggerHook2 == 0) DebuggerHook2 = (u32)Buffer + i;
+					else if(DebuggerHook3 == 0) DebuggerHook3 = (u32)Buffer + i;
+					printpatchfound("Hook:OSSleepThread",NULL,(u32)Buffer + i);
 					continue;
 				}
 			}
+			if( (PatchCount & FPATCH_GXBegin) == 0 )
+			{
+				//GXBegin(Pattern 1)
+				if( BufAt0 == 0x3C60CC01 && BufAt4 == 0x98038000 &&
+					( read32((u32)Buffer + i + 8 ) == 0xB3E38000 || read32((u32)Buffer + i + 8 ) == 0xB3C38000 ) )
+				{
+					PatchCount |= FPATCH_GXBegin;
+					i = GotoFuncEnd(i, (u32)Buffer);
+					if(DebuggerHook == 0) DebuggerHook = (u32)Buffer + i;
+					else if(DebuggerHook2 == 0) DebuggerHook2 = (u32)Buffer + i;
+					else if(DebuggerHook3 == 0) DebuggerHook3 = (u32)Buffer + i;
+					printpatchfound("Hook:GXBegin",NULL,(u32)Buffer + i);
+					continue;
+				}
+			}
+			if( (PatchCount & FPATCH_GXDrawDone) == 0 )
+			{
+				//GXDrawDone(Pattern 1)
+				if( BufAt0 == 0x3CC0CC01 && BufAt4 == 0x3CA04500 &&
+					read32((u32)Buffer + i + 12) == 0x38050002 && read32((u32)Buffer + i + 16) == 0x90068000 )
+				{
+					i = GotoFuncEnd(i, (u32)Buffer);
+					if(DebuggerHook == 0) DebuggerHook = (u32)Buffer + i;
+					else if(DebuggerHook2 == 0) DebuggerHook2 = (u32)Buffer + i;
+					else if(DebuggerHook3 == 0) DebuggerHook3 = (u32)Buffer + i;
+					printpatchfound("Hook:GXDrawDone",NULL,(u32)Buffer + i);
+					continue;
+				} //GXDrawDone(Pattern 2)
+				else if( BufAt0 == 0x3CA0CC01 && BufAt4 == 0x3C804500 &&
+					read32((u32)Buffer + i + 12) == 0x38040002 && read32((u32)Buffer + i + 16) == 0x90058000 )
+				{
+					i = GotoFuncEnd(i, (u32)Buffer);
+					if(DebuggerHook == 0) DebuggerHook = (u32)Buffer + i;
+					else if(DebuggerHook2 == 0) DebuggerHook2 = (u32)Buffer + i;
+					else if(DebuggerHook3 == 0) DebuggerHook3 = (u32)Buffer + i;
+					printpatchfound("Hook:GXDrawDone",NULL,(u32)Buffer + i);
+					continue;
+				} //GXDrawDone(Pattern 3)
+				else if( BufAt0 == 0x3FE04500 && BufAt4 == 0x3BFF0002 &&
+					read32((u32)Buffer + i + 20) == 0x3C60CC01 && read32((u32)Buffer + i + 24) == 0x93E38000 )
+				{
+					i = GotoFuncEnd(i, (u32)Buffer);
+					if(DebuggerHook == 0) DebuggerHook = (u32)Buffer + i;
+					else if(DebuggerHook2 == 0) DebuggerHook2 = (u32)Buffer + i;
+					else if(DebuggerHook3 == 0) DebuggerHook3 = (u32)Buffer + i;
+					printpatchfound("Hook:GXDrawDone",NULL,(u32)Buffer + i);
+					continue;
+				}//GXDrawDone(Pattern 4)
+				else if( BufAt0 == 0x3C804500 && read32((u32)Buffer + i + 12) == 0x3CA0CC01 &&
+					read32((u32)Buffer + i + 28) == 0x38040002 && read32((u32)Buffer + i + 40) == 0x90058000 )
+				{
+					i = GotoFuncEnd(i, (u32)Buffer);
+					if(DebuggerHook == 0) DebuggerHook = (u32)Buffer + i;
+					else if(DebuggerHook2 == 0) DebuggerHook2 = (u32)Buffer + i;
+					else if(DebuggerHook3 == 0) DebuggerHook3 = (u32)Buffer + i;
+					printpatchfound("Hook:GXDrawDone",NULL,(u32)Buffer + i);
+					continue;
+				}
+			}
 	#endif
 			if( (PatchCount & FPATCH_VideoModes) == 0 )
 			{
@@ -1995,11 +1959,13 @@
 								write32( (u32)Buffer+i+0x14, 0); //mode sf
 								break;
 							case 0x04: //PAL50
+								if(!(ConfigGetVideoMode() & NIN_VID_PATCH_PAL50))
+									break;
 								printvidpatch(VI_PAL, VI_480P, (u32)Buffer+i);
 								write32( (u32)Buffer+i, 0x02 );
 								//write32( (u32)Buffer+i, 0x06 );
+								memcpy( Buffer+i+0x04, GXIntDfAt04, sizeof(GXIntDfAt04) ); //terrible workaround I know
 								write32( (u32)Buffer+i+0x14, 0); //mode sf
-								//memcpy(Buffer+i, GXNtsc480Prog, sizeof(GXNtsc480Prog));
 								break;
 							case 0x08: //MPAL
 							case 0x14: //PAL60
@@ -2012,7 +1978,7 @@
 								break;
 						}
 					}
-					else
+					else if( ConfigGetVideoMode() & NIN_VID_FORCE )
 					{
 						u8 NinForceMode = ConfigGetVideoMode() & NIN_VID_FORCE_MASK;
 						switch(read32((u32)Buffer+i))
@@ -2048,7 +2014,8 @@
 								write32( (u32)Buffer+i+0x14, 1); //mode df
 								break;
 							case 0x04: //PAL50
-								if(NinForceMode == NIN_VID_FORCE_PAL50 || NinForceMode == NIN_VID_FORCE_PAL60)
+								if(NinForceMode == NIN_VID_FORCE_PAL50 || NinForceMode == NIN_VID_FORCE_PAL60
+										|| !(ConfigGetVideoMode() & NIN_VID_PATCH_PAL50))
 									break;
 								if(NinForceMode == NIN_VID_FORCE_MPAL)
 								{
@@ -2082,6 +2049,21 @@
 								break;
 						}
 					}
+					if(ConfigGetVideoScale() >= 40 && ConfigGetVideoScale() <= 120)
+					{
+						W16((u32)Buffer+i+0xE, ConfigGetVideoScale() + 600);
+						W16((u32)Buffer+i+0xA, (720 - R16((u32)Buffer+i+0xE)) / 2);
+					}
+					if(ConfigGetVideoOffset() >= -20 && ConfigGetVideoOffset() <= 20)
+					{
+						u16 xorig = R16((u32)Buffer+i+0xA);
+						if((xorig + ConfigGetVideoOffset()) < 0)
+							W16((u32)Buffer+i+0xA, 0);
+						else if((xorig + ConfigGetVideoOffset()) > 80)
+							W16((u32)Buffer+i+0xA, 80);
+						else
+							W16((u32)Buffer+i+0xA, xorig + ConfigGetVideoOffset());
+					}
 					i += 0x3C;
 					continue;
 				}
@@ -2150,10 +2132,7 @@
 							dbgprintf("DSP after Patch\r\n");
 							hexdump((void*)(Buffer + i), DspMatches[l].Length);
 	#endif
-
-							#ifdef DEBUG_PATCH
 							dbgprintf("Patch:[DSP v%u] patched (0x%08X)\r\n", Known, Buffer + i );
-							#endif
 							//PatchCount |= FPATCH_DSP_ROM; // yes, games can
 							//have multiple DSPs, check out Smugglers Run
 							i += DspMatches[l].Length;
@@ -2172,22 +2151,17 @@
 		}
 		i+=4;
 
-		FuncPattern fp;
-		MPattern( (u8*)(Buffer+i), Length, &fp );
+		MPattern( (u8*)(Buffer+i), maxPatternSize, &curFunc );
+		/* only deal with functions with potentially correct function sizes */
+		if(curFunc.Length < minPatternSize || curFunc.Length > maxPatternSize)
+			continue;
 		//if ((((u32)Buffer + i) & 0x7FFFFFFF) == 0x00000000) //(FuncPrint)
-		//	dbgprintf("FuncPattern: 0x%X, %d, %d, %d, %d, %d\r\n", fp.Length, fp.Loads, fp.Stores, fp.FCalls, fp.Branch, fp.Moves);
-		for(patitr = 0; patitr < PCODE_MAX; ++patitr)
+		//	dbgprintf("FuncPattern: 0x%X, %d, %d, %d, %d, %d\r\n", 
+		//	curFunc.Length, curFunc.Loads, curFunc.Stores, curFunc.FCalls, curFunc.Branch, curFunc.Moves);
+		for(patitr = 0; patitr < CurFPatternsListLen; ++patitr)
 		{
-			if(AllFPatterns[patitr].patmode == PCODE_TRI && TRIGame == TRI_NONE)
-				continue;
-			if(AllFPatterns[patitr].patmode == PCODE_EXI && DisableEXIPatch)
-				continue;
-			if (AllFPatterns[patitr].patmode == PCODE_DATEL && Datel == 0)
-				continue;
-			if (AllFPatterns[patitr].patmode == PCODE_SI && DisableSIPatch)
-				continue;
-			FuncPattern *CurPatterns = AllFPatterns[patitr].pat;
-			u32 CurPatternsLen = AllFPatterns[patitr].patlen;
+			FuncPattern *CurPatterns = CurFPatternsList[patitr].pat;
+			u32 CurPatternsLen = CurFPatternsList[patitr].patlen;
 			bool patfound = false;
 			for( j=0; j < CurPatternsLen; ++j )
 			{
@@ -2194,14 +2168,12 @@
 				if( CurPatterns[j].Found ) //Skip already found patches
 					continue;
 
-				if( CPattern( &fp, &(CurPatterns[j]) ) )
+				if( CPattern( &curFunc, &(CurPatterns[j]) ) )
 				{
 					u32 FOffset = (u32)Buffer + i;
 
 					CurPatterns[j].Found = FOffset;
-					//#ifdef DEBUG_PATCH
 					//dbgprintf("Patch:[%s] found (0x%08X)\r\n", CurPatterns[j].Name, FOffset );
-					//#endif
 
 					switch( CurPatterns[j].PatchLength )
 					{
@@ -2240,12 +2212,17 @@
 						{
 							if(read32(FOffset + 0x40) == 0x801E0004)
 							{
-								PatchBL(GXLoadTlutAddr, FOffset + 0x40);
-								if(read32(FOffset + 0x6C) == 0x801E0004)
-									PatchBL(GXLoadTlutAddr, FOffset + 0x6C);
-								else if(read32(FOffset + 0x70) == 0x801E0004)
-									PatchBL(GXLoadTlutAddr, FOffset + 0x70);
-								printpatchfound(CurPatterns[j].Name, CurPatterns[j].Type, FOffset);
+								if(TITLE_ID == 0x47424F) //Burnout
+								{
+									PatchBL(GXLoadTlutAddr, FOffset + 0x40);
+									if(read32(FOffset + 0x6C) == 0x801E0004)
+										PatchBL(GXLoadTlutAddr, FOffset + 0x6C);
+									else if(read32(FOffset + 0x70) == 0x801E0004)
+										PatchBL(GXLoadTlutAddr, FOffset + 0x70);
+									printpatchfound(CurPatterns[j].Name, CurPatterns[j].Type, FOffset);
+								}
+								else
+									dbgprintf("Patch:[GXLoadTlut] skipped (0x%08X)\r\n", FOffset);
 							}
 							else
 								CurPatterns[j].Found = 0; // False hit
@@ -2261,9 +2238,7 @@
 								}
 								else
 								{
-									#ifdef DEBUG_PATCH
 									dbgprintf("Patch:[__ARHandler] skipped (0x%08X)\r\n", FOffset);
-									#endif
 								}
 							}
 							else
@@ -2332,8 +2307,13 @@
 						} break;
 						case FCODE___OSReadROM:	//	__OSReadROM
 						{
-							printpatchfound(CurPatterns[j].Name, CurPatterns[j].Type, FOffset);
-							memcpy( (void*)FOffset, __OSReadROM, sizeof(__OSReadROM) );
+							if(read32(FOffset+0x80) == 0x38A00004)
+							{
+								memcpy((void*)FOffset, ReadROM, ReadROM_size);
+								printpatchfound(CurPatterns[j].Name, CurPatterns[j].Type, FOffset);
+							}
+							else
+								CurPatterns[j].Found = 0;
 						} break;
 						case FCODE___OSInitAudioSystem_A:
 						{
@@ -2349,9 +2329,7 @@
 						{
 							if((GAME_ID) == 0x475A4D50) //dont know why needed
 							{
-								#ifdef DEBUG_PATCH
 								dbgprintf("Patch:[__GXSetVAT] skipped (0x%08X)\r\n", FOffset);
-								#endif
 								break;
 							}
 							u32 BaseReg = 0, L1 = 0, L2 = 0, L3 = 0, RegLoc = 0;
@@ -2423,9 +2401,7 @@
 										if( reg == 3 )
 										{
 											value = read32( FOffset + off ) & 0x0000FFFF;
-											#ifdef DEBUG_PATCH
 											//dbgprintf("lis:%08X value:%04X\r\n", FOffset+off, value );
-											#endif
 										}
 									}
 								}
@@ -2440,9 +2416,7 @@
 											if(dst == 0)
 											{
 												valueB = read32( FOffset + off ) & 0x0000FFFF;
-												#ifdef DEBUG_PATCH
 												//dbgprintf("addi:%08X value:%04X\r\n", FOffset+off, valueB);
-												#endif
 												break;
 											}
 											else //false hit
@@ -2500,7 +2474,8 @@
 						} break;
 						case FCODE_ReadROM:
 						{
-							if(read32(FOffset+0x3C) == 0x3BE00100)
+							if(read32(FOffset+0x3C) == 0x3BE00100 || 
+								read32(FOffset+0x44) == 0x38800100)
 							{
 								memcpy((void*)FOffset, ReadROM, ReadROM_size);
 								printpatchfound(CurPatterns[j].Name, CurPatterns[j].Type, FOffset);
@@ -2525,9 +2500,7 @@
 							}
 							else if(read32(FOffset + 0x24) == 0x38604000 || read32(FOffset + 0x2C) == 0x38604000)
 							{
-								#ifdef DEBUG_PATCH
 								dbgprintf("Patch:[ARInit] skipped (0x%08X)\r\n", FOffset);
-								#endif
 							}
 							else
 								CurPatterns[j].Found = 0;
@@ -2560,7 +2533,7 @@
 									 (TITLE_ID) == 0x474D4F ||	// Micro Machines
 									 (TITLE_ID) == 0x475355 ||	// Superman: Shadow of Apokolips
 									 (TITLE_ID) == 0x474859 ||	// Disney's The Haunted Mansion
-									 (TITLE_ID) == 0x443737 )	// Multi-Game Demo Disc 18
+									 DemoNeedsPaperMarioDMA())
 							{
 								memcpy( (void*)FOffset, ARStartDMA_PM, ARStartDMA_PM_size );
 							}
@@ -2596,9 +2569,7 @@
 						{
 							if( ConfigGetConfig( NIN_CFG_DEBUGGER ) || !ConfigGetConfig(NIN_CFG_OSREPORT) )
 							{
-								#ifdef DEBUG_PATCH
 								dbgprintf("Patch:[patch_fwrite_Log] skipped (0x%08X)\r\n", FOffset);
-								#endif
 								break;
 							}
 
@@ -2606,9 +2577,7 @@
 							{
 								if( CurPatterns[j].Patch == patch_fwrite_GC ) // patch_fwrite_Log works fine
 								{
-									#ifdef DEBUG_PATCH
 									dbgprintf("Patch:[patch_fwrite_GC] skipped (0x%08X)\r\n", FOffset);
-									#endif
 									break;
 								}
 							}
@@ -2739,6 +2708,16 @@
 								}
 							}
 						} break;
+						case FCODE___PADSetSamplingRate:
+						{
+							if(read32(FOffset+0x60) != 0x40800014 || read32(FOffset+0x8C) != 0xA003206C)
+							{
+								CurPatterns[j].Found = 0; // False hit
+								break;
+							}
+							write32(FOffset+0x60, 0x60000000); //anti-crash
+							printpatchfound(CurPatterns[j].Name, CurPatterns[j].Type, FOffset);
+						} break;
 						case FCODE_PADControlAllMotors:
 						{
 							u32 CheckOffset = CurPatterns[j].Length - 0x24;
@@ -2812,8 +2791,15 @@
 							if(useipl == 1) break;
 							if(read32(FOffset + 0xF8) == 0x2C000000)
 							{
-								PatchBL( __DSPHandlerAddr, (FOffset + 0xF8) );
-								printpatchfound(CurPatterns[j].Name, CurPatterns[j].Type, FOffset);
+								if(DSPHandlerNeeded)
+								{
+									PatchBL( __DSPHandlerAddr, (FOffset + 0xF8) );
+									printpatchfound(CurPatterns[j].Name, CurPatterns[j].Type, FOffset);
+								}
+								else
+								{
+									dbgprintf("Patch:[__DSPHandler] skipped (0x%08X)\r\n", FOffset);
+								}
 							}
 							else
 								CurPatterns[j].Found = 0;
@@ -2835,9 +2821,7 @@
 								dbgprintf("PSO:Extract Addr:0x%08X\r\n", NewAddr);
 								write32(PRS_EXTRACT, NewAddr);
 								sync_after_write((void*)PRS_EXTRACT, 0x20);
-#ifdef DEBUG_PATCH
 								printpatchfound("SwitcherPrs", NULL, OrigAddr);
-#endif
 								PatchBL(SwitcherPrsAddr, OrigAddr);
 							}
 						} break;
@@ -2847,9 +2831,7 @@
 							u32 OrigAddr = FOffset + 0xAC;
 							if ((read32(OrigAddr - 8) == 0x4C00012C) && (read32(OrigAddr) == 0x4E800021))  // isync and blrl
 							{
-#ifdef DEBUG_PATCH
 								printpatchfound("PSO", "FakeEntry", OrigAddr);
-#endif
 								PatchBL(PATCH_OFFSET_ENTRY, OrigAddr);
 							}
 							else if (read32(FOffset + 0x38) == 0x4E800421) // bctrl
@@ -2861,16 +2843,12 @@
 									AppLoaderSize &= 0x0000FFFF;
 								else
 									AppLoaderSize = 0;
-#ifdef DEBUG_PATCH
 								printpatchfound("Datel", "FakeEntry", FOffset + 0x38);
 								printpatchfound("Datel", "FakeEntrySize", AppLoaderSize);
-#endif
 							}
 							else if (((u32)Buffer == 0x01300000) && (read32(FOffset + 0xA0) == 0x4C00012C) && (read32(FOffset + 0xC8) == 0x4E800021))  // isync and blrl
 							{
-#ifdef DEBUG_PATCH
 								printpatchfound("Datel", "FakeEntry", FOffset + 0xC8);
-#endif
 								PatchBL(PATCH_OFFSET_ENTRY, FOffset + 0xC8);
 							}
 						} break;
@@ -2881,12 +2859,11 @@
 								if ((  (TITLE_ID) != 0x474D53  // Super Mario Sunshine
 									&& (TITLE_ID) != 0x474C4D  // Luigis Mansion
 									&& (TITLE_ID) != 0x475049  // Pikmin
-									&& (TITLE_ID) != 0x474C56) // Chronicles of Narnia
+									&& (TITLE_ID) != 0x474C56  // Chronicles of Narnia
+									&& !DemoNeedsPostRequest())
 									|| useipl == 1)
 								{
-									#ifdef DEBUG_PATCH
 									dbgprintf("Patch:[ARQPostRequest] skipped (0x%08X)\r\n", FOffset);
-									#endif
 									break;
 								}
 							}
@@ -2898,9 +2875,7 @@
 							}
 							if( (CurPatterns[j].Length >> 16) == (FCODES  >> 16) )
 							{
-								#ifdef DEBUG_PATCH
 								dbgprintf("Patch:Unhandled dead case:%08X\r\n", CurPatterns[j].Length );
-								#endif
 							}
 							else
 							{
@@ -2918,9 +2893,7 @@
 							{
 								if( !CurPatterns[k].Found )		// Don't overwrite the offset!
 									CurPatterns[k].Found = -1;	// Usually this holds the offset, to determinate it from a REALLY found pattern we set it -1 which still counts a logical TRUE
-								#ifdef DEBUG_PATCH
 								//dbgprintf("Setting [%s] to found!\r\n", CurPatterns[k].Name );
-								#endif
 							}
 						}
 					}
@@ -2958,107 +2931,68 @@
 			PatchWideMulti(MTXLightPerspectiveOffset + 0x24, 27);
 		}
 	}
-	if(DebuggerHook)
+	if(DebuggerHook || DebuggerHook2 || DebuggerHook3)
 	{
-		/* Freekstyle needs Hook into GXSetDrawDone */
-		//if((GAME_ID) == 0x47464B45)
-		//	DebuggerHook = 0x123098;
-
-		u32 DBGSize;
-
-		FIL fs;
-		if( f_open_char( &fs, "/sneek/kenobiwii.bin", FA_OPEN_EXISTING|FA_READ ) != FR_OK )
+		//copy into dedicated space
+		memcpy( (void*)0x1800, codehandler, codehandler_size );
+		//copy game id for debugger
+		memcpy( (void *)0x1800, (void*)0, 6 );
+		//set custom cheats location
+		W16(0x1CDE, 0x9300);
+		W16(0x1CE2, 0x6000);
+		W16(0x1F5A, 0x9300);
+		W16(0x1F5E, 0x6000);
+		//make sure to clear code area beforeahand
+		memset((void*)0x13006000, 0, 0x2000);
+		sync_after_write((void*)0x13006000, 0x2000);
+		//copy in gct file if requested
+		if( ConfigGetConfig( NIN_CFG_CHEATS ) && TRIGame != TRI_SB && useipl == 0 )
 		{
-			#ifdef DEBUG_PATCH
-			dbgprintf( "Patch:Could not open:\"%s\", this file is required for debugging!\r\n", "/sneek/kenobiwii.bin" );
-			#endif
-		}
-		else if(fs.fsize > (POffset - 0x1800))
-		{
-			#ifdef DEBUG_PATCH
-			dbgprintf("Patch:No More Memory for kenobiwii left!\r\n");
-			#endif
-			f_close(&fs);
-		}
-		else
-		{
-			if( fs.fsize != 0 )
+			FIL CodeFD;
+			if( Check_Cheats() == 0 && f_open_char( &CodeFD, cheatPath, FA_OPEN_EXISTING|FA_READ ) == FR_OK )
 			{
-				DBGSize = fs.fsize;
-				void *KMem = malloc(fs.fsize);
-				//Read file to memory
-				s32 ret = f_read( &fs, KMem, fs.fsize, &read );
-				if( ret != FR_OK )
+				if( CodeFD.obj.objsize > 0x2000 )
 				{
-					#ifdef DEBUG_PATCH
-					dbgprintf( "Patch:Could not read:\"%s\":%d\r\n", "/sneek/kenobiwii.bin", ret );
-					#endif
-					free( KMem );
-					f_close( &fs );
+					dbgprintf( "Patch:Cheatfile is too large, it must not be larger than 8KB!\r\n" );
 				}
 				else
 				{
-					f_close( &fs );
-					memcpy( (void*)0x1800, KMem, DBGSize );
-					free( KMem );
-					if( IsWiiU )
+					void *CMem = malloc(CodeFD.obj.objsize);
+					if( f_read( &CodeFD, CMem, CodeFD.obj.objsize, &read ) == FR_OK )
 					{
-						*(vu32*)(P2C(*(vu32*)0x1808)) = 0;
+						memcpy((void*)0x13006000, CMem, CodeFD.obj.objsize);
+						sync_after_write((void*)0x13006000, 0x2000);
+						dbgprintf("Patch:Copied %s to memory\r\n", cheatPath);
 					}
 					else
 					{
-						if( ConfigGetConfig(NIN_CFG_DEBUGWAIT) )
-							*(vu32*)(P2C(*(vu32*)0x1808)) = 1;
-						else
-							*(vu32*)(P2C(*(vu32*)0x1808)) = 0;
+						dbgprintf("Patch:Failed to read %s\r\n", cheatPath);
 					}
-
-					memcpy( (void *)0x1800, (void*)0, 6 );
-
-					PatchB( 0x18A8, DebuggerHook );
-
-					if( ConfigGetConfig( NIN_CFG_CHEATS ) && TRIGame != TRI_SB && useipl == 0 )
-					{
-						FIL CodeFD;
-						if( f_open_char( &CodeFD, cheatPath, FA_OPEN_EXISTING|FA_READ ) == FR_OK )
-						{
-							if( CodeFD.fsize > (POffset - (0x1800+DBGSize-8)) )
-							{
-								#ifdef DEBUG_PATCH
-								dbgprintf( "Patch:Cheatfile is too large, it must not be larger than %d bytes!\r\n", (POffset - (0x1800+DBGSize-8)) );
-								#endif
-							}
-							else
-							{
-								void *CMem = malloc(CodeFD.fsize);
-								if( f_read( &CodeFD, CMem, CodeFD.fsize, &read ) == FR_OK )
-								{
-									memcpy((void*)(0x1800+DBGSize-8), CMem, CodeFD.fsize);
-									#ifdef DEBUG_PATCH
-									dbgprintf("Patch:Copied %s to memory\r\n", cheatPath);
-									#endif
-									//write32( 0x1804, 1 ); //???
-								}
-								else
-								{
-									#ifdef DEBUG_PATCH
-									dbgprintf("Patch:Failed to read %s\r\n", cheatPath);
-									#endif
-								}
-								free( CMem );
-							}
-							f_close( &CodeFD );
-						}
-						else
-						{
-							#ifdef DEBUG_PATCH
-							dbgprintf("Patch:Failed to open/find cheat file:\"%s\"\r\n", cheatPath );
-							#endif
-						}
-					}
+					free( CMem );
 				}
+				f_close( &CodeFD );
 			}
+			else
+			{
+				dbgprintf("Patch:Failed to open/find cheat file:\"%s\"\r\n", cheatPath );
+			}
 		}
+		//set if debugger is requested
+		if( IsWiiU )
+		{
+			*(vu32*)(P2C(*(vu32*)0x1808)) = 0;
+		}
+		else
+		{
+			if( ConfigGetConfig(NIN_CFG_DEBUGWAIT) )
+				*(vu32*)(P2C(*(vu32*)0x1808)) = 1;
+			else
+				*(vu32*)(P2C(*(vu32*)0x1808)) = 0;
+		}
+		//setup jump to codehandler
+		if(DebuggerHook) PatchB( 0x18A8, DebuggerHook );
+		if(DebuggerHook2) PatchB( 0x18A8, DebuggerHook2 );
+		if(DebuggerHook3) PatchB( 0x18A8, DebuggerHook3 );
 	}
 	free(hash);
 	free(SHA1i);
@@ -3065,9 +2999,7 @@
 
 	/*if( ((PatchCount & (1|2|4|8|2048)) != (1|2|4|8|2048)) )
 	{
-		#ifdef DEBUG_PATCH
 		dbgprintf("Patch:Could not apply all required patches!\r\n");
-		#endif
 		Shutdown();
 	}*/
 
@@ -3076,18 +3008,10 @@
 	//if( (PatchCount & FPATCH_DSP_ROM) == 0 )
 	//	dbgprintf("Patch:Unknown DSP ROM\r\n");
 
-	for(patitr = 0; patitr < PCODE_MAX; ++patitr)
+	for(patitr = 0; patitr < CurFPatternsListLen; ++patitr)
 	{
-		if(AllFPatterns[patitr].patmode == PCODE_TRI && TRIGame == TRI_NONE)
-			continue;
-		if(AllFPatterns[patitr].patmode == PCODE_EXI && DisableEXIPatch)
-			continue;
-		if(AllFPatterns[patitr].patmode == PCODE_DATEL && Datel == 0)
-			continue;
-		if(AllFPatterns[patitr].patmode == PCODE_SI && DisableSIPatch)
-			continue;
-		FuncPattern *CurPatterns = AllFPatterns[patitr].pat;
-		u32 CurPatternsLen = AllFPatterns[patitr].patlen;
+		FuncPattern *CurPatterns = CurFPatternsList[patitr].pat;
+		u32 CurPatternsLen = CurFPatternsList[patitr].patlen;
 		for( j=0; j < CurPatternsLen; ++j )
 		{
 			if(!CurPatterns[j].Found)
@@ -3101,6 +3025,15 @@
 	#endif
 	PatchState = PATCH_STATE_DONE;
 
+	//Sonic R NTSC Old Debug Prints
+	/*if(read32(0x7D49C) == 0x9421FF90 && read32(0x7D5A8) == 0x9421FF90)
+	{
+		memcpy((void*)0x7D49C, OSReportDM, sizeof(OSReportDM));
+		sync_after_write((void*)0x7D49C, sizeof(OSReportDM));
+		memcpy((void*)0x7D5A8, OSReportDM, sizeof(OSReportDM));
+		sync_after_write((void*)0x7D5A8, sizeof(OSReportDM));
+		
+	}*/
 	/*if(GAME_ID == 0x47365145) //Megaman Collection
 	{
 		memcpy((void*)0x5A110, OSReportDM, sizeof(OSReportDM));
@@ -3124,23 +3057,29 @@
 		if(read32(0x1341514) == 0x38600001)
 		{
 			write32(0x1341514, 0x38600000);
-			#ifdef DEBUG_PATCH
-			dbgprintf("Patch:Patched Gamecube NTSC IPL\r\n");
-			#endif
+			//fix up dsp init for cardunlock
+			write32(0x134F28C, 0x64001000); //oris r0, r0, 0x1000
+			dbgprintf("Patch:Patched Gamecube NTSC IPL v1.0\r\n");
 		}
+		else if(read32(0x13693D4) == 0x38600001)
+		{
+			write32(0x13693D4, 0x38600000);
+			dbgprintf("Patch:Patched Gamecube NTSC IPL v1.1\r\n");
+		}
+		else if(read32(0x13702A0) == 0x38600001)
+		{
+			write32(0x13702A0, 0x38600000);
+			dbgprintf("Patch:Patched Gamecube NTSC IPL v1.2\r\n");
+		}
 		else if(read32(0x136C9B4) == 0x38600001)
 		{
 			write32(0x136C9B4, 0x38600000);
-			#ifdef DEBUG_PATCH
 			dbgprintf("Patch:Patched Gamecube PAL IPL v1.0\r\n");
-			#endif
 		}
 		else if(read32(0x1373618) == 0x38600001)
 		{
 			write32(0x1373618, 0x38600000);
-			#ifdef DEBUG_PATCH
 			dbgprintf("Patch:Patched Gamecube PAL IPL v1.2\r\n");
-			#endif
 		}
 	}
 	else if( TITLE_ID == 0x474256 )	// Batman Vengeance
@@ -3148,15 +3087,11 @@
 		// Skip Usage of EXI Channel 2
 		if(write32A(0x0018B5DC, 0x60000000, 0x4801D6E1, 0))
 		{
-			#ifdef DEBUG_PATCH
 			dbgprintf("Patch:Patched Batman Vengeance NTSC-U\r\n");
-			#endif
 		}
 		else if(write32A(0x0015092C, 0x60000000, 0x4801D599, 0))
 		{
-			#ifdef DEBUG_PATCH
 			dbgprintf("Patch:Patched Batman Vengeance PAL\r\n");
-			#endif
 		}
 	}
 	else if( TITLE_ID == 0x474336 )	// Pokemon Colosseum
@@ -3166,24 +3101,24 @@
 		{
 			if(write32A(0x000B0D88, 0x38600001, 0x4801C0B1, 0))
 			{
-				#ifdef DEBUG_PATCH
 				dbgprintf("Patch:Patched Pokemon Colosseum NTSC-J\r\n");
-				#endif
 			}
 			else if(write32A(0x000B30DC, 0x38600001, 0x4801C2ED, 0))
 			{
-				#ifdef DEBUG_PATCH
 				dbgprintf("Patch:Patched Pokemon Colosseum NTSC-U\r\n");
-				#endif
 			}
 			else if(write32A(0x000B66DC, 0x38600001, 0x4801C2ED, 0))
 			{
-				#ifdef DEBUG_PATCH
 				dbgprintf("Patch:Patched Pokemon Colosseum PAL\r\n");
-				#endif
 			}
 		}
 	}
+	else if( GAME_ID == 0x5043534A ) // Colosseum Bonus
+	{
+		// Memory Card inserted hack
+		if( DisableEXIPatch == 0 && write32A(0x000B0474, 0x38600001, 0x4801C0B5, 0) )
+			dbgprintf("Patch:Patched Pokemon Colosseum Bonus NTSC-J\r\n");
+	}
 	else if( TITLE_ID == 0x475A4C )	// GZL=Wind Waker
 	{
 		//Anti FrameDrop Panic
@@ -3193,9 +3128,7 @@
 			//	write32( 0x03945B0, 0x8039408C );	// Test menu
 			write32(0x00221A28, 0x48000034);
 			write32(0x00256424, 0x48000068);
-			#ifdef DEBUG_PATCH
 			dbgprintf("Patch:Patched WW NTSC-U\r\n");
-			#endif
 		}
 		/* NTSC-U Demo */
 		if(read32(0x0021D33C) == 0x40820034 && read32(0x00251EF8) == 0x41820068)
@@ -3202,9 +3135,7 @@
 		{
 			write32(0x0021D33C, 0x48000034);
 			write32(0x00251EF8, 0x48000068);
-			#ifdef DEBUG_PATCH
 			dbgprintf("Patch:Patched WW NTSC-U Demo\r\n");
-			#endif
 		}
 		/* PAL Final */
 		if(read32(0x001F1FE0) == 0x40820034 && read32(0x0025B5C4) == 0x41820068)
@@ -3211,9 +3142,7 @@
 		{
 			write32(0x001F1FE0, 0x48000034);
 			write32(0x0025B5C4, 0x48000068);
-			#ifdef DEBUG_PATCH
 			dbgprintf("Patch:Patched WW PAL\r\n");
-			#endif
 		}
 		/* NTSC-J Final */
 		if(read32(0x0021EDD4) == 0x40820034 && read32(0x00253BCC) == 0x41820068)
@@ -3220,9 +3149,7 @@
 		{
 			write32(0x0021EDD4, 0x48000034);
 			write32(0x00253BCC, 0x48000068);
-			#ifdef DEBUG_PATCH
 			dbgprintf("Patch:Patched WW NTSC-J\r\n");
-			#endif
 		}
 		/*if( ConfigGetConfig( NIN_CFG_OSREPORT ) )
 		{
@@ -3235,14 +3162,108 @@
 		//Fix a Bad Jump in the code
 		if(write32A(0x0018A764, 0x4182021C, 0x41820018, 0))
 		{
-			#ifdef DEBUG_PATCH
 			dbgprintf("Patch:Patched X-Men Legends 2 NTSC-U\r\n");
-			#endif
 		}
 	}
+	else if( TITLE_ID == 0x474159 ) // Midway Arcarde Treasures 2
+	{
+		//Skip over __AXOutInit calling AIStartDMA
+		if(MAT2patched == 0 && write32A(0x906D0, 0x60000000, 0x4BFFB6D9, 0))
+		{
+			//needs patch on first bootup, no idea why
+			MAT2patched = 1;
+			//UnkReport
+			//PatchB(0x7C964,0x92F50);
+			//call AIStartDMA after NGC_SoundInit
+			PatchB(0x8BDA8,0x4F1B8);
+			dbgprintf("Patch:Patched Midway Arcade Treasures 2 NTSC-U\r\n");
+		}
+	}
+	else if( TITLE_ID == 0x475051 ) // Powerpuff Girls
+	{
+		// Audio Stream force DMA to get Video Sound
+		if(read32(0xF33D8) == 0x4E800020 && read32(0xF3494) == 0x4E800020)
+		{
+			//UnkReport
+			//memcpy((void*)0xDF870, OSReportDM, sizeof(OSReportDM));
+			//sync_after_write((void*)0xDF870, sizeof(OSReportDM));
+			//OSReport
+			//memcpy((void*)0xE84D4, OSReportDM, sizeof(OSReportDM));
+			//sync_after_write((void*)0xE84D4, sizeof(OSReportDM));
+			//Call AXInit after DVDPrepareStreamAbsAsync
+			PatchB(0xF9E80, 0xF33D8);
+			//Call AXQuit after DVDCancelStreamAsync
+			PatchB(0xF9EB4, 0xF3494);
+			dbgprintf("Patch:Patched Powerpuff Girls NTSC-U\r\n");
+		}
+		else if(read32(0xF3EC0) == 0x4E800020 && read32(0xF3F7C) == 0x4E800020)
+		{
+			//Call AXInit after DVDPrepareStreamAbsAsync
+			PatchB(0xFB340, 0xF3EC0);
+			//Call AXQuit after DVDCancelStreamAsync
+			PatchB(0xFB3B0, 0xF3F7C);
+			dbgprintf("Patch:Patched Powerpuff Girls PAL\r\n");
+		}
+	}
+	else if( TITLE_ID == 0x47505A ) // Nintendo Puzzle Collection
+	{
+		if(read32(0x6A28) == 0x7C7F282E && read32(0x6AF8) == 0x7C1F002E)
+		{
+			//Dont load compressed game .rel files but the uncompressed 
+			//ones to patch the timers without any further hooks
+			write32(0x6A28, 0x38600000);
+			write32(0x6AF8, 0x38000000);
+			dbgprintf("Patch:Patched Nintendo Puzzle Collection NTSC-J\r\n");
+		}
+	}
+	else if( TITLE_ID == 0x47454F ) // Capcom vs. SNK 2 EO
+	{
+		//fix for force progressive
+		if(write32A(0x1137C, 0x60000000, 0xB0010010, 0))
+		{
+			dbgprintf("Patch:Patched Capcom vs. SNK 2 EO NTSC-U\r\n");
+		}
+	}
+	else if( TITLE_ID == 0x475038 ) // Pac-Man World 3
+	{
+		//fix for force progressive
+		if(write32A(0x28D2A8, 0x48000010, 0x41820010, 0))
+		{
+			dbgprintf("Patch:Patched Pac-Man World 3 NTSC-U\r\n");
+		}
+	}
+	else if( TITLE_ID == 0x475134 ) // SpongeBob SquarePants CFTKK
+	{
+		//fix for force progressive
+		if(write32A(0x23007C, 0x48000010, 0x41820010, 0))
+		{
+			dbgprintf("Patch:Patched SpongeBob SquarePants CFTKK NTSC-U\r\n");
+		}
+	}
+	else if( TITLE_ID == 0x47414C ) // Super Smash Bros Melee
+	{
+		//fix for video mode breaking
+		if(write32A(0x365DB0, 0x38A00280, 0xA0A7000E, 0))
+		{
+			dbgprintf("Patch:Patched Super Smash Bros Melee v1.00\r\n");
+		}
+		else if(write32A(0x366F84, 0x38A00280, 0xA0A7000E, 0))
+		{
+			dbgprintf("Patch:Patched Super Smash Bros Melee v1.01\r\n");
+		}
+		else if(write32A(0x367C64, 0x38A00280, 0xA0A7000E, 0))
+		{
+			dbgprintf("Patch:Patched Super Smash Bros Melee v1.02\r\n");
+		}
+	}
 	PatchStaticTimers();
 
 	sync_after_write( Buffer, Length );
+
+//	UseReadLimit = 1;
+//	if(RealDiscCMD != 0 || TRIGame != TRI_NONE || IsN64Emu 
+//			|| ConfigGetConfig(NIN_CFG_REMLIMIT))
+//		UseReadLimit = 0;
 }
 
 void PatchInit()
@@ -3301,14 +3322,8 @@
 	// Reset SI status
 	SIInit();
 	u32 SiInitSet = 0;
-	//Reset GCAM status
-	GCAMInit();
-	//F-Zero AX uses Clean CARD after 150 uses
-	if(TRIGame == TRI_AX && TRI_BackupAvailable == 1)
-	{
-		sync_before_read(OurBase, 0x20);
-		GCAMCARDCleanStatus(R16((u32)OurBase+0x16));
-	}
+	// Reset Triforce
+	TRIReset();
 	// Didn't look for why PMW2 requires this.  ToDo
 	if ((TITLE_ID) == 0x475032 || TRIGame) // PacMan World 2 and Triforce hack
 		SiInitSet = 1;
@@ -3341,58 +3356,42 @@
 s32 Check_Cheats()
 {
 #ifdef CHEATS
-	if((ConfigGetConfig(NIN_CFG_CHEATS)) ||
-	  ((!(IsWiiU)) && ConfigGetConfig(NIN_CFG_DEBUGGER) ))
+	if( ConfigGetConfig(NIN_CFG_CHEAT_PATH) )
 	{
-		if( !fileExist("/sneek/kenobiwii.bin") )
+		char *cpath = ConfigGetCheatPath();
+		if (cpath[0] != 0)
 		{
-			#ifdef DEBUG_PATCH
-			dbgprintf( "Patch:Could not open /sneek/kenobiwii.bin, this file is required for debugging!\r\n" );
-			#endif
-			return -1;
-		}
-
-		if( ConfigGetConfig( NIN_CFG_CHEATS ) )
-		{
-			if( ConfigGetConfig(NIN_CFG_CHEAT_PATH) )
+			if( fileExist(cpath) )
 			{
-				char *cpath = ConfigGetCheatPath();
-				if (cpath[0] != 0)
-				{
-					if( fileExist(cpath) )
-					{
-						memcpy(cheatPath, cpath, 255);
-						return 0;
-					}
-				}
+				memcpy(cheatPath, cpath, 255);
+				return 0;
 			}
-			u32 i;
-			char* DiscName = ConfigGetGamePath();
-			//search the string backwards for '/'
-			for( i=strlen(DiscName); i > 0; --i )
-				if( DiscName[i] == '/' )
-					break;
-			i++;
-			memcpy(cheatPath, DiscName, i);
-			//new version paths
-			_sprintf(cheatPath+i, "game.gct");
-			if( fileExist(cheatPath) )
-				return 0;
-			sync_before_read((void*)0x0, 0x20);
-			_sprintf(cheatPath+i, "%.6s.gct", (char*)0x0);
-			if( fileExist(cheatPath) )
-				return 0;
-			//gecko path
-			_sprintf(cheatPath, "/codes/%.6s.gct", (char*)0x0);
-			if( fileExist(cheatPath) )
-				return 0;
-			//oldschool backup path
-			_sprintf(cheatPath, "/games/%.6s/%.6s.gct", (char*)0x0, (char*)0x0);
-			if( fileExist(cheatPath) )
-				return 0;
-			return -2;
 		}
 	}
+	u32 i;
+	char* DiscName = ConfigGetGamePath();
+	//search the string backwards for '/'
+	for( i=strlen(DiscName); i > 0; --i )
+		if( DiscName[i] == '/' )
+			break;
+	i++;
+	memcpy(cheatPath, DiscName, i);
+	//new version paths
+	_sprintf(cheatPath+i, "game.gct");
+	if( fileExist(cheatPath) )
+		return 0;
+	sync_before_read((void*)0x0, 0x20);
+	_sprintf(cheatPath+i, "%.6s.gct", (char*)0x0);
+	if( fileExist(cheatPath) )
+		return 0;
+	//gecko path
+	_sprintf(cheatPath, "/codes/%.6s.gct", (char*)0x0);
+	if( fileExist(cheatPath) )
+		return 0;
+	//oldschool backup path
+	_sprintf(cheatPath, "/games/%.6s/%.6s.gct", (char*)0x0, (char*)0x0);
+	if( fileExist(cheatPath) )
+		return 0;
 #endif
-	return 0;
+	return -1;
 }
Index: kernel/Patch.h
===================================================================
--- kernel/Patch.h	(revision 334)
+++ kernel/Patch.h	(working copy)
@@ -77,6 +77,7 @@
 
 void PatchB( u32 dst, u32 src );
 void PatchBL( u32 dst, u32 src );
+u32 PatchCopy(const u8 *PatchPtr, const u32 PatchSize);
 s32 PatchFunc( char *ptr );
 void PatchFuncInterface( char *dst, u32 Length );
 void PatchPatchBuffer(char *dst);
Index: kernel/PatchCodes.h
===================================================================
--- kernel/PatchCodes.h	(revision 334)
+++ kernel/PatchCodes.h	(working copy)
@@ -11,12 +11,9 @@
 #include "asm/EXIGetID.h"
 #include "asm/__CARDReadStatus.h"
 #include "asm/__CARDClearStatus.h"
-#include "asm/__CARDEraseSector.h"
 #include "asm/ReadROM.h"
 
 #include "asm/ARQPostRequest.h"
-#include "asm/ARInit.h"
-#include "asm/ARGetBaseAddress.h"
 #include "asm/ARStartDMA.h"
 #include "asm/ARStartDMA_PM.h"
 #include "asm/ARStartDMA_TC.h"
@@ -35,16 +32,7 @@
 #include "asm/PADControlAllMotors.h"
 #include "asm/PADControlMotor.h"
 #include "asm/PADIsBarrel.h"
-#include "asm/DVDInquiryAsync.h"
-#include "asm/DVDSeekAbsAsyncPrio.h"
 #include "asm/GCAMSendCommand.h"
-#include "asm/PADReadGP.h"
-#include "asm/PADReadF.h"
-#include "asm/PADReadVS.h"
-#include "asm/CheckTestMenu.h"
-#include "asm/CheckTestMenuVS.h"
-#include "asm/RestoreSettingsAX.h"
-#include "asm/RestoreSettingsVS.h"
 #include "asm/patch_fwrite_Log.h"
 #include "asm/patch_fwrite_GC.h"
 #include "asm/FakeRSWLoad.h"
@@ -63,6 +51,10 @@
 #include "asm/DatelTimer.h"
 #include "asm/SonicRidersCopy.h"
 
+#include "asm/MajoraAudioStream.h"
+#include "asm/MajoraLoadRegs.h"
+#include "asm/MajoraSaveRegs.h"
+
 unsigned char SRAM[64] =
 {
     0x42, 0x8B,
@@ -116,7 +108,7 @@
         0x38600000,     //  li		r3, 0
         0x4E800020      //  blr
 };
-
+#ifndef AUDIOSTREAM
 // Audio streaming replacement functions copied from Swiss r92
 const u32 DVDLowAudioStatusNULL[17] = {
         // execute function(1); passed in on r4
@@ -166,7 +158,7 @@
         0x38210040,     //  addi        sp, sp, 64
         0x4E800020      //  blr
 };
-
+#endif
 //function header is good enough to verify
 const u32 PADIsBarrelOri[] = {
 		0x2C030000,		// cmpwi	r3,0
Index: kernel/patches.c
===================================================================
--- kernel/patches.c	(revision 334)
+++ kernel/patches.c	(working copy)
@@ -3,7 +3,7 @@
 Nintendont (Kernel) - Playing Gamecubes in Wii mode on a Wii U
 
 Copyright (C) 2013  crediar
-Copyright (C) 2014  FIX94
+Copyright (C) 2014 - 2016 FIX94
 
 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
@@ -33,7 +33,10 @@
 	FPATCH_CARDUnlock = 1<<5,
 	FPATCH_OSSleepThread = 1<<6,
 	FPATCH_VideoModes = 1<<7,
-	FPATCH_DSP_ROM = 1<<8
+	FPATCH_DSP_ROM = 1<<8,
+	FPATCH_GXBegin = 1<<9,
+	FPATCH_GXDrawDone = 1<<10,
+	FPATCH_getTiming = 1<<11,
 };
 
 enum
@@ -89,6 +92,7 @@
 										//EXIntrruptHandler_B,	
 										//EXIntrruptHandler_C,
 	FCODE_PADRead,
+	FCODE___PADSetSamplingRate,
 	FCODE_PADControlAllMotors,
 	FCODE_PADControlMotor,
 	FCODE_PADIsBarrel,
@@ -143,11 +147,12 @@
 	FGROUP_CARDStat,
 	FGROUP_OSGetResetState,
 	FGROUP___OSInitAudioSystem,
+	FGROUP_ReadROM,
 } FPatternGroups;
 
 FuncPattern NormalFPatterns[] =
 {
-	{   0xA8,   10,    4,    4,    6,    3,	DVDGetDriveStatus,	sizeof(DVDGetDriveStatus),	"DVDGetDriveStatus",	NULL,		FGROUP_NONE,				0 },
+//	{   0xA8,   10,    4,    4,    6,    3,	DVDGetDriveStatus,	sizeof(DVDGetDriveStatus),	"DVDGetDriveStatus",	NULL,		FGROUP_NONE,				0 },
 #ifndef AUDIOSTREAM
 	{   0xD4,   13,    8,   11,    2,    7,	NULL,				FCODE_AIResetStreamCount,"AIResetStreamSampleCount",NULL,		FGROUP_NONE,				0 },
 #endif
@@ -179,7 +184,8 @@
 	{   0x74,   10,    3,    4,    1,    3,	NULL,				FCODE___ARHandler,			"__ARHandler",			NULL,		FGROUP_NONE,				0 },
 
 	{  0x158,   26,   22,    5,   13,    2,	ARQPostRequest,		ARQPostRequest_size,		"ARQPostRequest",		NULL,		FGROUP_NONE,				0 },
-//	{  0x120,   28,    6,   10,    2,    7,	NULL,				FCODE___OSReadROM,			"__OSReadROM",						FGROUP_NONE,				0 },
+
+	{   0xE8,   14,    7,    6,   10,    6,	NULL,				FCODE___PADSetSamplingRate,	"__PADSetSamplingRate",	NULL,		FGROUP_NONE,				0 },
 #ifdef PATCHALL
 	{   0xCC,    3,    3,    1,    0,    3,	NULL,				FCODE_C_MTXPerspective,		"C_MTXPerspective",		NULL,		FGROUP_NONE,				0 },
 	{   0xC8,    3,    3,    1,    0,    3,	NULL,				FCODE_C_MTXLightPerspective,"C_MTXLightPerspective",NULL,		FGROUP_NONE,				0 },
@@ -209,14 +215,6 @@
 	{   0x88,   18,    8,    2,    0,    2,	DVDLowAudioStatusNULL,	sizeof(DVDLowAudioStatusNULL),"DVDLowRequestAudioStatus",	NULL,FGROUP_NONE,			0 },
 	{   0x98,   19,    8,    2,    1,    3,	DVDLowAudioConfigNULL,	sizeof(DVDLowAudioConfigNULL),"DVDLowAudioBufferConfig",	NULL,FGROUP_NONE,			0 },
 #endif
-	{  0x23C,   66,   24,   35,    0,    9,	NULL,				FCODE_PatchPatchBuffer,		"PatchBuffer",			"A",		FGROUP_NONE,			    0 },
-	{  0x274,   51,   24,    7,   17,   16,	NULL,				FCODE_PatchPatchBuffer,		"PatchBuffer",			"B",		FGROUP_NONE,			    0 },
-	{  0x1B0,   11,   10,   15,   11,    9,	NULL,				FCODE_PatchPatchBuffer,		"PatchBuffer",			"C",		FGROUP_NONE,			    0 },
-	{   0x2C,    6,    2,    1,    0,    2,	NULL,				FCODE_PatchPatchBuffer,		"PatchBuffer",			"D",		FGROUP_NONE,			    0 },
-	{  0x378,  110,   26,   52,    0,    9,	NULL,				FCODE_PatchPatchBuffer,		"PatchBuffer",			"E",		FGROUP_NONE,			    0 },
-	{  0x378,  109,   26,   52,    0,   10,	NULL,				FCODE_PatchPatchBuffer,		"PatchBuffer",			"F",		FGROUP_NONE,			    0 },
-	{  0x268,   52,    9,   39,    8,    7,	NULL,				FCODE_PrsLoad,				"PrsLoad",				NULL,		FGROUP_NONE,			    0 },
-	{   0xC0,   22,    2,    7,    1,    4,	NULL,				FCODE_DolEntryMod,			"DolEntryMod",			NULL,		FGROUP_NONE,			    0 },
 };
 
 FuncPattern TRIFPatterns[] =
@@ -349,11 +347,11 @@
 	{  0x1B0,   32,    6,    8,   13,   14,	NULL,				FCODE___CARDStat_A,			"__CARDStat",			"A",		FGROUP_CARDStat,			0 },
 	{  0x19C,   38,    8,    6,   13,   14,	NULL,				FCODE___CARDStat_B,			"__CARDStat",			"B",		FGROUP_CARDStat,			0 },
 	{  0x220,   37,    6,    9,   15,   25,	NULL,				FCODE___CARDStat_C,			"__CARDStat",			"C",		FGROUP_CARDStat,			0 },
-//	{  0x130,   33,    8,    6,    5,    2,	__CARDReadSegment,	sizeof(__CARDReadSegment),	"__CARDReadSegment",				FGROUP_NONE,				0 },
-//	{   0x60,    7,    6,    1,    1,    3,	__CARDRead,			sizeof(__CARDRead),			"__CARDRead",						FGROUP_NONE,				0 },
-//	{   0xDC,   17,    9,    4,    3,    2,	__CARDEraseSector,	sizeof(__CARDEraseSector),	"__CARDEraseSector",				FGROUP_NONE,				0 },
 
-	{   0x88,    9,    6,    1,    3,    2,	NULL,				FCODE_ReadROM,				"ReadROM",				NULL,		FGROUP_NONE,				0 },
+	{   0x88,    9,    6,    1,    3,    2,	NULL,				FCODE_ReadROM,				"ReadROM",				"A",		FGROUP_ReadROM,				0 },
+	{   0x80,    8,    6,    1,    4,    6,	NULL,				FCODE_ReadROM,				"ReadROM",				"B",		FGROUP_ReadROM,				0 },
+
+	{  0x120,   28,    6,   10,    2,    7,	NULL,				FCODE___OSReadROM,			"__OSReadROM",			NULL,		FGROUP_NONE,				0 },
 };
 
 FuncPattern DatelFPatterns[] =
@@ -362,6 +360,18 @@
 	{   0xF8,    8,   6,    7,    1,    6,	NULL,				FCODE_DolEntryMod,			"DolEntryMod",			"DatelB",	FGROUP_NONE,				0 },
 };
 
+FuncPattern PSOFPatterns[] = 
+{
+	{  0x23C,   66,   24,   35,    0,    9,	NULL,				FCODE_PatchPatchBuffer,		"PatchBuffer",			"A",		FGROUP_NONE,			    0 },
+	{  0x274,   51,   24,    7,   17,   16,	NULL,				FCODE_PatchPatchBuffer,		"PatchBuffer",			"B",		FGROUP_NONE,			    0 },
+	{  0x1B0,   11,   10,   15,   11,    9,	NULL,				FCODE_PatchPatchBuffer,		"PatchBuffer",			"C",		FGROUP_NONE,			    0 },
+	{   0x2C,    6,    2,    1,    0,    2,	NULL,				FCODE_PatchPatchBuffer,		"PatchBuffer",			"D",		FGROUP_NONE,			    0 },
+	{  0x378,  110,   26,   52,    0,    9,	NULL,				FCODE_PatchPatchBuffer,		"PatchBuffer",			"E",		FGROUP_NONE,			    0 },
+	{  0x378,  109,   26,   52,    0,   10,	NULL,				FCODE_PatchPatchBuffer,		"PatchBuffer",			"F",		FGROUP_NONE,			    0 },
+	{  0x268,   52,    9,   39,    8,    7,	NULL,				FCODE_PrsLoad,				"PrsLoad",				NULL,		FGROUP_NONE,			    0 },
+	{   0xC0,   22,    2,    7,    1,    4,	NULL,				FCODE_DolEntryMod,			"DolEntryMod",			NULL,		FGROUP_NONE,			    0 },
+};
+
 enum
 {
 	PCODE_NORMAL = 0,
@@ -369,6 +379,7 @@
 	PCODE_SI,
 	PCODE_EXI,
 	PCODE_DATEL,
+	PCODE_PSO,
 	PCODE_MAX,
 } AllPGroups;
 
@@ -379,4 +390,5 @@
 	{ SIFPatterns, sizeof(SIFPatterns) / sizeof(FuncPattern), PCODE_SI },
 	{ EXIFPatterns, sizeof(EXIFPatterns) / sizeof(FuncPattern), PCODE_EXI },
 	{ DatelFPatterns, sizeof(DatelFPatterns) / sizeof(FuncPattern), PCODE_DATEL },
+	{ PSOFPatterns, sizeof(PSOFPatterns) / sizeof(FuncPattern), PCODE_PSO },
 };
Index: kernel/PatchTimers.c
===================================================================
--- kernel/PatchTimers.c	(revision 334)
+++ kernel/PatchTimers.c	(working copy)
@@ -85,9 +85,9 @@
 #define U32_TIMER_CLOCK_RAD_GC		0xcf2049a1
 #define U32_TIMER_CLOCK_RAD_WII		0x8a15866c
 
-//dont know exactly what this represents
-#define FLT_ONE_DIV_SOMECLOCK_GC	0x37f88d25
-#define FLT_ONE_DIV_SOMECLOCK_WII	0x37a5b36e
+//1 divided by one 1200th of a second
+#define FLT_ONE_DIV_CLOCK_1200_GC	0x37f88d25
+#define FLT_ONE_DIV_CLOCK_1200_WII	0x37a5b36e
 
 //osGetCount, Multiplier so (GC / 1.5f)
 #define DBL_1_1574		0x3ff284b5dcc63f14ull
@@ -99,47 +99,76 @@
 	if( FirstVal == FLT_TIMER_CLOCK_BUS_GC )
 	{
 		write32(Buffer, FLT_TIMER_CLOCK_BUS_WII);
-		dbgprintf("Patch:[Timer Clock float Bus] applied (0x%08X)\r\n", Buffer );
+		dbgprintf("PatchTimers:[Timer Clock float Bus] applied (0x%08X)\r\n", Buffer );
 		return true;
 	}
 	if( FirstVal == FLT_TIMER_CLOCK_CPU_GC )
 	{
 		write32(Buffer, FLT_TIMER_CLOCK_CPU_WII);
-		dbgprintf("Patch:[Timer Clock float CPU] applied (0x%08X)\r\n", Buffer );
+		dbgprintf("PatchTimers:[Timer Clock float CPU] applied (0x%08X)\r\n", Buffer );
 		return true;
 	}
 	if( FirstVal == FLT_TIMER_CLOCK_SECS_GC )
 	{
 		write32(Buffer, FLT_TIMER_CLOCK_SECS_WII);
-		dbgprintf("Patch:[Timer Clock float s] applied (0x%08X)\r\n", Buffer );
+		dbgprintf("PatchTimers:[Timer Clock float s] applied (0x%08X)\r\n", Buffer );
 		return true;
 	}
 	if( FirstVal == FLT_TIMER_CLOCK_MSECS_GC )
 	{
 		write32(Buffer, FLT_TIMER_CLOCK_MSECS_WII);
-		dbgprintf("Patch:[Timer Clock float ms] applied (0x%08X)\r\n", Buffer );
+		dbgprintf("PatchTimers:[Timer Clock float ms] applied (0x%08X)\r\n", Buffer );
 		return true;
 	}
 	if( FirstVal == FLT_ONE_DIV_CLOCK_SECS_GC )
 	{
 		write32(Buffer, FLT_ONE_DIV_CLOCK_SECS_WII);
-		dbgprintf("Patch:[Timer Clock float 1/s] applied (0x%08X)\r\n", Buffer );
+		dbgprintf("PatchTimers:[Timer Clock float 1/s] applied (0x%08X)\r\n", Buffer );
 		return true;
 	}
 	if( FirstVal == FLT_ONE_DIV_CLOCK_MSECS_GC )
 	{
 		write32(Buffer, FLT_ONE_DIV_CLOCK_MSECS_WII);
-		dbgprintf("Patch:[Timer Clock float 1/ms] applied (0x%08X)\r\n", Buffer );
+		dbgprintf("PatchTimers:[Timer Clock float 1/ms] applied (0x%08X)\r\n", Buffer );
 		return true;
 	}
-	if( FirstVal == FLT_ONE_DIV_SOMECLOCK_GC )
+	if( FirstVal == FLT_ONE_DIV_CLOCK_1200_GC )
 	{
-		write32(Buffer, FLT_ONE_DIV_SOMECLOCK_WII);
-		dbgprintf("Patch:[Timer Clock float 1/unk] applied (0x%08X)\r\n", Buffer );
+		write32(Buffer, FLT_ONE_DIV_CLOCK_1200_WII);
+		dbgprintf("PatchTimers:[Timer Clock float 1/1200] applied (0x%08X)\r\n", Buffer );
 		return true;
 	}
+	/* For Nintendo Puzzle Collection */
+	if( FirstVal == 0x38C00BB8 && (u32)Buffer == 0x770528 )
+	{	//it IS a smooth 1.5 BUT the game is actually not properly timed, good job devs
+		write32(Buffer, 0x38C01194);
+		dbgprintf("PatchTimers:[Timer Clock Panel de Pon] applied (0x%08X)\r\n", Buffer );
+		return true;
+	}
 	/* Coded in values */
 	FirstVal &= 0xFC00FFFF;
+	if( FirstVal == 0x3C0009A7 )
+	{
+		u32 NextP = CheckFor(Buffer, 0x6000EC80);
+		if(NextP > 0)
+		{
+			W16(Buffer + 2, U32_TIMER_CLOCK_BUS_WII >> 16);
+			W16(NextP + 2, U32_TIMER_CLOCK_BUS_WII & 0xFFFF);
+			dbgprintf("PatchTimers:[Timer Clock ori Bus] applied (0x%08X)\r\n", Buffer );
+			return true;
+		}
+	}
+	if( FirstVal == 0x3C0009A8 )
+	{
+		u32 NextP = CheckFor(Buffer, 0x3800EC80);
+		if(NextP > 0)
+		{
+			W16(Buffer + 2, (U32_TIMER_CLOCK_BUS_WII >> 16) + 1);
+			W16(NextP + 2, U32_TIMER_CLOCK_BUS_WII & 0xFFFF);
+			dbgprintf("PatchTimers:[Timer Clock addi Bus] applied (0x%08X)\r\n", Buffer );
+			return true;
+		}
+	}
 	if( FirstVal == 0x3C001CF7 )
 	{
 		u32 NextP = CheckFor(Buffer, 0x6000C580);
@@ -147,7 +176,7 @@
 		{
 			W16(Buffer + 2, U32_TIMER_CLOCK_CPU_WII >> 16);
 			W16(NextP + 2, U32_TIMER_CLOCK_CPU_WII & 0xFFFF);
-			dbgprintf("Patch:[Timer Clock ori CPU] applied (0x%08X)\r\n", Buffer );
+			dbgprintf("PatchTimers:[Timer Clock ori CPU] applied (0x%08X)\r\n", Buffer );
 			return true;
 		}
 	}
@@ -158,7 +187,7 @@
 		{
 			W16(Buffer + 2, (U32_TIMER_CLOCK_CPU_WII >> 16) + 1);
 			W16(NextP + 2, U32_TIMER_CLOCK_CPU_WII & 0xFFFF);
-			dbgprintf("Patch:[Timer Clock addi CPU] applied (0x%08X)\r\n", Buffer );
+			dbgprintf("PatchTimers:[Timer Clock addi CPU] applied (0x%08X)\r\n", Buffer );
 			return true;
 		}
 	}
@@ -169,7 +198,7 @@
 		{
 			W16(Buffer + 2, U32_TIMER_CLOCK_SECS_WII >> 16);
 			W16(NextP + 2, U32_TIMER_CLOCK_SECS_WII & 0xFFFF);
-			dbgprintf("Patch:[Timer Clock ori s] applied (0x%08X)\r\n", Buffer );
+			dbgprintf("PatchTimers:[Timer Clock ori s] applied (0x%08X)\r\n", Buffer );
 			return true;
 		}
 	}
@@ -180,7 +209,7 @@
 		{
 			W16(Buffer + 2, (U32_TIMER_CLOCK_SECS_WII >> 16) + 1);
 			W16(NextP + 2, U32_TIMER_CLOCK_SECS_WII & 0xFFFF);
-			dbgprintf("Patch:[Timer Clock addi s] applied (0x%08X)\r\n", Buffer );
+			dbgprintf("PatchTimers:[Timer Clock addi s] applied (0x%08X)\r\n", Buffer );
 			return true;
 		}
 	}
@@ -191,7 +220,7 @@
 		{
 			W16(Buffer + 2, U32_TIMER_CLOCK_MSECS_WII >> 16);
 			W16(NextP + 2, U32_TIMER_CLOCK_MSECS_WII & 0xFFFF);
-			dbgprintf("Patch:[Timer Clock ori ms] applied (0x%08X)\r\n", Buffer );
+			dbgprintf("PatchTimers:[Timer Clock ori ms] applied (0x%08X)\r\n", Buffer );
 			return true;
 		}
 	}
@@ -202,7 +231,7 @@
 		{
 			W16(Buffer + 2, (U32_TIMER_CLOCK_MSECS_WII >> 16) + 1);
 			W16(NextP + 2, U32_TIMER_CLOCK_MSECS_WII & 0xFFFF);
-			dbgprintf("Patch:[Timer Clock addi ms] applied (0x%08X)\r\n", Buffer );
+			dbgprintf("PatchTimers:[Timer Clock addi ms] applied (0x%08X)\r\n", Buffer );
 			return true;
 		}
 	}
@@ -215,7 +244,7 @@
 			u32 smallTimer = U32_TIMER_CLOCK_RAD_WII >> 15;
 			W16(Buffer + 2, smallTimer >> 16);
 			W16(NextP + 2, smallTimer & 0xFFFF);
-			dbgprintf("Patch:[RADTimerRead ori shift] applied (0x%08X)\r\n", Buffer );
+			dbgprintf("PatchTimers:[RADTimerRead ori shift] applied (0x%08X)\r\n", Buffer );
 			return true;
 		}
 	}
@@ -226,7 +255,7 @@
 		{
 			W16(Buffer + 2, U32_TIMER_CLOCK_RAD_WII >> 16);
 			W16(NextP + 2, U32_TIMER_CLOCK_RAD_WII & 0xFFFF);
-			dbgprintf("Patch:[RADTimerRead ori full] applied (0x%08X)\r\n", Buffer );
+			dbgprintf("PatchTimers:[RADTimerRead ori full] applied (0x%08X)\r\n", Buffer );
 			return true;
 		}
 	}
@@ -237,7 +266,7 @@
 		{
 			W16(Buffer + 2, (U32_TIMER_CLOCK_RAD_WII >> 16) + 1);
 			W16(NextP + 2, U32_TIMER_CLOCK_RAD_WII & 0xFFFF);
-			dbgprintf("Patch:[RADTimerRead addi full] applied (0x%08X)\r\n", Buffer );
+			dbgprintf("PatchTimers:[RADTimerRead addi full] applied (0x%08X)\r\n", Buffer );
 			return true;
 		}
 	}
@@ -253,27 +282,41 @@
 	if(write64A(0x001463E0, DBL_0_7716, DBL_1_1574))
 	{
 		#ifdef DEBUG_PATCH
-		dbgprintf("Patch:[Majoras Mask NTSC-J] applied\r\n");
+		dbgprintf("PatchTimers:[Majoras Mask NTSC-J] applied\r\n");
 		#endif
 	}
 	else if(write64A(0x00141C00, DBL_0_7716, DBL_1_1574))
 	{
 		#ifdef DEBUG_PATCH
-		dbgprintf("Patch:[Majoras Mask NTSC-U] applied\r\n");
+		dbgprintf("PatchTimers:[Majoras Mask NTSC-U] applied\r\n");
 		#endif
 	}
 	else if(write64A(0x00130860, DBL_0_7716, DBL_1_1574))
 	{
 		#ifdef DEBUG_PATCH
-		dbgprintf("Patch:[Majoras Mask PAL] applied\r\n");
+		dbgprintf("PatchTimers:[Majoras Mask PAL] applied\r\n");
 		#endif
 	}
 	else if(read32(0x1E71AC) == 0x3CE0000A && read32(0x1E71B8) == 0x39074CB8)
-	{
+	{	/* one 60th of a second */
 		write32(0x1E71AC, 0x3CE0000F);
 		write32(0x1E71B8, 0x39077314);
 		#ifdef DEBUG_PATCH
-		dbgprintf("Patch:[Killer7 PAL] applied\r\n");
+		dbgprintf("PatchTimers:[Killer7 PAL] applied\r\n");
 		#endif
 	}
+	else if(read32(0x55A0) == 0x3C60000A && read32(0x55A4) == 0x38036000 
+		&& read32(0x55B0) == 0x380000FF)
+	{	/* The game uses 2 different timers */
+		write32(0x55A0, 0x3C60000F); //lis r3, 0xF
+		write32(0x55A4, 0x60609060); //ori r0, r3, 0x9060
+		write32(0x55B0, 0x38000180); //li r0, 0x180
+		/* Values get set twice */
+		write32(0x5ECC, 0x3C60000F); //lis r3, 0xF
+		write32(0x5ED4, 0x60609060); //ori r0, r3, 0x9060
+		write32(0x5ED8, 0x38600180); //li r3, 0x180
+		#ifdef DEBUG_PATCH
+		dbgprintf("PatchTimers:[GT Cube NTSC-J] applied\r\n");
+		#endif
+	}
 }
Index: kernel/PatchWidescreen.c
===================================================================
--- kernel/PatchWidescreen.c	(revision 334)
+++ kernel/PatchWidescreen.c	(working copy)
@@ -21,6 +21,8 @@
 #include "string.h"
 #include "PatchWidescreen.h"
 #include "asm/CalcWidescreen.h"
+#include "asm/CalcWidescreenDiv.h"
+#include "asm/CalcGXWidescreen.h"
 
 extern void PatchB(u32 dst, u32 src);
 extern u32 PatchCopy(const u8 *PatchPtr, const u32 PatchSize);
@@ -36,6 +38,28 @@
 	PatchB(BufferPos+4, wide+CalcWidescreen_size-4);
 }
 
+void PatchWideDiv(u32 BufferPos, u32 dstReg)
+{
+	u32 wide = PatchCopy(CalcWidescreenDiv, CalcWidescreenDiv_size);
+	/* Copy original instruction and jump */
+	write32(wide, read32(BufferPos));
+	PatchB(wide, BufferPos);
+	/* Modify destination register */
+	write32(wide+0x28, (read32(wide+0x28) & 0xFC1FF83F) | (dstReg << 6) | (dstReg << 21));
+	/* Jump back to original code */
+	PatchB(BufferPos+4, wide+CalcWidescreenDiv_size-4);
+}
+
+void PatchGXWideMulti(u32 BufferPos, u32 dstReg)
+{
+	u32 wide = PatchCopy(CalcGXWidescreen, CalcGXWidescreen_size);
+	/* Copy original instruction and jump */
+	write32(wide+CalcGXWidescreen_size-8, read32(BufferPos));
+	PatchB(wide, BufferPos);
+	/* Jump back to original code */
+	PatchB(BufferPos+4, wide+CalcGXWidescreen_size-4);
+}
+
 //Credits to Ralf from gc-forever for the original Ocarina Codes
 
 #define FLT_ASPECT_0_913 0x3f69d89c
@@ -61,7 +85,7 @@
 	if(FirstVal == FLT_ASPECT_0_913 && read32(Buffer+4) == 0x2e736200)
 	{
 		write32(Buffer, FLT_ASPECT_1_218);
-		dbgprintf("Patch:[Aspect Ratio 1.218] applied (0x%08X)\r\n", Buffer );
+		dbgprintf("PatchWidescreen:[Aspect Ratio 1.218] applied (0x%08X)\r\n", Buffer );
 		return true;
 	}
 	else if(FirstVal == FLT_ASPECT_1_200 && (read32(Buffer+4) == 0x43F00000 || 
@@ -68,13 +92,13 @@
 			(read32(Buffer+4) == 0 && read32(Buffer+8) == 0x43F00000)))
 	{	//All Mario Party games share this value
 		write32(Buffer, FLT_ASPECT_1_600);
-		dbgprintf("Patch:[Aspect Ratio 1.600] applied (0x%08X)\r\n", Buffer );
+		dbgprintf("PatchWidescreen:[Aspect Ratio 1.600] applied (0x%08X)\r\n", Buffer );
 		return true;
 	}
 	else if(FirstVal == FLT_ASPECT_1_266 && read32(Buffer+4) == 0x44180000)
 	{
 		write32(Buffer, FLT_ASPECT_1_688);
-		dbgprintf("Patch:[Aspect Ratio 1.688] applied (0x%08X)\r\n", Buffer );
+		dbgprintf("PatchWidescreen:[Aspect Ratio 1.688] applied (0x%08X)\r\n", Buffer );
 		return true;
 	}
 	else if(FirstVal == FLT_ASPECT_1_333 && (read32(Buffer+4) == 0x481c4000 || 
@@ -81,56 +105,85 @@
 		read32(Buffer+4) == 0x3f800000 || read32(Buffer+4) == 0xbf800000))
 	{
 		write32(Buffer, FLT_ASPECT_1_777);
-		dbgprintf("Patch:[Aspect Ratio 1.777] applied (0x%08X)\r\n", Buffer );
+		dbgprintf("PatchWidescreen:[Aspect Ratio 1.777] applied (0x%08X)\r\n", Buffer );
 		return true;
 	}
 	else if(FirstVal == FLT_ASPECT_1_357 && read32(Buffer+4) == 0x481c4000)
 	{
 		write32(Buffer, FLT_ASPECT_1_809);
-		dbgprintf("Patch:[Aspect Ratio 1.809] applied (0x%08X)\r\n", Buffer );
+		dbgprintf("PatchWidescreen:[Aspect Ratio 1.809] applied (0x%08X)\r\n", Buffer );
 		return true;
 	}
 	else if(FirstVal == FLT_ASPECT_1_428 && read32(Buffer+4) == 0x3e99999a)
 	{
 		write32(Buffer, FLT_ASPECT_1_905);
-		dbgprintf("Patch:[Aspect Ratio 1.905] applied (0x%08X)\r\n", Buffer );
+		dbgprintf("PatchWidescreen:[Aspect Ratio 1.905] applied (0x%08X)\r\n", Buffer );
 		return true;
 	}
 	return false;
 }
 extern vu32 TRIGame;
+extern u32 IsN64Emu;
 bool PatchStaticWidescreen(u32 TitleID, u32 Region)
 {
-	if(TRIGame == TRI_GP1)
+	switch (TRIGame)
 	{
-		dbgprintf("Patch:Mario Kart GP1 Widescreen\r\n");
-		PatchWideMulti(0x28C800, 1);
-		return true;
+		case TRI_GP1:
+			dbgprintf("PatchWidescreen:[Mario Kart GP1] applied\r\n");
+			PatchWideMulti(0x28C800, 1);
+			return true;
+		case TRI_GP2:
+			dbgprintf("PatchWidescreen:[Mario Kart GP2] applied\r\n");
+			PatchWideMulti(0x2C80D4, 1);
+			return true;
+		case TRI_VS4:
+			if (read32(0x5E418) == 0xEC020024)
+			{
+				dbgprintf("PatchWidescreen:[Virtua Striker 4v06 Exp] applied\r\n");
+				PatchWideMulti(0x5E418, 0); //clipping
+				PatchWideMulti(0x7FA58, 0); //widescreen
+				return true;
+			}
+			break;
+		case TRI_AX:
+			dbgprintf("PatchWidescreen:[F-Zero AX] applied\r\n");
+			if(read32(0x445774) == FLT_ASPECT_1_333)
+				write32(0x445774, read32(0x445770));
+			else if(read32(0x445C34) == FLT_ASPECT_1_333)
+				write32(0x445C34, read32(0x445C30));
+			else if(read32(0x4461B4) == FLT_ASPECT_1_333)
+				write32(0x4461B4, read32(0x4461B0));
+			return true;
+		default:
+			break;
 	}
-	else if(TRIGame == TRI_GP2)
+
+	u32 Buffer, PatchedWide = 0;
+	if(IsN64Emu)
 	{
-		dbgprintf("Patch:Mario Kart GP2 Widescreen\r\n");
-		PatchWideMulti(0x2C80D4, 1);
-		return true;
+		for(Buffer = 0x90000; Buffer < 0x9F000; Buffer+=4)
+		{
+			if(read32(Buffer) == 0xC3A1005C && read32(Buffer+4) == 0x80030010 && read32(Buffer+8) == 0xFC80E890)
+			{
+				PatchWideMulti(Buffer, 29); //guPerspective
+				PatchedWide++;
+			}
+			if(read32(Buffer) == 0xC3810014 && read32(Buffer+4) == 0x80030010 && read32(Buffer+8) == 0xFC80E090)
+			{
+				PatchWideMulti(Buffer, 28); //guPerspectiveF
+				PatchedWide++;
+			}
+		}
+		if(PatchedWide)
+		{
+			dbgprintf("PatchWidescreen:[N64 Emu] applied (%i times)\r\n", PatchedWide);
+			return true;
+		}
 	}
-	else if(TRIGame == TRI_VS4)
-	{
-		dbgprintf("Patch:Virtua Striker 4 Widescreen\r\n");
-		PatchWideMulti(0x5E418, 0); //clipping
-		PatchWideMulti(0x7FA58, 0); //widescreen
-		return true;
-	}
-	else if(TRIGame == TRI_AX)
-	{	//thanks CosmoCortney
-		dbgprintf("Patch:F-Zero AX Widescreen\r\n");
-		write32(0x445C34, read32(0x445C30));
-		return true;
-	}
-	u32 Buffer, PatchedWide = 0;
 	switch(TitleID)
 	{
 		case 0x474D34: //Mario Kart Double Dash
-			dbgprintf("Patch:Patched MKDD Widescreen\r\n");
+			dbgprintf("PatchWidescreen:[Mario Kart Double Dash] applied\r\n");
 			if(Region == REGION_ID_USA || Region == REGION_ID_JAP)
 			{
 				PatchWideMulti(0x1D65A4, 3);
@@ -148,7 +201,7 @@
 			{	//Every language has its own function location making 7 different locations
 				if(read32(Buffer) == 0xFF801090 && read32(Buffer+4) == 0x7C9F2378)
 				{
-					dbgprintf("Patch:Patched Animal Crossing Widescreen (0x%08X)\r\n", Buffer);
+					dbgprintf("PatchWidescreen:[Animal Crossing] applied (0x%08X)\r\n", Buffer);
 					PatchWideMulti(Buffer, 28);
 					return true;
 				}
@@ -159,7 +212,7 @@
 			{
 				if(read32(Buffer) == 0x281E0000 && read32(Buffer+4) == 0xC03F0034)
 				{
-					dbgprintf("Patch:Patched SSBM Widescreen (0x%08X)\r\n", Buffer+4);
+					dbgprintf("PatchWidescreen:[Super Smash Bros Melee] applied (0x%08X)\r\n", Buffer+4);
 					PatchWideMulti(Buffer+4, 1);
 					return true;
 				}
@@ -170,7 +223,7 @@
 			{
 				if(read32(Buffer) == 0xEC000828 && (read32(Buffer+4) == 0xD00302A0 || read32(Buffer+4) == 0xD01C02A0))
 				{
-					dbgprintf("Patch:Patched 1080 Avalanche Widescreen (0x%08X)\r\n", Buffer);
+					dbgprintf("PatchWidescreen:[1080 Avalanche] applied (0x%08X)\r\n", Buffer);
 					PatchWideMulti(Buffer, 0);
 					PatchedWide = 1; //patching 2 areas
 				}
@@ -181,7 +234,7 @@
 			{
 				if(read32(Buffer) == 0x80BF030C)
 				{
-					dbgprintf("Patch:Patched Pikmin Widescreen (0x%08X)\r\n", Buffer);
+					dbgprintf("PatchWidescreen:[Pikmin] applied (0x%08X)\r\n", Buffer);
 					write32(Buffer, 0x38A003AC);
 					return true;
 				}
@@ -192,14 +245,32 @@
 			{
 				if(read32(Buffer) == 0xEC011824 && read32(Buffer+12) == 0xC0040000)
 				{
-					dbgprintf("Patch:Patched Pikmin 2 Widescreen (0x%08X)\r\n", Buffer);
+					dbgprintf("PatchWidescreen:[Pikmin 2] applied (0x%08X)\r\n", Buffer);
 					PatchWideMulti(Buffer, 0);
 					return true;
 				}
 			}
 			return false;
+		case 0x474D38: //Metroid Prime
+		case 0x47324D: //Metroid Prime 2
+			for(Buffer = 0x2B0000; Buffer < 0x3B0000; Buffer+=4)
+			{
+				if(read32(Buffer) == 0xFFA01090 && read32(Buffer+8) == 0xFFC01890 && read32(Buffer+12) == 0xEC250072)
+				{
+					PatchWideMulti(Buffer, 29); //perspective
+					PatchedWide++;
+				}
+				if(read32(Buffer) == 0xFF401090 && read32(Buffer+4) == 0xEF210032 && read32(Buffer+12) == 0xFFC01890)
+				{
+					PatchWideMulti(Buffer, 26); //width near plane
+					PatchWideMulti(Buffer+12, 30); //width far plane
+					PatchedWide++;
+				}
+			}
+			dbgprintf("PatchWidescreen:[Metroid Prime] applied (%i times)\r\n", PatchedWide);
+			return PatchedWide;
 		case 0x474832: //Need for Speed Hot Pursuit 2
-			dbgprintf("Patch:Patched NFS:HP2 Widescreen\r\n");
+			dbgprintf("PatchWidescreen:[Need for Speed Hot Pursuit 2] applied\r\n");
 			if(Region == REGION_ID_USA)
 			{
 				write32(0x14382C, 0xC0429AE8);
@@ -212,7 +283,7 @@
 			}
 			return true;
 		case 0x474C4D: //Luigis Mansion
-			dbgprintf("Patch:Patched Luigis Mansion Widescreen\r\n");
+			dbgprintf("PatchWidescreen:[Luigis Mansion] applied\r\n");
 			if(Region == REGION_ID_USA)
 				PatchWideMulti(0x206A4, 0);
 			else if(Region == REGION_ID_EUR)
@@ -221,7 +292,7 @@
 				PatchWideMulti(0x20300, 0);
 			return true;
 		case 0x474342: //Crash Bandicoot
-			dbgprintf("Patch:Patched Crash Bandicoot Clipping\r\n");
+			dbgprintf("PatchWidescreen:[Crash Bandicoot] clipping applied\r\n");
 			if(Region == REGION_ID_USA)
 				write32(0xAC768, 0xD01E0040);
 			else if(Region == REGION_ID_EUR)
@@ -229,6 +300,108 @@
 			else if(Region == REGION_ID_JAP)
 				write32(0xADF1C, 0xD01E0040);
 			return false; //aspect ratio gets patched later
+		case 0x473258: //Sonic Gems Collection
+			if(Region == REGION_ID_USA)
+			{
+				if(read32(0x48A2A4) == FLT_ASPECT_1_200)
+				{
+					dbgprintf("PatchWidescreen:[Sonic R] applied\r\n");
+					//aspect ratio
+					write32(0x48A2A4,FLT_ASPECT_1_600);
+					//free space for new wide values
+					write32(0x69124,0x7C69586E);
+					write32(0x6912C,0x7E631A14);
+					//general clipping left half
+					write32(0x69134,0x3800FF96);
+					//general clipping right half
+					write32(0x69138,0x3A4002E9);
+					//stage clipping multiplier
+					PatchWideMulti(0x87CAC, 13);
+					return true;
+				}
+			}
+			else if(Region == REGION_ID_EUR)
+			{
+				if(read32(0x48A364) == FLT_ASPECT_1_200)
+				{
+					dbgprintf("PatchWidescreen:[Sonic R] applied\r\n");
+					//aspect ratio
+					write32(0x48A364,FLT_ASPECT_1_600);
+					//free space for new wide values
+					write32(0x69128,0x7C69586E);
+					write32(0x69130,0x7E631A14);
+					//general clipping left half
+					write32(0x69138,0x3800FF96);
+					//general clipping right half
+					write32(0x6913C,0x3A4002E9);
+					//stage clipping multiplier
+					PatchWideMulti(0x87CB4, 13);
+					return true;
+				}
+			}
+			else if(Region == REGION_ID_JAP)
+			{
+				if(read32(0x48A104) == FLT_ASPECT_1_200)
+				{
+					dbgprintf("PatchWidescreen:[Sonic R] applied\r\n");
+					//aspect ratio
+					write32(0x48A104,FLT_ASPECT_1_600);
+					//free space for new wide values
+					write32(0x69124,0x7C69586E);
+					write32(0x6912C,0x7E631A14);
+					//general clipping left half
+					write32(0x69134,0x3800FF96);
+					//general clipping right half
+					write32(0x69138,0x3A4002E9);
+					//stage clipping multiplier
+					PatchWideMulti(0x87BA0, 13);
+					return true;
+				}
+			}
+			return false;
+		case 0x474E46: //NFL Blitz 2002
+			if(Region == REGION_ID_USA)
+			{
+				dbgprintf("PatchWidescreen:[NFL Blitz 2002] applied\r\n");
+				write32(0x199B3C,0xC0040000);
+				PatchWideMulti(0x199B3C,0);
+				write32(0x199B44,0xD01F0068);
+				return true;
+			}
+			return false;
+		case 0x474F33: //NFL Blitz 2003
+			if(Region == REGION_ID_USA)
+			{
+				dbgprintf("PatchWidescreen:[NFL Blitz 2003] applied\r\n");
+				write32(0x2037A8,0xC01D0000);
+				PatchWideMulti(0x2037A8,0);
+				write32(0x2037B0,0xD01F0068);
+				return true;
+			}
+			return false;
+		case 0x474656: //NFL Blitz Pro
+			if(Region == REGION_ID_USA)
+			{
+				dbgprintf("PatchWidescreen:[NFL Blitz Pro] applied\r\n");
+				write32(0x274114,0xC0040000);
+				PatchWideMulti(0x274114,0);
+				write32(0x27412C,0xD0030068);
+				return true;
+			}
+			return false;
+		case 0x474541: //skies of arcadia legends
+			dbgprintf("PatchWidescreen:[Skies of Arcadia Legends] applied\r\n");
+			if(Region == REGION_ID_USA) {
+				PatchWideMulti(0x1DCE00,2); //picture effects
+				PatchWideDiv(0x299334,6); //widescreen, clipping
+			} else if(Region == REGION_ID_EUR) {
+				PatchWideMulti(0x1DEADC,2); //picture effects
+				PatchWideDiv(0x29BC5C,6); //widescreen, clipping
+			} else if(Region == REGION_ID_JAP) {
+				PatchWideMulti(0x1DCCDC,1); //picture effects
+				PatchWideDiv(0x298DE4,6); //widescreen, clipping
+			}
+			return true;
 		default:
 			return false;
 	}
Index: kernel/ReadSpeed.c
===================================================================
--- kernel/ReadSpeed.c	(revision 334)
+++ kernel/ReadSpeed.c	(working copy)
@@ -17,6 +17,7 @@
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
 #include "global.h"
+#include "Config.h"
 #include "ReadSpeed.h"
 #include "debug.h"
 
@@ -23,8 +24,8 @@
 // This file exists to emulate the disc read speed
 // The data used comes from my D2C wii disc drive
 
-static const u32 SEEK_TICKS = 9492; // 50 ms
-static const float READ_TICKS = 1.657f; // 3 MB/s
+static u32 SEEK_TICKS = 94922; // 50 ms
+static float READ_TICKS = 1.657f; // 3 MB/s
 static const u32 READ_BLOCK = 65536; // 64 KB
 static const float CACHE_TICKS = 8.627f; // 15.6 MB/s
 static const u32 CACHE_SIZE = 1048576; // 1 MB
@@ -36,6 +37,8 @@
 static u32 CMDBaseBlock = UINT_MAX;
 static u32 CMDLastBlock = UINT_MAX;
 
+extern u32 TITLE_ID;
+
 void ReadSpeed_Init()
 {
 	CMDStartTime = 0;
@@ -43,6 +46,13 @@
 	CMDTicks = UINT_MAX;
 	CMDBaseBlock = UINT_MAX;
 	CMDLastBlock = UINT_MAX;
+
+	if(TITLE_ID == 0x47574B) //King Kong
+	{
+		dbgprintf("ReadSpeed:Using Slow Settings\r\n");
+		SEEK_TICKS = 284765; // 150 ms
+		READ_TICKS = 1.1f; // 2 MB/s
+	}
 }
 
 extern vu32 TRIGame;
Index: kernel/RealDI.c
===================================================================
--- kernel/RealDI.c	(revision 0)
+++ kernel/RealDI.c	(working copy)
@@ -0,0 +1,264 @@
+/*
+RealDI.h for Nintendont (Kernel)
+
+Copyright (C) 2015 FIX94
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation version 2.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+#include "debug.h"
+#include "Config.h"
+#include "common.h"
+#include "string.h"
+#include "alloc.h"
+#include "RealDI.h"
+#include "DI.h"
+
+static struct ipcmessage realdimsg ALIGNED(32);
+static u32 outbuf[8] __attribute__((aligned(32)));
+static u32 spinup[8] __attribute__((aligned(32)));
+static u32 identify[8] __attribute__((aligned(32)));
+static u32 readdiscid[8] __attribute__((aligned(32)));
+static const char di_path[] __attribute__((aligned(32))) = "/dev/di";
+static s32 di_fd = -1;
+extern u32 Region;
+u32 RealDiscCMD = 0, RealDiscError = 0;
+//No ISO Cache so lets take alot of memory
+u8 *DISC_FRONT_CACHE = (u8*)0x12000000;
+u8 *DISC_DRIVE_BUFFER = (u8*)0x12000800;
+u32 DISC_DRIVE_BUFFER_LENGTH = 0x7FF000;
+u8 *DISC_TMP_CACHE = (u8*)0x127FF800;
+
+s32 realdiqueue = -1;
+vu32 realdi_msgrecv = 0;
+u32 RealDI_Thread(void *arg)
+{
+	struct ipcmessage *msg = NULL;
+	while(1)
+	{
+		mqueue_recv( realdiqueue, &msg, 0 );
+		mqueue_ack( msg, 0 );
+		realdi_msgrecv = 1;
+	}
+	return 0;
+}
+
+extern char __realdi_stack_addr, __realdi_stack_size;
+static u32 RealDI_Thread_P = 0;
+static u8 *realdiheap = NULL;
+
+void RealDI_Init()
+{
+	memset32(spinup, 0, 32);
+	spinup[0] = 0x8A000000;
+	spinup[1] = 1;
+	sync_after_write(spinup, 32);
+
+	memset32(identify, 0, 32);
+	identify[0] = 0x12000000;
+	sync_after_write(identify, 32);
+
+	memset32(readdiscid, 0, 32);
+	readdiscid[0] = 0x70000000;
+	sync_after_write(readdiscid, 32);
+
+	//have real disc drive ready
+	di_fd = IOS_Open(di_path, 0);
+
+	realdiheap = (u8*)malloca(32,32);
+	realdiqueue = mqueue_create(realdiheap, 1);
+
+	RealDI_Thread_P = thread_create(RealDI_Thread, NULL, ((u32*)&__realdi_stack_addr), ((u32)(&__realdi_stack_size)) / sizeof(u32), 0x50, 1);
+	thread_continue(RealDI_Thread_P);
+	mdelay(100);
+	RealDI_Identify(true);
+}
+
+void RealDI_Identify(bool NeedsGC)
+{
+	ClearRealDiscBuffer();
+	u32 Length = 0x800;
+	RealDiscCMD = DIP_CMD_NORMAL;
+	u8 *TmpBuf = ReadRealDisc(&Length, 0, false);
+	if(IsGCGame((u32)TmpBuf) == false)
+	{
+		Length = 0x800;
+		RealDiscCMD = DIP_CMD_DVDR;
+		TmpBuf = ReadRealDisc(&Length, 0, false);
+		if(IsGCGame((u32)TmpBuf) == false)
+		{
+			if(NeedsGC)
+			{
+				dbgprintf("No GC Disc!\r\n");
+				BootStatusError(-2, -2);
+				mdelay(4000);
+				Shutdown();
+			}
+			else
+				dbgprintf("No GC Disc, continuing anyways\r\n");
+			return;
+		}
+	}
+	memcpy((void*)0, TmpBuf, 0x20); //Disc Header
+	sync_after_write((void*)0, 0x20);
+	Region = read32((u32)(TmpBuf+0x458)); //Game Region
+	dbgprintf("DI:Reading real disc with command 0x%02X\r\n", RealDiscCMD);
+}
+
+vu32 WaitForWrite = 0, WaitForRead = 0;
+void RealDI_Update()
+{
+	if(WaitForWrite == 1)
+	{
+		WaitForWrite = 0;
+		while(WaitForRead == 0)
+			udelay(20);
+	}
+	if(WaitForRead == 1 && (read32(DIP_CONTROL) & 1) == 0)
+	{
+		if(read32(DIP_STATUS) & 4)
+			RealDiscError = 1;
+		write32(DIP_STATUS, 0x54); //mask and clear interrupts
+		udelay(70);
+		WaitForRead = 0;
+	}
+}
+
+static u32 switch_stat = 0;
+bool RealDI_NewDisc()
+{
+	if(switch_stat == 0 && read32(DIP_COVER) == 4) //disc switch!
+	{
+		realdi_msgrecv = 0;
+		switch_stat++;
+		IOS_IoctlAsync(di_fd, 0x8A, VirtualToPhysical(spinup), 0x20, VirtualToPhysical(outbuf), 0x20, realdiqueue, VirtualToPhysical(&realdimsg));
+	}
+	if(realdi_msgrecv == 1)
+	{
+		realdi_msgrecv = 0;
+		if(switch_stat == 1)
+		{
+			switch_stat++;
+			IOS_IoctlAsync(di_fd, 0x12, VirtualToPhysical(identify), 0x20, VirtualToPhysical(outbuf), 0x20, realdiqueue, VirtualToPhysical(&realdimsg));
+		}
+		else if(switch_stat == 2)
+		{
+			switch_stat++;
+			IOS_IoctlAsync(di_fd, 0x70, VirtualToPhysical(readdiscid), 0x20, VirtualToPhysical(outbuf), 0x20, realdiqueue, VirtualToPhysical(&realdimsg));
+		}
+		else if(switch_stat == 3)
+		{
+			switch_stat = 0; //done!
+			return true;
+		}
+	}
+	return false;
+}
+
+static u32 DVD_OFFSET = UINT_MAX;
+void ClearRealDiscBuffer(void)
+{
+	DVD_OFFSET = UINT_MAX;
+	memset32(DISC_DRIVE_BUFFER, 0, DISC_DRIVE_BUFFER_LENGTH);
+	sync_after_write(DISC_DRIVE_BUFFER, DISC_DRIVE_BUFFER_LENGTH);
+}
+extern bool access_led;
+u8 *ReadRealDisc(u32 *Length, u32 Offset, bool NeedSync)
+{
+	//dbgprintf("ReadRealDisc(%08x %08x)\r\n", *Length, Offset);
+
+	u32 CachedBlockStart = 0;
+	u32 ReadDiff = 0;
+	if(RealDiscCMD == DIP_CMD_DVDR)
+	{
+		u32 AlignedOffset = ALIGN_BACKWARD(Offset, 0x800);
+		ReadDiff = Offset - AlignedOffset;
+		if(AlignedOffset == DVD_OFFSET)
+		{
+			sync_before_read(DISC_TMP_CACHE, 0x800);
+			//dbgprintf("Using cached offset %08x\r\n", DVD_OFFSET>>11);
+			memcpy(DISC_FRONT_CACHE, DISC_TMP_CACHE, 0x800);
+			CachedBlockStart = 0x800;
+			u32 AlignedLength = ALIGN_FORWARD(*Length + ReadDiff, 0x800);
+			if( AlignedLength > 0 && AlignedLength == CachedBlockStart )
+				return (DISC_FRONT_CACHE + ReadDiff);
+		}
+		//dbgprintf("ReadDiff: %08x\r\n", ReadDiff);
+	}
+	if(NeedSync)
+	{
+		WaitForWrite = 1;
+		while(WaitForWrite == 1)
+			udelay(20);
+	}
+
+	//turn on drive led
+	if (access_led) set32(HW_GPIO_OUT, GPIO_SLOT_LED);
+
+	if (*Length > DISC_DRIVE_BUFFER_LENGTH - ReadDiff)
+	{
+		*Length = DISC_DRIVE_BUFFER_LENGTH - ReadDiff;
+		//dbgprintf("New Length: %08x\r\n", *Length);
+	}
+	u32 TmpLen = *Length;
+	u32 TmpOffset = Offset;
+	if(RealDiscCMD == DIP_CMD_DVDR)
+	{
+		TmpLen = ALIGN_FORWARD(TmpLen + ReadDiff, 0x800) - CachedBlockStart;
+		TmpOffset = ALIGN_BACKWARD(Offset, 0x800) + CachedBlockStart;
+	}
+
+	write32(DIP_STATUS, 0x54); //mask and clear interrupts
+
+	//Actually read
+	write32(DIP_CMD_0, RealDiscCMD << 24);
+	write32(DIP_CMD_1, RealDiscCMD == DIP_CMD_DVDR ? TmpOffset >> 11 : TmpOffset >> 2);
+	write32(DIP_CMD_2, RealDiscCMD == DIP_CMD_DVDR ? TmpLen >> 11 : TmpLen);
+
+	//dbgprintf("Read %08x %08x\r\n", read32(DIP_CMD_1), read32(DIP_CMD_2));
+	sync_before_read(DISC_DRIVE_BUFFER, TmpLen);
+	write32(DIP_DMA_ADR, (u32)DISC_DRIVE_BUFFER);
+	write32(DIP_DMA_LEN, TmpLen);
+
+	write32( DIP_CONTROL, 3 );
+	udelay(70);
+
+	if(NeedSync)
+	{
+		WaitForRead = 1;
+		while(WaitForRead == 1)
+			udelay(200);
+	}
+	else
+	{
+		while(read32(DIP_CONTROL) & 1)
+			udelay(200);
+		write32(DIP_STATUS, 0x54); //mask and clear interrupts
+		udelay(70);
+	}
+
+	//turn off drive led
+	if (access_led) clear32(HW_GPIO_OUT, GPIO_SLOT_LED);
+
+	if(RealDiscCMD == DIP_CMD_DVDR)
+	{
+		u32 LastBlockStart = (read32(DIP_CMD_2) - 1) << 11;
+		DVD_OFFSET = (read32(DIP_CMD_1) << 11) + LastBlockStart;
+		memcpy(DISC_TMP_CACHE, DISC_DRIVE_BUFFER + LastBlockStart, 0x800);
+		sync_after_write(DISC_TMP_CACHE, 0x800);
+		if(CachedBlockStart)
+			return (DISC_FRONT_CACHE + ReadDiff);
+	}
+
+	return DISC_DRIVE_BUFFER + ReadDiff;
+}
Index: kernel/RealDI.h
===================================================================
--- kernel/RealDI.h	(revision 0)
+++ kernel/RealDI.h	(working copy)
@@ -0,0 +1,33 @@
+/*
+RealDI.h for Nintendont (Kernel)
+
+Copyright (C) 2015 FIX94
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation version 2.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef _REALDI_H_
+#define _REALDI_H_
+
+#define		DIP_CMD_NORMAL	0xA8
+#define		DIP_CMD_DVDR	0xD0
+
+void RealDI_Init();
+void RealDI_Update();
+void RealDI_Identify(bool NeedsGC);
+bool RealDI_NewDisc();
+void ClearRealDiscBuffer(void);
+u8 *ReadRealDisc(u32 *Length, u32 Offset, bool NeedSync);
+
+#endif
Index: kernel/Stream.c
===================================================================
--- kernel/Stream.c	(revision 334)
+++ kernel/Stream.c	(working copy)
@@ -1,7 +1,7 @@
 /*
 Stream.c for Nintendont (Kernel)
 
-Copyright (C) 2014 FIX94
+Copyright (C) 2014 - 2016 FIX94
 
 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
@@ -104,7 +104,8 @@
 	u32 i;
 	for(i = 0; i < cur_chunksize; i += ONE_BLOCK_SIZE)
 	{
-		ADPdecodebuffer(StreamBuffer+i,outl,outr,&hist[0],&hist[1],&hist[2],&hist[3]);
+		//outl and outr needed to be swapped here to be correct
+		ADPdecodebuffer(StreamBuffer+i,outr,outl,&hist[0],&hist[1],&hist[2],&hist[3]);
 		CurrentWriter();
 	}
 	sync_after_write((void*)cur_buf, BUFSIZE);
Index: kernel/string.c
===================================================================
--- kernel/string.c	(revision 334)
+++ kernel/string.c	(working copy)
@@ -120,7 +120,7 @@
 
 void *memset(void *dst, int x, size_t n)
 {
-	unsigned char *p;
+	volatile unsigned char *p;
 
 	for (p = dst; n; n--)
 		*p++ = x;
Index: kernel/vsprintf.c
===================================================================
--- kernel/vsprintf.c	(revision 334)
+++ kernel/vsprintf.c	(working copy)
@@ -329,7 +329,7 @@
 		}
 			
 		if (file_opened == FR_OK) {
-			f_lseek(&dbgfile, dbgfile.fsize);
+			f_lseek(&dbgfile, dbgfile.obj.objsize);
 			f_write(&dbgfile, buffer, strlen(buffer), &read);
 			f_sync(&dbgfile);
 		}
Index: libcustomfat/include/fat.h
===================================================================
--- libcustomfat/include/fat.h	(revision 334)
+++ libcustomfat/include/fat.h	(working copy)
@@ -1,7 +1,7 @@
 /*
 	fat.h
 	Simple functionality for startup, mounting and unmounting of FAT-based devices.
-	
+
  Copyright (c) 2006 - 2012
 	Michael "Chishm" Chisholm
 	Dave "WinterMute" Murphy
@@ -73,7 +73,7 @@
 /*
 Mount the device pointed to by interface, and set up a devoptab entry for it as "name:".
 You can then access the filesystem using "name:/".
-This will mount the active partition or the first valid partition on the disc, 
+This will mount the active partition or the first valid partition on the disc,
 and will use a cache size optimized for the host system.
 */
 extern bool fatMountSimple (const char* name, const DISC_INTERFACE* interface);
@@ -111,7 +111,7 @@
 Methods to modify DOS File Attributes
 */
 int	FAT_getAttr(const char *file);
-int	FAT_setAttr(const char *file, int attr );
+int	FAT_setAttr(const char *file, uint8_t attr );
 
 #define LIBFAT_FEOS_MULTICWD
 
Index: libcustomfat/include/libfatversion.h
===================================================================
--- libcustomfat/include/libfatversion.h	(revision 334)
+++ libcustomfat/include/libfatversion.h	(working copy)
@@ -3,8 +3,8 @@
 
 #define _LIBFAT_MAJOR_	1
 #define _LIBFAT_MINOR_	0
-#define _LIBFAT_PATCH_	13
+#define _LIBFAT_PATCH_	14
 
-#define _LIBFAT_STRING "libFAT Release 1.0.13"
+#define _LIBFAT_STRING "libFAT Release 1.0.14"
 
 #endif // __LIBFATVERSION_H__
Index: libcustomfat/Makefile
===================================================================
--- libcustomfat/Makefile	(revision 334)
+++ libcustomfat/Makefile	(working copy)
@@ -6,7 +6,7 @@
  
 export LIBFAT_MAJOR	:= 1
 export LIBFAT_MINOR	:= 0
-export LIBFAT_PATCH	:= 13
+export LIBFAT_PATCH	:= 14
 
 export VERSTRING	:=	$(LIBFAT_MAJOR).$(LIBFAT_MINOR).$(LIBFAT_PATCH)
 
Index: libcustomfat/README
===================================================================
--- libcustomfat/README	(revision 334)
+++ libcustomfat/README	(working copy)
@@ -1,4 +1,4 @@
-This is pretty much just libfat-1.0.13, only 2 things were modified,
+This is pretty much just libfat-1.0.14, only 2 things were modified,
 partition.c line 183 from:
 
 if ( (sectorBuffer[BPB_bootSig_55] != 0x55) || (sectorBuffer[BPB_bootSig_AA] != 0xAA)) {
Index: libcustomfat/source/bit_ops.h
===================================================================
--- libcustomfat/source/bit_ops.h	(revision 334)
+++ libcustomfat/source/bit_ops.h	(working copy)
@@ -42,6 +42,17 @@
 	return ( item[offset] | (item[offset + 1] << 8) | (item[offset + 2] << 16) | (item[offset + 3] << 24));
 }
 
+static inline uint64_t u8array_to_u64 (const uint8_t* item, int offset) {
+	return (  (uint64_t)item[offset] |
+	         ((uint64_t)(item[offset + 1]) << 8) |
+	         ((uint64_t)(item[offset + 2]) << 16) |
+	         ((uint64_t)(item[offset + 3]) << 24) |
+	         ((uint64_t)(item[offset + 4]) << 32) |
+	         ((uint64_t)(item[offset + 5]) << 40) |
+	         ((uint64_t)(item[offset + 6]) << 48) |
+	         ((uint64_t)(item[offset + 7]) << 56));
+}
+
 static inline void u16_to_u8array (uint8_t* item, int offset, uint16_t value) {
 	item[offset]     = (uint8_t) value;
 	item[offset + 1] = (uint8_t)(value >> 8);
Index: libcustomfat/source/directory.c
===================================================================
--- libcustomfat/source/directory.c	(revision 334)
+++ libcustomfat/source/directory.c	(working copy)
@@ -45,9 +45,6 @@
 #define DIR_ENTRY_LAST 0x00
 #define DIR_ENTRY_FREE 0xE5
 
-#define LAST_LFN_POS (19*13)
-#define LAST_LFN_POS_CORRECTION (MAX_LFN_LENGTH-15)
-
 typedef unsigned short ucs2_t;
 
 // Long file name directory entry
@@ -315,6 +312,7 @@
 	while (!found && !notFound) {
 		if (_FAT_directory_incrementDirEntryPosition (partition, &entryEnd, false) == false) {
 			notFound = true;
+			break;
 		}
 
 		_FAT_cache_readPartialSector (partition->cache, entryData,
@@ -341,12 +339,10 @@
 			}
 			if (lfnExists) {
 				lfnPos = ((entryData[LFN_offset_ordinal] & ~LFN_END) - 1) * 13;
-				if (lfnPos > LAST_LFN_POS) {
-					// Force it within the buffer. Will corrupt the filename but prevent buffer overflows
-					lfnPos = LAST_LFN_POS;
-				}
 				for (i = 0; i < 13; i++) {
-					lfn[lfnPos + i] = entryData[LFN_offset_table[i]] | (entryData[LFN_offset_table[i]+1] << 8);
+					if (lfnPos + i < MAX_LFN_LENGTH - 1) {
+						lfn[lfnPos + i] = entryData[LFN_offset_table[i]] | (entryData[LFN_offset_table[i]+1] << 8);
+					}
 				}
 			}
 		} else if (entryData[DIR_ENTRY_attributes] & ATTRIB_VOL) {
@@ -498,11 +494,10 @@
 		} else {
 			// Copy the long file name data
 			lfnPos = ((entryData[LFN_offset_ordinal] & ~LFN_END) - 1) * 13;
-			if (lfnPos > LAST_LFN_POS) {
-				lfnPos = LAST_LFN_POS_CORRECTION;
-			}
 			for (i = 0; i < 13; i++) {
-				lfn[lfnPos + i] = entryData[LFN_offset_table[i]] | (entryData[LFN_offset_table[i]+1] << 8);
+				if (lfnPos + i < MAX_LFN_LENGTH - 1) {
+					lfn[lfnPos + i] = entryData[LFN_offset_table[i]] | (entryData[LFN_offset_table[i]+1] << 8);
+				}
 			}
 		}
 	}
@@ -511,6 +506,7 @@
 		return false;
 	}
 
+	entryStart = entry->dataStart;
 	if ((entryStart.cluster == entryEnd.cluster)
 		&& (entryStart.sector == entryEnd.sector)
 		&& (entryStart.offset == entryEnd.offset)) {
@@ -705,7 +701,9 @@
 			_FAT_fat_clusterToSector(partition, gapEnd.cluster) + gapEnd.sector,
 			gapEnd.offset * DIR_ENTRY_DATA_SIZE, DIR_ENTRY_DATA_SIZE);
 		if (entryData[0] == DIR_ENTRY_LAST) {
-			gapStart = gapEnd;
+			if (dirEntryRemain == size) {
+				gapStart = gapEnd;
+			}
 			-- dirEntryRemain;
 			endOfDirectory = true;
 		} else if (entryData[0] == DIR_ENTRY_FREE) {
@@ -912,6 +910,18 @@
 	int aliasLen;
 	int lfnLen;
 
+	// Remove trailing spaces
+	for (i = strlen (entry->filename) - 1; (i >= 0) && (entry->filename[i] == ' '); --i) {
+		entry->filename[i] = '\0';
+	}
+#if 0
+	// Remove leading spaces
+	for (i = 0; entry->filename[i] == ' '; ++i) ;
+	if (i > 0) {
+		memmove (entry->filename, entry->filename + i, strlen (entry->filename + i));
+	}
+#endif
+
 	// Make sure the filename is not 0 length
 	if (strnlen (entry->filename, MAX_FILENAME_LENGTH) < 1) {
 		return false;
@@ -923,16 +933,6 @@
 		return false;
 	}
 
-	// Remove trailing spaces
-	for (i = strlen (entry->filename) - 1; (i > 0) && (entry->filename[i] == ' '); --i) {
-		entry->filename[i] = '\0';
-	}
-	// Remove leading spaces
-	for (i = 0; (i < (int)strlen (entry->filename)) && (entry->filename[i] == ' '); ++i) ;
-	if (i > 0) {
-		memmove (entry->filename, entry->filename + i, strlen (entry->filename + i));
-	}
-
 	// Remove junk in filename
 	i = strlen (entry->filename);
 	memset (entry->filename + i, '\0', MAX_FILENAME_LENGTH - i);
@@ -972,17 +972,15 @@
 				_FAT_directory_entryExists (partition, alias, dirCluster))
 			{
 				// expand primary part to 8 characters long by padding the end with underscores
-				i = MAX_ALIAS_PRI_LENGTH - 1;
+				i = 0;
+				j = MAX_ALIAS_PRI_LENGTH;
 				// Move extension to last 3 characters
-				while (alias[i] != '.' && i > 0) i--;
-				if (i > 0) {
-					j = MAX_ALIAS_LENGTH - MAX_ALIAS_EXT_LENGTH - 2; // 1 char for '.', one for NUL, 3 for extension
-					memmove (alias + j, alias + i, strlen(alias) - i);
+				while (alias[i] != '.' && alias[i] != '\0') i++;
+				if (i < j) {
+					memmove (alias + j, alias + i, aliasLen - i + 1);
 					// Pad primary component
 					memset (alias + i, '_', j - i);
-					alias[MAX_ALIAS_LENGTH-1]=0;
 				}
-
 				// Generate numeric tail
 				for (i = 1; i <= MAX_NUMERIC_TAIL; i++) {
 					j = i;
Index: libcustomfat/source/fatfile.c
===================================================================
--- libcustomfat/source/fatfile.c	(revision 334)
+++ libcustomfat/source/fatfile.c	(working copy)
@@ -48,6 +48,10 @@
 bool _FAT_findEntry(const char *path, DIR_ENTRY *dirEntry) {
 	PARTITION *partition = _FAT_partition_getPartitionFromPath(path);
 
+	// Check Partition
+	if( !partition )
+		return false;
+
 	// Move the path pointer to the start of the actual path
 	if (strchr (path, ':') != NULL) {
 		path = strchr (path, ':') + 1;
@@ -58,22 +62,22 @@
 
 	// Search for the file on the disc
 	return _FAT_directory_entryFromPath (partition, dirEntry, path, NULL);
-	
+
 }
 
 int	FAT_getAttr(const char *file) {
 	DIR_ENTRY dirEntry;
 	if (!_FAT_findEntry(file,&dirEntry)) return -1;
-	 
+
 	return dirEntry.entryData[DIR_ENTRY_attributes];
 }
 
-int FAT_setAttr(const char *file, int attr) {
+int FAT_setAttr(const char *file, uint8_t attr) {
 
 	// Defines...
 	DIR_ENTRY_POSITION entryEnd;
 	PARTITION *partition = NULL;
-	DIR_ENTRY* dirEntry = NULL;
+	DIR_ENTRY dirEntry;
 
 	// Get Partition
 	partition = _FAT_partition_getPartitionFromPath( file );
@@ -81,7 +85,7 @@
 	// Check Partition
 	if( !partition )
 		return -1;
-	
+
 	// Move the path pointer to the start of the actual path
 	if (strchr (file, ':') != NULL)
 		file = strchr (file, ':') + 1;
@@ -89,11 +93,11 @@
 		return -1;
 
 	// Get DIR_ENTRY
-	if( !_FAT_directory_entryFromPath (partition, dirEntry, file, NULL) )
+	if( !_FAT_directory_entryFromPath (partition, &dirEntry, file, NULL) )
 		return -1;
 
 	// Get Entry-End
-	entryEnd = dirEntry->dataEnd;
+	entryEnd = dirEntry.dataEnd;
 
 	// Lock Partition
 	_FAT_lock(&partition->lock);
Index: libcustomfat/source/libfat.c
===================================================================
--- libcustomfat/source/libfat.c	(revision 334)
+++ libcustomfat/source/libfat.c	(working copy)
@@ -30,7 +30,7 @@
 #include <unistd.h>
 #include <string.h>
 #include <stdio.h>
-#include <sys/param.h>
+#include <limits.h>
 
 #include "common.h"
 #include "partition.h"
@@ -64,8 +64,9 @@
 	_FAT_ftruncate_r,
 	_FAT_fsync_r,
 	NULL,	/* Device data */
-	NULL,
-	NULL
+	NULL,	// chmod_r
+	NULL,	// fchmod_r
+	NULL	// rmdir_r
 };
 
 bool fatMount (const char* name, const DISC_INTERFACE* interface, sec_t startSector, uint32_t cacheSize, uint32_t SectorsPerPage) {
@@ -167,7 +168,7 @@
 	}
 
 	if (setAsDefaultDevice) {
-		char filePath[MAXPATHLEN * 2];
+		char filePath[PATH_MAX];
 		strcpy (filePath, _FAT_disc_interfaces[defaultDevice].name);
 		strcat (filePath, ":/");
 #ifdef ARGV_MAGIC
Index: libcustomfat/source/partition.c
===================================================================
--- libcustomfat/source/partition.c	(revision 334)
+++ libcustomfat/source/partition.c	(working copy)
@@ -99,10 +99,138 @@
 	FSIB_bootSig_AA = 0x1FF
 };
 
+// GPT header information block offsets
+enum GPT_Header_Fields
+{
+	GPT_SIG1 			= 0x00,
+	GPT_Revision			= 0x08,
+	GPT_Header_Size			= 0x0C,
+	GPT_Header_CRC32		= 0x10,
+	GPT_Header_Current_LBA		= 0x18,
+	GPT_Header_Backup_LBA		= 0x20,
+	GPT_Header_First_Usable_LBA	= 0x28,
+	GPT_Header_Last_Usable_LBA	= 0x30,
+	GPT_Disk_GUID			= 0x38,
+	GPT_Partition_Array_Start_LBA	= 0x48,
+	GPT_Partition_Count		= 0x50,
+	GPT_Partition_Entry_Size	= 0x54,
+	GPT_Partition_Array_CRC32	= 0x58
+};
+
+// GPT partition entry offsets
+enum GPT_Partition_Entry_Fields
+{
+	GPT_Partition_Type_GUID		= 0x00,
+	GPT_Partition_Unique_GUID	= 0x10,
+	GPT_Partition_First_LBA		= 0x20,
+	GPT_Partition_Last_LBA		= 0x28,	/* inclusive, usually odd */
+	GPT_Partition_Attribute_Flags	= 0x30,
+	GPT_Partition_Name		= 0x38,
+};
+
 static const char FAT_SIG[3] = {'F', 'A', 'T'};
 static const char FS_INFO_SIG1[4] = {'R', 'R', 'a', 'A'};
 static const char FS_INFO_SIG2[4] = {'r', 'r', 'A', 'a'};
+static const char GPT_SIG[8] = {'E', 'F', 'I', ' ', 'P', 'A', 'R', 'T'};
+static const uint32_t GPT_Invalid_GUID[4] = {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
+// EFI System Partition: {C12A7328-F81F-11D2-BA4B-00A0C93EC93B}
+static const uint32_t GPT_EFISYS_GUID[4] = {0x28732AC1, 0x1FF8D211, 0xBA4B00A0, 0xC93EC93B};
 
+#define GPT_PARTITION_ENTRY_SIZE 128
+#define GPT_PARTITION_COUNT_MAX 128
+
+/**
+ * Find the first valid partition on a GPT device.
+ * @param disc Disk device.
+ * @param gpt_lba LBA of GPT partition header sector.
+ * @param sectorBuffer Sector buffer.
+ * @return LBA of first valid partition, or 0 if none found.
+ */
+static sec_t FindFirstValidPartition_GPT_buf(const DISC_INTERFACE *disc, sec_t gpt_lba, uint8_t *sectorBuffer)
+{
+	sec_t partition_lba[128];
+	unsigned int partition_count;
+	int n, idx, gpt_lba_max;
+
+	if (!_FAT_disc_readSectors (disc, gpt_lba, 1, sectorBuffer)) return 0;
+
+	// Verify that this is in fact a GPT.
+	// NOTE: Not checking GPT version or CRC32.
+	if (memcmp(sectorBuffer, GPT_SIG, sizeof(GPT_SIG)) != 0) return 0;
+
+	// Assuming each partition entry is 128 bytes.
+	if (u8array_to_u32(sectorBuffer, GPT_Partition_Entry_Size) != GPT_PARTITION_ENTRY_SIZE)
+		return 0;
+
+	// Get the partition array information.
+	// NOTE: Starting LBA is 64-bit, but it's almost always 2.
+	gpt_lba = u8array_to_u32(sectorBuffer, GPT_Partition_Array_Start_LBA);
+	partition_count = u8array_to_u32(sectorBuffer, GPT_Partition_Count);
+	if (partition_count > GPT_PARTITION_COUNT_MAX) {
+		// We're only supporting the first 128 partitions.
+		// (Why do you have more than 128 partitions on a Wii HDD?)
+		partition_count = GPT_PARTITION_COUNT_MAX;
+	}
+
+	// Read from gpt_lba to gpt_lba + ((partition_count - 1) / 4).
+	// This assumes 512-byte sectors, 128 bytes per partition entry.
+	// 4096-byte sectors has fewer LBAs.
+	gpt_lba_max = ((partition_count - 1) / 4);
+	gpt_lba_max += gpt_lba;
+	idx = 0;	// index in partition_lba[]
+
+	for (; gpt_lba < gpt_lba_max && idx < partition_count; gpt_lba++) {
+		// Read the current sector.
+		memset(sectorBuffer, 0xFF, MAX_SECTOR_SIZE);
+		if (!_FAT_disc_readSectors (disc, gpt_lba, 1, sectorBuffer)) return 0;
+
+		// Process partition entries.
+		for (n = 0; n < MAX_SECTOR_SIZE && idx < partition_count;
+		     n += GPT_PARTITION_ENTRY_SIZE)
+		{
+			uint64_t lba64_start, lba64_end;
+
+			// Check if the partition GUIDs are valid.
+			if (!memcmp(&sectorBuffer[n + GPT_Partition_Type_GUID], GPT_Invalid_GUID, sizeof(GPT_Invalid_GUID)) ||
+			    !memcmp(&sectorBuffer[n + GPT_Partition_Unique_GUID], GPT_Invalid_GUID, sizeof(GPT_Invalid_GUID)))
+			{
+				// Invalid GUID. We're done processing this sector.
+				break;
+			}
+			else if (!memcmp(&sectorBuffer[n + GPT_Partition_Type_GUID], GPT_EFISYS_GUID, sizeof(GPT_EFISYS_GUID)))
+			{
+				// EFI System Partition. Ignore it.
+				continue;
+			}
+
+			// Save the partition LBA for later.
+			lba64_start = u8array_to_u64(sectorBuffer, n+GPT_Partition_First_LBA);
+			lba64_end = u8array_to_u64(sectorBuffer, n+GPT_Partition_Last_LBA);
+			if (lba64_start > 0xFFFFFFFFULL || lba64_end > 0xFFFFFFFFULL) {
+				// Partition is over the 32-bit sector limit.
+				// libcustomfat doesn't support this.
+				continue;
+			}
+
+			partition_lba[idx++] = (sec_t)lba64_start;
+		}
+	}
+
+	// Check the partitions to see which one is FAT.
+	for (n = 0; n < idx; n++) {
+		if(!_FAT_disc_readSectors (disc, partition_lba[n], 1, sectorBuffer)) return 0;
+
+		if (!memcmp(sectorBuffer + BPB_FAT16_fileSysType, FAT_SIG, sizeof(FAT_SIG)) ||
+			!memcmp(sectorBuffer + BPB_FAT32_fileSysType, FAT_SIG, sizeof(FAT_SIG))) {
+			// Found the FAT partition.
+			return partition_lba[n];
+		}
+	}
+
+	// No FAT partitions found.
+	return 0;
+}
+
 sec_t FindFirstValidPartition_buf(const DISC_INTERFACE* disc, uint8_t *sectorBuffer)
 {
 	uint8_t part_table[16*4];
@@ -117,6 +245,12 @@
 	memcpy(part_table,sectorBuffer+0x1BE,16*4);
 	ptr = part_table;
 
+	if (ptr[4] == 0xEE) {
+		// Device is partitioned using GPT.
+		sec_t gpt_lba = u8array_to_u32(ptr, 0x8);
+		return FindFirstValidPartition_GPT_buf(disc, gpt_lba, sectorBuffer);
+	}
+
 	for(i=0;i<4;i++,ptr+=16) {
 		sec_t part_lba = u8array_to_u32(ptr, 0x8);
 
Index: loader/data/background.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: loader/data/font.ttf
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: loader/extlibs/lib/libcustomfat.a
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: loader/include/font.h
===================================================================
--- loader/include/font.h	(revision 334)
+++ loader/include/font.h	(working copy)
@@ -22,6 +22,7 @@
 #ifndef __FONT_H__
 #define __FONT_H__
 
-void PrintFormat(u8 size, const u32 color, int x, int y, const char *str, ... );
+void PrintFormat(u8 size, const u32 color, int x, int y, const char *str, ... )
+	__attribute__ ((format (printf, 5, 6)));
 
 #endif
\ No newline at end of file
Index: loader/include/global.h
===================================================================
--- loader/include/global.h	(revision 334)
+++ loader/include/global.h	(working copy)
@@ -27,6 +27,7 @@
 #include "background_png.h"
 #include "Config.h"
 #include "grrlib.h"
+#include <ogc/lwp_watchdog.h>
 
 #ifndef HW_RVL
 #define HW_RVL
@@ -66,8 +67,21 @@
 #define SILVER				0xC0C0C0FF
 #define TEAL				0x008080FF
 #define WHITE				0xFFFFFFFF
-#define YELLOW				0xFFFF00FF
+#define YELLOW				0xFFF380FF
 
+#define BLUED				0x0000A0FF
+#define GREEND				0x254117FF
+#define REDD				0x800517FF
+#define PURPLED				0x800080FF
+#define BROWND				0x2B1B17FF
+#define ROSED				0x307D7EFF
+#define GOLDEN				0x7F5217FF
+#define BLUEL				0x4EE2ECFF
+#define GREENL				0x99C68EFF
+#define REDL				0xF75D59FF
+#define PURPLEL				0xF3E5ABFF
+#define BROWNL				0x98FF98FF
+
 #define		HW_REG_BASE		0xCD800000
 #define		HW_RESETS		(HW_REG_BASE + 0x194)
 
@@ -80,7 +94,6 @@
 	((typeof(x))(((u32)(x)) & (~(align-1))))
 
 extern bool UseSD;
-extern u32 Region;
 extern u32 POffset;
 extern NIN_CFG *ncfg;
 extern FILE *cfg;
@@ -87,7 +100,19 @@
 extern GRRLIB_ttfFont *myFont;
 extern GRRLIB_texImg *background;
 extern GRRLIB_texImg *screen_buffer;
+extern int which_bg;
+extern int menumod;
 
+enum
+{
+	TRI_NONE = 0,
+	TRI_GP1,
+	TRI_GP2,
+	TRI_AX,
+	TRI_VS4,
+	TRI_SB,
+} TRIGames;
+
 enum ContentType
 {
 	CONTENT_REQUIRED=	(1<< 0),	// not sure
@@ -95,6 +120,16 @@
 	CONTENT_OPTIONAL=	(1<<14),
 };
 
+enum {
+	BG_NONE,
+	BG_LIGHT,
+	BG_DARK,
+	BG_BARS,
+	BG_NOBAR,
+	BG_LEGACY,
+	BG_BLACK,
+	BG_NO_INIT
+};
 typedef struct
 {
 	u32 ID;				//	0	(0x1E4)
@@ -138,7 +173,8 @@
 void Initialise();
 bool LoadNinCFG();
 bool IsGCGame(u8 *Buffer);
-bool IsTRIGame(char *Path);
+u32 IsTRIGame(char *Path, u32 CurDICMD, u32 ISOShift);
+int CreateNewFile(char *Path, u32 size);
 void ExitToLoader(int ret);
 void ClearScreen();
 void CloseDevices();
@@ -147,6 +183,13 @@
 void DrawBuffer(void);
 void UpdateScreen(void);
 void Screenshot(void);
+void CheckTheme();
+void BackTheme();
+void DeleteCustom();
+void FadeIt();
+void FadeOut();
+void UpdateNinCFG();
+//void UpdateNinCFG();
 raw_irq_handler_t BeforeIOSReload();
 void AfterIOSReload(raw_irq_handler_t handle, u32 rev);
 
Index: loader/include/menu.h
===================================================================
--- loader/include/menu.h	(revision 334)
+++ loader/include/menu.h	(working copy)
@@ -23,18 +23,57 @@
 
 #include <gctypes.h>
 
-#define MAX_GAMES 500
+#define MAX_GAMES 1024
 
 typedef struct GameInfo 
 {
-	char ID[6];
-	char *Name;
-	char *Path;
+	char ID[6];		// ID6 of the game.
+	uint8_t NameAlloc;	// If non-zero, Name was allocated via strdup().
+	                        // Otherwise, it should NOT be free()'d!
+	uint8_t DiscNumber;	// Disc number.
+	char *Name;		// Game name. (If NameAlloc, strdup()'d.)
+	char *Path;		// File path.
 } gameinfo;
 
 void HandleSTMEvent(u32 event);
 void HandleWiiMoteEvent(s32 chan);
+void DeleteCache();
+void CheckTheme();
+void BackTheme();
+void FadeIt();
+void FadeOut();
+void Credits();
+/**
+ * Select the source device and game.
+ * @return TRUE to save settings; FALSE if no settings have been changed.
+ */
+bool SelectDevAndGame(void);
 
-bool SelectGame( void );
+/**
+ * Show a single message screen.
+ * @param msg Message.
+ */
+void ShowMessageScreen(const char *msg);
+
+/**
+ * Show a single message screen and then exit to loader..
+ * @param msg Message.
+ * @param ret Return value. If non-zero, text will be printed in red.
+ */
+void ShowMessageScreenAndExit(const char *msg, int ret)
+	__attribute__ ((noreturn));
+
+// Predefined messages.
+static inline void ShowLoadingScreen(void)
+{
+	ShowMessageScreen("Loading, please wait...");
+}
+
+/**
+ * Print Nintendont version and system hardware information.
+ */
+void PrintInfo(void);
+
 void PrintInfo( void );
+void ReconfigVideo( GXRModeObj *vidmode );
 #endif
Index: loader/include/titles.h
===================================================================
--- loader/include/titles.h	(revision 334)
+++ loader/include/titles.h	(working copy)
@@ -23,6 +23,6 @@
 #define __TITLES_H__
 
 s32 LoadTitles(void);
-bool SearchTitles(const char *titleID, char *titleName);
+const char *SearchTitles(const char *titleID);
 
 #endif
Index: loader/include/update.h
===================================================================
--- loader/include/update.h	(revision 334)
+++ loader/include/update.h	(working copy)
@@ -23,5 +23,15 @@
 #define __UPDATE_H__
 
 void UpdateNintendont(void);
-
+void UpdateLoader(void);
+void UpdateLegacy(void);
+void UpdateThemes(void);
+void UpdateBios(void);
+void UpdateOld(void);
+void UpdateOther(void);
+void SimpleBack(void);
+void UpdateGrad(void);
+void DownloadGame(void);
+void GDMenu(void);
+void DeleteCache();
 #endif
Index: loader/source/global.c
===================================================================
--- loader/source/global.c	(revision 334)
+++ loader/source/global.c	(working copy)
@@ -37,13 +37,14 @@
 #include "exi.h"
 #include "global.h"
 #include "font_ttf.h"
+#include "dip.h"
 
+int which_bg = BG_NO_INIT;
 
 GRRLIB_ttfFont *myFont;
 GRRLIB_texImg *background;
 GRRLIB_texImg *screen_buffer;
 
-u32 Region;
 u32 POffset;
 
 NIN_CFG* ncfg = (NIN_CFG*)0x93002900;
@@ -148,7 +149,6 @@
 }
 void Initialise()
 {
-	int i;
 	AUDIO_Init(NULL);
 	DSP_Init();
 	AUDIO_StopDMA();
@@ -156,14 +156,7 @@
 	CheckForGecko();
 	gprintf("GRRLIB_Init = %i\r\n", GRRLIB_Init());
 	myFont = GRRLIB_LoadTTF(font_ttf, font_ttf_size);
-	background = GRRLIB_LoadTexturePNG(background_png);
 	screen_buffer = GRRLIB_CreateEmptyTexture(rmode->fbWidth, rmode->efbHeight);
-	for (i=0; i<255; i +=5) // Fade background image in from black screen
-	{
-		GRRLIB_DrawImg(0, 0, background, 0, 1, 1, RGBA(255, 255, 255, i)); // Opacity increases as i does
-		GRRLIB_Render();
-	}
-	ClearScreen();
 	gprintf("Initialize Finished\r\n");
 }
 static void (*stub)() = (void*)0x80001800;
@@ -257,6 +250,7 @@
 			if(BytesRead != 540)
 				ConfigLoaded = false;
 		} break;
+		case 3:
 		case NIN_CFG_VERSION:
 		{
 			if(BytesRead != sizeof(NIN_CFG))
@@ -272,6 +266,12 @@
 		ncfg->MemCardBlocks = 0x2;//251 blocks
 		ncfg->Version = 3;
 	}
+	if (ncfg->Version < 4)
+	{
+		ncfg->VideoScale = 0;
+		ncfg->VideoOffset = 0;
+		ncfg->Version = 4;
+	}
 	if (ncfg->Version != NIN_CFG_VERSION)
 		ConfigLoaded = false;
 
@@ -287,7 +287,10 @@
 }
 inline void ClearScreen()
 {
-	GRRLIB_DrawImg(0, 0, background, 0, 1, 1, 0xFFFFFFFF);
+	if(which_bg == BG_NO_INIT)
+		GRRLIB_FillScreen(BLACK);
+	else
+		GRRLIB_DrawImg(0, 0, background, 0, 1, 1, 0xFFFFFFFF);
 }
 extern bool sdio_Deinitialize();
 extern void USBStorageOGC_Deinitialize();
@@ -345,46 +348,57 @@
 	return (AMB1 == 0x414D4231 || GCMagic == 0xC2339F3D);
 }
 
-u32 OffsetCheck[4] = {
-	0x210320, //GP1
-	0x25C0AC, //GP2
-	0x1821C4, //AX
-	0x20D7E8, //VS4
-};
+void UpdateNinCFG()
+{
+	if (ncfg->Version == 2)
+	{	//251 blocks, used to be there
+		ncfg->Unused = 0x2;
+		ncfg->Version = 3;
+	}
+	if (ncfg->Version == 3)
+	{	//new memcard setting space
+		ncfg->MemCardBlocks = ncfg->Unused;
+		ncfg->VideoScale = 0;
+		ncfg->VideoOffset = 0;
+		ncfg->Version = 4;
+	}
+	if (ncfg->Version == 4)
+	{	//Option got changed so not confuse it
+		//ncfg->Config &= ~NIN_CFG_HID;
+		ncfg->Version = 5;
+	}
+	if (ncfg->Version == 5)
+	{	//New Video Mode option
+		ncfg->VideoMode &= ~NIN_VID_PATCH_PAL50;
+		ncfg->Version = 6;
+	}
+}
 
-bool IsTRIGame(char *Path)
+int CreateNewFile(char *Path, u32 size)
 {
-	u32 DOLOffset = 0;
-	char FullPath[300];
-	sprintf(FullPath, "%s:%s", GetRootDevice(), Path);
-	FILE *f = fopen(FullPath, "rb");
+	FILE *f;
+	f = fopen(Path, "rb");
 	if(f != NULL)
-	{
-		fseek(f, 0x420, SEEK_SET);
-		fread(&DOLOffset, 1, 4, f);
+	{	//create ONLY new files
+		fclose(f);
+		return -1;
 	}
-	else
+	f = fopen(Path, "wb");
+	if(f == NULL)
 	{
-		char FSTPath[300];
-		sprintf(FSTPath, "%ssys/main.dol", FullPath);
-		f = fopen(FSTPath, "rb");
+		gprintf("Failed to create %s!\r\n", Path);
+		return -2;
 	}
-	if(f != NULL)
+	void *buf = malloc(size);
+	if(buf == NULL)
 	{
-		u32 i;
-		u32 BufAtOffset;
-		for(i = 0; i < 4; ++i)
-		{
-			fseek(f, DOLOffset+OffsetCheck[i], SEEK_SET);
-			fread(&BufAtOffset, 1, 4, f);
-			if(BufAtOffset == 0x386000A8)
-			{
-				fclose(f);
-				gprintf("Found TRIGame %u\n", i);
-				return true;
-			}
-		}
-		fclose(f);
+		gprintf("Failed to allocate %i bytes!\r\n", size);
+		return -3;
 	}
-	return false;
-}
+	memset(buf, 0, size);
+	fwrite(buf, 1, size, f);
+	free(buf);
+	fclose(f);
+	gprintf("Created %s with %i bytes!\r\n", Path, size);
+	return 0;
+}
\ No newline at end of file
Index: loader/source/grrlib.c
===================================================================
--- loader/source/grrlib.c	(revision 334)
+++ loader/source/grrlib.c	(working copy)
@@ -72,81 +72,39 @@
 	if (is_setup)  return 0;
 	
 	VIDEO_Init();
-	
-	// Grab a pointer to the video mode attributes
-	if ( !(rmode = VIDEO_GetPreferredMode(NULL)) )  return -1;
-	#ifdef DEBUG
-	if( !IsWiiU() )
+	if(CONF_GetProgressiveScan() > 0 && VIDEO_HaveComponentCable())
+	{
+		rmode = &TVNtsc480Prog;
+		gprintf("PROG\n");
+	}
+	else
 	{
-		if( rmode == &TVNtsc480Int )
-			gprintf("VI:TVNtsc480Int\r\n");
-		else if( rmode == &TVNtsc480IntDf )
-			gprintf("VI:TVNtsc480IntDf\r\n");
-		else if( rmode == &TVNtsc480IntAa )
-			gprintf("VI:TVNtsc480IntAa\r\n");
-		else if( rmode == &TVNtsc480Prog )
-			gprintf("VI:TVNtsc480Prog\r\n");
-		else if( rmode == &TVNtsc480ProgSoft )
-			gprintf("VI:TVNtsc480ProgSoft\r\n");
-		else if( rmode == &TVNtsc480ProgAa )
-			gprintf("VI:TVNtsc480ProgAa\r\n");
-
-		else if( rmode == &TVPal524IntAa )
-			gprintf("VI:TVPal524IntAa\r\n");
-		else if( rmode == &TVPal528Int )
-			gprintf("VI:TVPal528Int\r\n");
-		else if( rmode == &TVPal528IntDf )
-			gprintf("VI:TVPal528IntDf\r\n");
-		else if( rmode == &TVPal528IntDf )
-			gprintf("VI:TVPal528IntDf\r\n");
-		else if( rmode == &TVPal528IntDf )
-			gprintf("VI:TVPal528IntDf\r\n");
-	
-		else if( rmode == &TVEurgb60Hz480Int )
-			gprintf("VI:TVEurgb60Hz480Int\r\n");
-		else if( rmode == &TVEurgb60Hz480IntDf )
-			gprintf("VI:TVEurgb60Hz480IntDf\r\n");
-		else if( rmode == &TVEurgb60Hz480IntAa )
-			gprintf("VI:TVEurgb60Hz480IntAa\r\n");
-		else if( rmode == &TVEurgb60Hz480Prog )
-			gprintf("VI:TVEurgb60Hz480Prog\r\n");
-		else if( rmode == &TVEurgb60Hz480ProgSoft )
-			gprintf("VI:TVEurgb60Hz480ProgSoft\r\n");
-		else if( rmode == &TVEurgb60Hz480ProgAa )
-			gprintf("VI:TVEurgb60Hz480ProgAa\r\n");
+		switch(CONF_GetVideo())
+		{
+			case CONF_VIDEO_PAL:
+				if (CONF_GetEuRGB60() > 0)
+				{
+					gprintf("PAL60\n");
+					rmode = &TVEurgb60Hz480Int;
+				}
+				else
+				{
+					gprintf("PAL50\n");
+					rmode = &TVPal576IntDfScale;
+				}
+				break;
+			case CONF_VIDEO_MPAL:
+				gprintf("MPAL\n");
+				rmode = &TVMpal480IntDf;
+				break;
+			case CONF_VIDEO_NTSC:
+			default:
+				gprintf("NTSC\n");
+				rmode = &TVNtsc480Int;		
+				break;
+		}
 	}
-	#endif
 
-	bool progressive = (CONF_GetProgressiveScan() > 0) && VIDEO_HaveComponentCable();
-	switch( *(vu32*)0x800000CC )
-	{
-		default:
-		case 0:
-		{
-			if(progressive)
-				rmode = &TVNtsc480Prog;
-			else
-				rmode = &TVNtsc480IntDf;
-		} break;
-		case 1:
-		{
-			if(progressive)
-				rmode = &TVEurgb60Hz480Prog;
-			else
-				rmode = &TVPal528IntDf;
-		} break;
-		case 2:
-		{
-			rmode = &TVMpal480IntDf;
-		} break;
-		case 5:
-		{
-			if(progressive)
-				rmode = &TVEurgb60Hz480Prog;
-			else
-				rmode = &TVEurgb60Hz480IntDf;
-		} 
-	}
 	VIDEO_Configure(rmode);
 
 	// Get some memory to use for a "double buffered" frame buffer
@@ -1438,7 +1396,7 @@
 
 	va_list argp;
 	va_start(argp, text);
-	size = vsprintf(tmp, text, argp);
+	size = vsnprintf(tmp, sizeof(tmp), text, argp);
 	va_end(argp);
 
 	for (i=0; i<size; i++) {
@@ -1490,7 +1448,7 @@
 
 	va_list argp;
 	va_start(argp, text);
-	size = vsprintf(tmp, text, argp);
+	size = vsnprintf(tmp, sizeof(tmp), text, argp);
 	va_end(argp);
 
 	usb_sendbuffer_safe(1, tmp, size);
Index: loader/source/HID.c
===================================================================
--- loader/source/HID.c	(revision 334)
+++ loader/source/HID.c	(working copy)
@@ -19,11 +19,11 @@
 	/* I hope this covers all possible ini files */
 	gprintf("Trying to get VID%04x PID%04x\n", DeviceVID, DevicePID);
 	char filename[50];
-	sprintf(filename, "sd:/controllers/%04X_%04X.ini", DeviceVID, DevicePID);
+	snprintf(filename, sizeof(filename), "sd:/controllers/%04X_%04X.ini", DeviceVID, DevicePID);
 	FILE *f = fopen(filename, "rb");
 	if(f == NULL)
 	{
-		sprintf(filename, "usb:/controllers/%04X_%04X.ini", DeviceVID, DevicePID);
+		snprintf(filename, sizeof(filename), "usb:/controllers/%04X_%04X.ini", DeviceVID, DevicePID);
 		f = fopen(filename, "rb");
 		if(f == NULL)
 		{
Index: loader/source/http.c
===================================================================
--- loader/source/http.c	(revision 334)
+++ loader/source/http.c	(working copy)
@@ -334,11 +334,12 @@
 			return false;
 		}
 	}
-	char *request = (char *) memalign (32, 1024*6);
-	char *r = request;
-	r += sprintf (r, "GET %s HTTP/1.1\r\n", http_path);
-	r += sprintf (r, "Host: %s\r\n", http_host);
-	r += sprintf (r, "Cache-Control: no-cache\r\n\r\n");
+	char *request = (char *) memalign (32, 1024*2);
+	snprintf(request, 1024*2,
+		"GET %s HTTP/1.1\r\n"
+		"Host: %s\r\n"
+		"Cache-Control: no-cache\r\n\r\n",
+		http_path, http_host);
 
 	bool b = tcp_write (http_port == 443 ? sslcontext : s, (u8 *) request, strlen (request));
 
@@ -422,12 +423,13 @@
 	}
 
 	char *request = (char *) memalign (32, 1024*6);
-	char *r = request;
-	r += sprintf (r, "POST %s HTTP/1.1\r\n", http_path);
-	r += sprintf (r, "Host: %s\r\n", http_host);
-	r += sprintf (r, "Content-type: application/x-www-form-urlencoded\r\n");
-	r += sprintf (r, "Content-length: %d\r\n\r\n", strlen(postData));
-	r += sprintf (r, "%s", postData);
+	snprintf(request, 1024*6,
+		"POST %s HTTP/1.1\r\n"
+		"Host: %s\r\n"
+		"Content-type: application/x-www-form-urlencoded\r\n"
+		"Content-length: %d\r\n\r\n"
+		"%s",
+		http_path, http_host, strlen(postData), postData); 
 	
 	gprintf("\n request:\n");
 	//gprintf(request);
Index: loader/source/main.c
===================================================================
--- loader/source/main.c	(revision 334)
+++ loader/source/main.c	(working copy)
@@ -28,6 +28,7 @@
 
 #include <unistd.h>
 #include <sys/dir.h>
+#include <sys/stat.h>
 
 #include "exi.h"
 #include "dip.h"
@@ -44,11 +45,16 @@
 #include "titles.h"
 #include "ipl.h"
 #include "HID.h"
+#include "TRI.h"
 
 extern void __exception_setreload(int t);
 extern void __SYS_ReadROM(void *buf,u32 len,u32 offset);
 extern u32 __SYS_GetRTC(u32 *gctime);
 
+extern syssram* __SYS_LockSram();
+extern u32 __SYS_UnlockSram(u32 write);
+extern u32 __SYS_SyncSram(void);
+
 #define STATUS			((void*)0x90004100)
 #define STATUS_LOADING	(*(vu32*)(0x90004100))
 #define STATUS_SECTOR	(*(vu32*)(0x90004100 + 8))
@@ -59,8 +65,9 @@
 #define HW_DIFLAGS		0xD800180
 #define MEM_PROT		0xD8B420A
 
-#define IOCTL_ExecSuspendScheduler	1
-
+#define IOCTL_ExecSuspendScheduler 1
+ 	
+int intro = 0;
 static GXRModeObj *vmode = NULL;
 
 static const unsigned char Boot2Patch[] =
@@ -102,6 +109,8 @@
 extern DISC_INTERFACE __io_custom_usbstorage;
 extern vu32 FoundVersion;
 vu32 KernelLoaded = 0;
+int hid_count=0;
+
 u32 entrypoint = 0;
 char launch_dir[MAXPATHLEN] = {0};
 extern void __exception_closeall();
@@ -111,98 +120,95 @@
 static const char NIN_BUILD_STRING[] ALIGNED(32) = NIN_VERSION_STRING; // Version detection string used by nintendont launchers "$$Version:x.xxx"
 int main(int argc, char **argv)
 {
-	// Exit after 10 seconds if there is an error
+// Exit after 10 seconds if there is an error
 	__exception_setreload(10);
 //	u64 timeout = 0;
 	CheckForGecko();
 	DCInvalidateRange(loader_stub, 0x1800);
 	memcpy(loader_stub, (void*)0x80001800, 0x1800);
-
 	RAMInit();
-
-	//Meh, doesnt do anything anymore anyways
-	//STM_RegisterEventHandler(HandleSTMEvent);
-
+	
+ 	//Meh, doesnt do anything anymore anyways
+	//STM_RegisterEventHandler(HandleSTMEvent);	
+	
 	Initialise();
-
-	u32 u;
-	//Disables MEMPROT for patches
+	// Checking for storage devices...
+	ShowMessageScreen("Checking storage devices...");
+	
+ 	u32 u;
+ 	//Disables MEMPROT for patches
 	write16(MEM_PROT, 0);
 	//Patches FS access
 	for( u = 0x93A00000; u < 0x94000000; u+=2 )
 	{
-		if( memcmp( (void*)(u), FSAccessPattern, sizeof(FSAccessPattern) ) == 0 )
+	if( memcmp( (void*)(u), FSAccessPattern, sizeof(FSAccessPattern) ) == 0 )
 		{
-		//	gprintf("FSAccessPatch:%08X\r\n", u );
-			memcpy( (void*)u, FSAccessPatch, sizeof(FSAccessPatch) );
-			DCFlushRange((void*)u, sizeof(FSAccessPatch));
-			break;
-		}
+	// gprintf("FSAccessPatch:%08X\r\n", u );
+	memcpy( (void*)u, FSAccessPatch, sizeof(FSAccessPatch) );
+	DCFlushRange((void*)u, sizeof(FSAccessPatch));
+	break;
+		}		
 	}
-
-	//for BT.c
+ 	//for BT.c
 	CONF_GetPadDevices((conf_pads*)0x932C0000);
 	DCFlushRange((void*)0x932C0000, sizeof(conf_pads));
 	*(vu32*)0x932C0490 = CONF_GetIRSensitivity();
 	*(vu32*)0x932C0494 = CONF_GetSensorBarPosition();
 	DCFlushRange((void*)0x932C0490, 8);
-
 	if(LoadKernel() < 0)
 	{
-		ClearScreen();
-		gprintf("Failed to load kernel from NAND!\r\n");
-		PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, 232, "Failed to load kernel from NAND!" );
-		ExitToLoader(1);
+	ClearScreen();
+	gprintf("Failed to load kernel from NAND!\r\n");
+	ShowMessageScreenAndExit("Failed to load kernel from NAND!", 1);
 	}
 	InsertModule((char*)kernel_bin, kernel_bin_size);
-
+	
 	memset( (void*)0x92f00000, 0, 0x100000 );
 	DCFlushRange( (void*)0x92f00000, 0x100000 );
-
+	
 	DCInvalidateRange( (void*)0x939F02F0, 0x20 );
-
+	
 	memcpy( (void*)0x939F02F0, Boot2Patch, sizeof(Boot2Patch) );
-
+	
 	DCFlushRange( (void*)0x939F02F0, 0x20 );
-
-	//libogc still has that, lets close it
-	__ES_Close();
+ 	//libogc still has that, lets close it
+	__ES_Close();	
 	s32 fd = IOS_Open( "/dev/es", 0 );
-
-	memset( STATUS, 0xFFFFFFFF, 0x20  );
+	
+	memset( STATUS, 0xFFFFFFFF, 0x20 );
 	DCFlushRange( STATUS, 0x20 );
-
-	memset( (void*)0x91000000, 0xFFFFFFFF, 0x20  );
+	
+	memset( (void*)0x91000000, 0xFFFFFFFF, 0x20 );
 	DCFlushRange( (void*)0x91000000, 0x20 );
-
+	
 	*(vu32*)0xD3003420 = 0; //make sure kernel doesnt reload
-
+	
 	raw_irq_handler_t irq_handler = BeforeIOSReload();
 	IOS_IoctlvAsync( fd, 0x1F, 0, 0, &IOCTL_Buf, NULL, NULL );
 	AfterIOSReload( irq_handler, FoundVersion );
+        while(1)
+        {
+                DCInvalidateRange( STATUS, 0x20 );
+                if((STATUS_LOADING > 0 || abs(STATUS_LOADING) > 1) && STATUS_LOADING < 20)
+                {
+                        gprintf("Kernel sent signal\n");
+                        break;
+                }
+        }
 
-	while(1)
-	{
-		DCInvalidateRange( STATUS, 0x20 );
-		if((STATUS_LOADING > 0 || abs(STATUS_LOADING) > 1) && STATUS_LOADING < 20)
-		{
-			gprintf("Kernel sent signal\n");
-			break;
-		}
-	}
-
 	/* For slow USB HDDs */
 	time_t timeout = time(NULL);
 	while(time(NULL) - timeout < 10)
 	{
-		if(__io_custom_usbstorage.startup() && __io_custom_usbstorage.isInserted())
-			break;
-		usleep(50000);
+	if(__io_custom_usbstorage.startup() && __io_custom_usbstorage.isInserted())
+	break;
+	usleep(50000);
 	}
 	fatInitDefault();
+	DeleteCache();
 
-	gprintf("Nintendont at your service!\r\n%s\r\n", NIN_BUILD_STRING);
-	KernelLoaded = 1;
+ 	gprintf("Nintendont at your service!\r\n%s\r\n", NIN_BUILD_STRING);
+ 	KernelLoaded = 1;
 
 	char* first_slash = strrchr(argv[0], '/');
 	if (first_slash != NULL) strncpy(launch_dir, argv[0], first_slash-argv[0]+1);
@@ -210,13 +216,21 @@
 
 	FPAD_Init();
 	FPAD_Update();
-
-	PrintInfo();
-	PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + + 430, MENU_POS_Y + 20*1, "Home: Exit");
-	PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + + 430, MENU_POS_Y + 20*2, "A   : Select");
-	GRRLIB_Render();
-	ClearScreen();
-
+	
+	//PrintInfo();
+	//				if (which_bg == BG_NONE)
+	//				{
+	//PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + + 430, MENU_POS_Y, "  Home: Exit");
+	//PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + + 430, MENU_POS_Y + 20*1, "  A   : Select");
+	//				}
+	//				else if (which_bg == BG_LEGACY)
+	//				{
+	//PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + + 430, MENU_POS_Y, "  Home: Exit");
+	//PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + + 430, MENU_POS_Y + 20*1, "  A   : Select");
+	//				}
+	//GRRLIB_Render();
+    //ClearScreen();
+		
 	/* Read IPL Font before doing any patches */
 	void *fontbuffer = memalign(32, 0x50000);
 	__SYS_ReadROM((void*)fontbuffer,0x50000,0x1AFF00);
@@ -224,7 +238,7 @@
 	DCInvalidateRange( (void*)0x93100000, 0x50000 );
 	free(fontbuffer);
 	//gprintf("Font: 0x1AFF00 starts with %.4s, 0x1FCF00 with %.4s\n", (char*)0x93100000, (char*)0x93100000 + 0x4D000);
-
+	
 	// Simple code to autoupdate the meta.xml in Nintendont's folder
 	FILE *meta = fopen("meta.xml", "w");
 	if(meta != NULL)
@@ -238,18 +252,13 @@
 		fclose(meta);
 	}
 	LoadTitles();
-
 	memset((void*)ncfg, 0, sizeof(NIN_CFG));
-
+	 
 	bool argsboot = false;
 	if(argc > 1) //every 0x00 gets counted as one arg so just make sure its more than the path and copy
-	{
-		memcpy(ncfg, argv[1], sizeof(NIN_CFG));
-		if (ncfg->Version == 2)	//need to upgrade config from ver 2 to ver 3
-		{
-			ncfg->MemCardBlocks = 0x2;//251 blocks
-			ncfg->Version = 3;
-		}
+	{	
+		memcpy(ncfg, argv[1], sizeof(NIN_CFG));	
+		UpdateNinCFG(); //support for old versions with this
 		if(ncfg->Magicbytes == 0x01070CF6 && ncfg->Version == NIN_CFG_VERSION && ncfg->MaxPads <= NIN_CFG_MAXPAD)
 		{
 			if(ncfg->Config & NIN_CFG_AUTO_BOOT)
@@ -258,9 +267,61 @@
 				argsboot = true;
 			}
 		}
+			GRRLIB_FreeTexture(background);
+			CheckTheme();
+			FadeIt();
+		// Prevent autobooting if B is pressed
+		int i = 0;
+		while((ncfg->Config & NIN_CFG_AUTO_BOOT) && (i < 500000)) // wait for wiimote re-sync
+		{	
+			if (i == 0) {
+				PrintInfo();
+        if (which_bg == BG_NONE)
+        {
+           PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 320 - 90, MENU_POS_Y + 20*10, "B: Cancel Autoboot");
+           GRRLIB_Render();
+           ClearScreen();
+        }
+        else if (which_bg == BG_LEGACY)
+        {
+           PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 320 - 90, MENU_POS_Y + 20*10, "B: Cancel Autoboot");
+           GRRLIB_Render();
+           ClearScreen();
+        }
+        else if (which_bg == BG_BLACK)
+        {
+           GRRLIB_Render();
+           ClearScreen();
+        }
+        else
+        {
+		PrintFormat(DEFAULT_SIZE, BLACK, 230, MENU_POS_Y + 406, "B: Cancel Autoboot");
+		PrintFormat(DEFAULT_SIZE, BLACK, 230, MENU_POS_Y + 410, "B: Cancel Autoboot");
+		PrintFormat(DEFAULT_SIZE, BLACK, 228, MENU_POS_Y + 408, "B: Cancel Autoboot");
+		PrintFormat(DEFAULT_SIZE, BLACK, 232, MENU_POS_Y + 408, "B: Cancel Autoboot");
+		PrintFormat(DEFAULT_SIZE, BLACK, 228, MENU_POS_Y + 406, "B: Cancel Autoboot");
+		PrintFormat(DEFAULT_SIZE, BLACK, 232, MENU_POS_Y + 410, "B: Cancel Autoboot");
+		PrintFormat(DEFAULT_SIZE, BLACK, 228, MENU_POS_Y + 410, "B: Cancel Autoboot");
+		PrintFormat(DEFAULT_SIZE, BLACK, 232, MENU_POS_Y + 406, "B: Cancel Autoboot"); 
+        PrintFormat(DEFAULT_SIZE, WHITE, 230, MENU_POS_Y + 408, "B: Cancel Autoboot");
+		GRRLIB_Render();
+		ClearScreen();
+        }
+		}
+		FPAD_Update();
+			if (FPAD_Cancel(0)) {
+				ncfg->Config &= ~NIN_CFG_AUTO_BOOT;
+				FadeOut();
+				BackTheme();
+				break;
+			}
+			i++;
+		}
 	}
+
 	if(argsboot == false)
-	{
+	{			
+		//UpdateNinCFG(); //support for old versions with this
 		if (LoadNinCFG() == false)
 		{
 			memset(ncfg, 0, sizeof(NIN_CFG));
@@ -271,30 +332,60 @@
 			ncfg->MaxPads = NIN_CFG_MAXPAD;
 			ncfg->MemCardBlocks = 0x2;//251 blocks
 		}
-
+		GRRLIB_FreeTexture(background);
+		CheckTheme();
+		FadeIt();
 		// Prevent autobooting if B is pressed
 		int i = 0;
-		while((ncfg->Config & NIN_CFG_AUTO_BOOT) && i < 1000000) // wait for wiimote re-synch
-		{
+		while((ncfg->Config & NIN_CFG_AUTO_BOOT) && (i < 500000)) // wait for wiimote re-sync
+		{	
 			if (i == 0) {
-				PrintInfo();
-				PrintFormat(DEFAULT_SIZE, BLACK, 320 - 90, MENU_POS_Y + 20*10, "B: Cancel Autoboot");
-				GRRLIB_Render();
-				ClearScreen();
-			}
-			
+				PrintInfo();		
+        if (which_bg == BG_NONE)
+        {
+            PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 320 - 90, MENU_POS_Y + 20*10, "B: Cancel Autoboot");
+            GRRLIB_Render();
+			ClearScreen();
+        }
+        else if (which_bg == BG_LEGACY)
+        {
+           PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 320 - 90, MENU_POS_Y + 20*10, "B: Cancel Autoboot");
+           GRRLIB_Render();
+           ClearScreen();
+        }
+        else if (which_bg == BG_BLACK)
+        {
+           GRRLIB_Render();
+           ClearScreen();
+        }
+        else
+        {
+		PrintFormat(DEFAULT_SIZE, BLACK, 230, MENU_POS_Y + 406, "B: Cancel Autoboot");
+		PrintFormat(DEFAULT_SIZE, BLACK, 230, MENU_POS_Y + 410, "B: Cancel Autoboot");
+		PrintFormat(DEFAULT_SIZE, BLACK, 228, MENU_POS_Y + 408, "B: Cancel Autoboot");
+		PrintFormat(DEFAULT_SIZE, BLACK, 232, MENU_POS_Y + 408, "B: Cancel Autoboot");
+		PrintFormat(DEFAULT_SIZE, BLACK, 228, MENU_POS_Y + 406, "B: Cancel Autoboot");
+		PrintFormat(DEFAULT_SIZE, BLACK, 232, MENU_POS_Y + 410, "B: Cancel Autoboot");
+		PrintFormat(DEFAULT_SIZE, BLACK, 228, MENU_POS_Y + 410, "B: Cancel Autoboot");
+		PrintFormat(DEFAULT_SIZE, BLACK, 232, MENU_POS_Y + 406, "B: Cancel Autoboot"); 
+        PrintFormat(DEFAULT_SIZE, WHITE, 230, MENU_POS_Y + 408, "B: Cancel Autoboot");
+		GRRLIB_Render();
+		ClearScreen();
+        }
+		}
 			FPAD_Update();
-
 			if (FPAD_Cancel(0)) {
-				ncfg->Config &= ~NIN_CFG_AUTO_BOOT;
+			ncfg->Config &= ~NIN_CFG_AUTO_BOOT;
+			FadeOut();
+			BackTheme();
 				break;
 			}
-
 			i++;
 		}
 	}
+
+	ReconfigVideo(rmode);
 	UseSD = (ncfg->Config & NIN_CFG_USB) == 0;
-
 	bool progressive = (CONF_GetProgressiveScan() > 0) && VIDEO_HaveComponentCable();
 	if(progressive) //important to prevent blackscreens
 		ncfg->VideoMode |= NIN_VID_PROG;
@@ -301,9 +392,21 @@
 	else
 		ncfg->VideoMode &= ~NIN_VID_PROG;
 
-	if((ncfg->Config & NIN_CFG_AUTO_BOOT) == 0)
+	bool SaveSettings = false;
+	if(!(ncfg->Config & NIN_CFG_AUTO_BOOT))
+	{	
+		BackTheme();
+		FadeIt();
+		// Not autobooting.
+		// Prompt the user to select a device and game.
+		SaveSettings = SelectDevAndGame();
+	}
+	else
 	{
-		while (1)
+		// Autobooting.
+		gprintf("Autobooting:\"%s\"\r\n", ncfg->GamePath );
+		PrintInfo();
+		/*while (1)
 		{
 			VIDEO_WaitVSync();
 			FPAD_Update();
@@ -310,13 +413,22 @@
 
 			UseSD = (ncfg->Config & NIN_CFG_USB) == 0;
 			PrintInfo();
-			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "Home: Exit");
-			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*2, "A   : Select");
-			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 53 * 6 - 8, MENU_POS_Y + 20 * 6, UseSD ? ARROW_LEFT : "");
-			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 53 * 6 - 8, MENU_POS_Y + 20 * 7, UseSD ? "" : ARROW_LEFT);
-			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 47 * 6 - 8, MENU_POS_Y + 20 * 6, " SD  ");
-			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 47 * 6 - 8, MENU_POS_Y + 20 * 7, "USB  ");
-
+			if (which_bg == BG_NONE)
+			{
+			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 53 * 6 - 8, MENU_POS_Y + 20 * 8, UseSD ? ARROW_LEFT : "");
+			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 53 * 6 - 8, MENU_POS_Y + 20 * 9, UseSD ? "" : ARROW_LEFT);
+			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 47 * 6 - 8, MENU_POS_Y + 20 * 8, " SD  ");
+			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 47 * 6 - 8, MENU_POS_Y + 20 * 9, "USB  ");}
+			else if (which_bg == BG_LEGACY)
+			{
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 53 * 6 - 8, MENU_POS_Y + 20 * 8, UseSD ? ARROW_LEFT : "");
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 53 * 6 - 8, MENU_POS_Y + 20 * 9, UseSD ? "" : ARROW_LEFT);
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 47 * 6 - 8, MENU_POS_Y + 20 * 8, " SD  ");
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 47 * 6 - 8, MENU_POS_Y + 20 * 9, "USB  ");}
 			if (FPAD_OK(0))
 				break;
 
@@ -323,7 +435,8 @@
 			if (FPAD_Start(1))
 			{
 				ClearScreen();
-				PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Returning to loader...");
+				if (which_bg == BG_NONE)
+				{PrintFormat(DEFAULT_SIZE, MAROON, 212, 232, "Returning to loader...");}
 				ExitToLoader(0);
 			}
 			if (FPAD_Down(0))
@@ -336,31 +449,39 @@
 			ClearScreen();
 		}
 		ClearScreen();
-		PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Loading, please wait...");
+		if (which_bg == BG_NONE)
+		{PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Loading, please wait...");}
+		else if (which_bg == BG_LEGACY)
+		{PrintFormat(DEFAULT_SIZE, WHITE, 212, 232, "Loading, please wait...");} */
 		GRRLIB_Render();
 		ClearScreen();
 	}
 
-	/*FILE *out = fopen("/kernel.bin", "wb");
-	fwrite( (char*)0x90100000, 1, NKernelSize, out );
-	fclose(out);*/
-
-//Load config
-
-//Reset drive
-
-	bool SaveSettings = false;
-	if( ncfg->Config & NIN_CFG_AUTO_BOOT )
-		gprintf("Autobooting:\"%s\"\r\n", ncfg->GamePath );
-	else
-		SaveSettings = SelectGame();
-
+//Init DI and set correct ID if needed
 	u32 CurDICMD = 0;
-	//Init DI and set correct ID if needed
 	if( memcmp(ncfg->GamePath, "di", 3) == 0 )
 	{
 		ClearScreen();
+		if (which_bg == BG_NONE)
+		{
 		PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Loading, please wait...");
+		}
+		else if (which_bg == BG_LEGACY)
+		{
+		PrintFormat(DEFAULT_SIZE, WHITE, 212, 232, "Loading, please wait...");
+		}
+		else
+		{
+		PrintFormat(DEFAULT_SIZE, BLACK, 230, MENU_POS_Y + 406, "Loading, please wait...");
+		PrintFormat(DEFAULT_SIZE, BLACK, 230, MENU_POS_Y + 410, "Loading, please wait...");
+		PrintFormat(DEFAULT_SIZE, BLACK, 228, MENU_POS_Y + 408, "Loading, please wait...");
+		PrintFormat(DEFAULT_SIZE, BLACK, 232, MENU_POS_Y + 408, "Loading, please wait...");
+		PrintFormat(DEFAULT_SIZE, BLACK, 228, MENU_POS_Y + 406, "Loading, please wait...");
+		PrintFormat(DEFAULT_SIZE, BLACK, 232, MENU_POS_Y + 410, "Loading, please wait...");
+		PrintFormat(DEFAULT_SIZE, BLACK, 228, MENU_POS_Y + 410, "Loading, please wait...");
+		PrintFormat(DEFAULT_SIZE, BLACK, 232, MENU_POS_Y + 406, "Loading, please wait...");
+		PrintFormat(DEFAULT_SIZE, WHITE, 230, MENU_POS_Y + 408, "Loading, please wait...");		
+		}
 		GRRLIB_Render();
 		ClearScreen();
 
@@ -376,7 +497,7 @@
 			ExitToLoader(1);
 		}
 		DI_Close();
-
+		
 		u8 *DIBuf = memalign(32,0x800);
 		memset(DIBuf, 0, 0x20);
 		DCFlushRange(DIBuf, 0x20);
@@ -405,7 +526,7 @@
 		FILE *cfg;
 		char ConfigPath[20];
 		// Todo: detects the boot device to prevent writing twice on the same one
-		sprintf(ConfigPath, "/nincfg.bin"); // writes config to boot device, loaded on next launch
+		strcpy(ConfigPath, "/nincfg.bin"); // writes config to boot device, loaded on next launch
 		cfg = fopen(ConfigPath, "wb");
 		if( cfg != NULL )
 		{
@@ -412,7 +533,7 @@
 			fwrite( ncfg, sizeof(NIN_CFG), 1, cfg );
 			fclose( cfg );
 		}
-		sprintf(ConfigPath, "%s:/nincfg.bin", GetRootDevice()); // writes config to game device, used by kernel
+		snprintf(ConfigPath, sizeof(ConfigPath), "%s:/nincfg.bin", GetRootDevice()); // writes config to game device, used by kernel
 		cfg = fopen(ConfigPath, "wb");
 		if( cfg != NULL )
 		{
@@ -422,14 +543,16 @@
 	}
 	u32 ISOShift = 0;
 	if(memcmp(&(ncfg->GameID), "COBR", 4) == 0 || memcmp(&(ncfg->GameID), "GGCO", 4) == 0
-		|| memcmp(&(ncfg->GameID), "GCOP", 4) == 0 || memcmp(&(ncfg->GameID), "RGCO", 4) == 0)
-	{
+	|| memcmp(&(ncfg->GameID), "GCO", 3) == 0 || memcmp(&(ncfg->GameID), "RGCO", 4) == 0)
+		{
+		which_bg = BG_NONE;
+		BackTheme();
+
 		u32 i, j = 0;
 		u32 Offsets[15];
 		gameinfo gi[15];
 		FILE *f = NULL;
 		u8 *MultiHdr = memalign(32, 0x800);
-		u8 *GameHdr = memalign(32, 0x800);
 		if(CurDICMD)
 		{
 			ReadRealDisc(MultiHdr, 0, 0x800, CurDICMD);
@@ -437,74 +560,90 @@
 		else if(strstr(ncfg->GamePath, ".iso") != NULL)
 		{
 			char GamePath[255];
-			sprintf( GamePath, "%s:%s", GetRootDevice(), ncfg->GamePath );
+			snprintf(GamePath, sizeof(GamePath), "%s:%s", GetRootDevice(), ncfg->GamePath);
 			f = fopen(GamePath, "rb");
 			fread(MultiHdr,1,0x800,f);
 		}
-		u32 NeedShift = (*(vu32*)(MultiHdr+4) == 0x44564439);
-		for(i = 0x40; i < 0x100; i += 4)
+//Damn you COD for sharing this ID!
+		if(memcmp(MultiHdr, "GCO", 3) == 0 && memcmp(MultiHdr+4, "52", 3) == 0)
 		{
-			u32 TmpOffset = *(vu32*)(MultiHdr+i);
-			if(TmpOffset > 0)
-			{
-				Offsets[j] = NeedShift ? TmpOffset << 2 : TmpOffset;
-				if(CurDICMD)
-				{
-					ReadRealDisc(GameHdr, Offsets[j], 0x800, CurDICMD);
-				}
-				else
-				{
-					fseek(f, Offsets[j], SEEK_SET);
-					fread(GameHdr, 1, 0x800, f);
-				}
-				memcpy(gi[j].ID, GameHdr, 6);
-				gi[j].Name = strdup((char*)GameHdr+0x20);
-				j++;
-				if(j == 15) break;
-			}
+			free(MultiHdr);
+			if(f) fclose(f);
 		}
-		free(GameHdr);
-		free(MultiHdr);
-		if(f) fclose(f);
-		bool redraw = 1;
-		ClearScreen();
-		u32 PosX = 0;
-		u32 UpHeld = 0, DownHeld = 0;
-		while(1)
+		else
 		{
-			VIDEO_WaitVSync();
-			FPAD_Update();
-			if( FPAD_OK(0) )
-				break;
-			else if( FPAD_Down(1) )
+			u8 *GameHdr = memalign(32, 0x800);
+			u32 NeedShift = (*(vu32*)(MultiHdr+4) == 0x44564439);
+			for(i = 0x40; i < 0x100; i += 4)
 			{
-				if(DownHeld == 0 || DownHeld > 10)
+				u32 TmpOffset = *(vu32*)(MultiHdr+i);
+				if(TmpOffset > 0)
 				{
-					PosX++;
-					if(PosX == j) PosX = 0;
-					redraw = true;
+					Offsets[j] = NeedShift ? TmpOffset << 2 : TmpOffset;
+					if(CurDICMD)
+					{
+						ReadRealDisc(GameHdr, Offsets[j], 0x800, CurDICMD);
+					}
+					else
+					{
+						fseek(f, Offsets[j], SEEK_SET);
+						fread(GameHdr, 1, 0x800, f);
+					}
+					memcpy(gi[j].ID, GameHdr, 6);
+					gi[j].Name = strdup((char*)GameHdr+0x20);
+					j++;
+					if(j == 15) break;
 				}
-				DownHeld++;
 			}
-			else
-				DownHeld = 0;
-			if( FPAD_Up(1) )
+			free(GameHdr);
+			free(MultiHdr);
+			if(f) fclose(f);
+			bool redraw = 1;
+			ClearScreen();
+			u32 PosX = 0;
+			u32 UpHeld = 0, DownHeld = 0;
+			while(1)
 			{
-				if(UpHeld == 0 || UpHeld > 10)
+				VIDEO_WaitVSync();
+				FPAD_Update();
+				if( FPAD_OK(0) )
+					break;
+				else if( FPAD_Down(1) )
 				{
-					if(PosX == 0) PosX = j;
-					PosX--;
-					redraw = true;
+					if(DownHeld == 0 || DownHeld > 10)
+					{
+						PosX++;
+						if(PosX == j) PosX = 0;
+						redraw = true;
+					}
+					DownHeld++;
 				}
-				UpHeld++;
-			}
-			else
-				UpHeld = 0;
-			if( redraw )
+				else
+					DownHeld = 0;
+				if( FPAD_Up(1) )
+				{
+					if(UpHeld == 0 || UpHeld > 10)
+					{
+						if(PosX == 0) PosX = j;
+						PosX--;
+						redraw = true;
+					}
+					UpHeld++;
+				}
+				else
+					UpHeld = 0;
+				if( redraw )
 			{
 				PrintInfo();
 				for( i=0; i < j; ++i )
-					PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*5 + i * 20, "%50.50s [%.6s]%s", gi[i].Name, gi[i].ID, i == PosX ? ARROW_LEFT : " " );
+		if (which_bg == BG_NONE)
+		{
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*5 + i * 20, "%50.50s [%.6s]%s", gi[i].Name, gi[i].ID, i == PosX ? ARROW_LEFT : " " );
+		}
+		else if (which_bg == BG_LEGACY)
+		{
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*5 + i * 20, "%50.50s [%.6s]%s", gi[i].Name, gi[i].ID, i == PosX ? ARROW_LEFT : " " );
+		}
 				GRRLIB_Render();
 				Screenshot();
 				ClearScreen();
@@ -514,10 +653,12 @@
 		ISOShift = Offsets[PosX];
 		memcpy(&(ncfg->GameID), gi[PosX].ID, 4);
 	}
-	*(vu32*)0xD300300C = ISOShift; //multi-iso games
+	}
+//multi-iso game hack
+	*(vu32*)0xD300300C = ISOShift;
 
-	//Set Language
-	if(ncfg->Language == NIN_LAN_AUTO)
+//Set Language
+	if(ncfg->Language == NIN_LAN_AUTO || ncfg->Language >= NIN_LAN_LAST)
 	{
 		switch (CONF_GetLanguage())
 		{
@@ -543,14 +684,18 @@
 	}
 
 //setup memory card
+	u32 IsTRIGame = 0;
+	if(ncfg->GameID != 0x47545050) //Damn you Knights Of The Temple!
+	IsTRIGame = TRISetupGames(ncfg->GamePath, CurDICMD, ISOShift);
+
 	if(ncfg->Config & NIN_CFG_MEMCARDEMU)
 	{
 		char BasePath[20];
-		sprintf(BasePath, "%s:/saves", GetRootDevice());
+		snprintf(BasePath, sizeof(BasePath), "%s:/saves", GetRootDevice());
 		mkdir(BasePath, S_IREAD | S_IWRITE);
 		char MemCardName[8];
 		memset(MemCardName, 0, 8);
-		if ( ncfg->Config & NIN_CFG_MC_MULTI )
+		if (( ncfg->Config & NIN_CFG_MC_MULTI ) && (IsTRIGame == 0)) //(TRIGame == TRI_NONE)
 		{
 			if ((ncfg->GameID & 0xFF) == 'J')  // JPN games
 				memcpy(MemCardName, "ninmemj", 7);
@@ -557,10 +702,12 @@
 			else
 				memcpy(MemCardName, "ninmem", 6);
 		}
+		else if(IsTRIGame != 0) //if((IsTRIGame(ncfg->GamePath, CurDICMD, ISOShift) != 0))  
+			ncfg->Config &= ~NIN_CFG_MEMCARDEMU;
 		else
 			memcpy(MemCardName, &(ncfg->GameID), 4);
 		char MemCard[30];
-		sprintf(MemCard, "%s/%s.raw", BasePath, MemCardName);
+		snprintf(MemCard, sizeof(MemCard), "%s/%s.raw", BasePath, MemCardName);
 		gprintf("Using %s as Memory Card.\r\n", MemCard);
 		FILE *f = fopen(MemCard, "rb");
 		if(f == NULL)
@@ -573,20 +720,22 @@
 			}
 		}
 		else
-			fclose(f);
+			fclose(f);	
 	}
 	void *iplbuf = NULL;
 	bool useipl = false;
 	bool useipltri = false;
-	if(IsTRIGame(ncfg->GamePath) == false && (ncfg->Config & NIN_CFG_MEMCARDEMU))
+
+	if(IsTRIGame == 0)
 	{
 		char iplchar[32];
+		memset(iplchar,0,32);
 		if((ncfg->GameID & 0xFF) == 'E')
-			sprintf(iplchar, "%s:/iplusa.bin", GetRootDevice());
+			snprintf(iplchar, sizeof(iplchar), "%s:/iplusa.bin", GetRootDevice());
 		else if((ncfg->GameID & 0xFF) == 'J')
-			sprintf(iplchar, "%s:/ipljap.bin", GetRootDevice());
-		else
-			sprintf(iplchar, "%s:/iplpal.bin", GetRootDevice());
+			snprintf(iplchar, sizeof(iplchar), "%s:/ipljap.bin", GetRootDevice());
+		else if(!IsWiiU())
+			snprintf(iplchar, sizeof(iplchar), "%s:/iplpal.bin", GetRootDevice());
 		FILE *f = fopen(iplchar, "rb");
 		if(f != NULL)
 		{
@@ -602,10 +751,10 @@
 			fclose(f);
 		}
 	}
-	else if(IsTRIGame(ncfg->GamePath) == true)
+	else
 	{
 		char iplchar[32];
-		sprintf(iplchar, "%s:/segaboot.bin", GetRootDevice());
+		snprintf(iplchar, sizeof(iplchar), "%s:/segaboot.bin", GetRootDevice());
 		FILE *f = fopen(iplchar, "rb");
 		if(f != NULL)
 		{
@@ -622,6 +771,12 @@
 			fclose(f);
 		}
 	}
+	if((ncfg->Config & NIN_CFG_AUTO_BOOT) == 0)
+	{	
+	CheckTheme();
+	FadeIt();
+	sleep(1);
+	}
 //sync changes
 	CloseDevices();
 
@@ -632,24 +787,34 @@
 
 	WUPC_Shutdown();
 	WPAD_Shutdown();
-
-//make sure the cfg gets to the kernel
+	
+//before flushing do game specific patches
+	if(ncfg->Config & NIN_CFG_FORCE_PROG &&
+			ncfg->GameID == 0x47584745)
+	{	//Mega Man X Collection does progressive ingame so
+		//forcing it would mess with the interal game setup
+		gprintf("Disabling Force Progressive for this game\r\n");
+		ncfg->Config &= ~NIN_CFG_FORCE_PROG;
+	}
+	
+	//make sure the cfg gets to the kernel
 	DCStoreRange((void*)ncfg, sizeof(NIN_CFG));
-
 	*(vu32*)0xD3003420 = 0x0DEA;
+    if (which_bg == BG_NONE)
+    {
 	while(1)
 	{
 		DCInvalidateRange( STATUS, 0x20 );
 		if( STATUS_LOADING == 0xdeadbeef )
 			break;
-
+		
 		PrintInfo();
-
+		
 		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*6, "Loading patched kernel... %d", STATUS_LOADING);
 		if(STATUS_LOADING == 0)
 		{
 			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*7, "ES_Init...");
-			// Cleans the -1 when it's past it to avoid confusion if another error happens. e.g. before it showed "81" instead of "8" if the controller was unplugged.
+		// Cleans the -1 when it's past it to avoid confusion if another error happens. e.g. before it showed "81" instead of "8" if the controller was unplugged.
 			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 163, MENU_POS_Y + 20*6, " ");
 		}
 		if((STATUS_LOADING > 0 || abs(STATUS_LOADING) > 1) && STATUS_LOADING < 20)
@@ -667,7 +832,7 @@
 		if(STATUS_LOADING == -3)
 			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*9, "Mounting USB/SD device... Error! %d  Shutting down", STATUS_ERROR);
 		if(STATUS_LOADING == 5) {
-/* 			if (timeout == 0)
+/*			if (timeout == 0)
 				timeout = ticks_to_secs(gettime()) + 20; // Set timer for 20 seconds
 			else if (timeout <= ticks_to_secs(gettime())) {
 				STATUS_ERROR = -7;
@@ -676,7 +841,7 @@
 				//memset( (void*)0x92f00000, 0, 0x100000 );
 				//DCFlushRange( (void*)0x92f00000, 0x100000 );
 				//ExitToLoader(1);
-			}*/
+			}*/		
 			PrintFormat(DEFAULT_SIZE, (STATUS_ERROR == -7) ? MAROON:BLACK, MENU_POS_X, MENU_POS_Y + 20*10, (STATUS_ERROR == -7) ? "Checking FS... Timeout!" : "Checking FS...");
 		}
 		if(abs(STATUS_LOADING) > 5 && abs(STATUS_LOADING) < 20)
@@ -699,7 +864,8 @@
 		/*if(STATUS_LOADING == 8)
 		{
 			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*14, "Init HID devices... ");
-			if ( STATUS_ERROR == 1)
+			hid_count++;
+			if ( (STATUS_ERROR) == 1 && (hid_count > 15))
 			{
 				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*15, "          Make sure the Controller is plugged in");
 			}
@@ -728,28 +894,28 @@
 			{
 				case -1:
 					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "No Controller plugged in! %25s", " ");
-					break;
+					break;	
 				case -2:
 					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Missing %s:/controller.ini %20s", GetRootDevice(), " ");
-					break;
+					break;	
 				case -3:
 					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Controller does not match %s:/controller.ini %6s", GetRootDevice(), " ");
-					break;
+					break;	
 				case -4:
 					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Invalid Polltype in %s:/controller.ini %12s", GetRootDevice(), " ");
-					break;
+					break;	
 				case -5:
 					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Invalid DPAD value in %s:/controller.ini %9s", GetRootDevice(), " ");
-					break;
+					break;	
 				case -6:
 					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "PS3 controller init error %25s", " ");
-					break;
+					break;	
 				case -7:
 					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Gamecube adapter for Wii u init error %13s", " ");
-					break;
+					break;	
 				default:
 					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Unknown error %d %35s", STATUS_ERROR, " ");
-					break;
+					break;	
 			}
 		}*/
 		if(STATUS_LOADING == 9)
@@ -760,152 +926,613 @@
 			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*15, "Init CARD...");
 		if(abs(STATUS_LOADING) > 10 && abs(STATUS_LOADING) < 20)
 			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*15, "Init CARD... Done!");
-		if(STATUS_LOADING == -10)
+		GRRLIB_Screen2Texture(0, 0, screen_buffer, GX_FALSE); // Copy all status messages
+		GRRLIB_Render();
+		ClearScreen();
+ 	while((STATUS_LOADING < -1) && (STATUS_LOADING > -20)) //displaying a fatal error
+	;} //do nothing wait for shutdown	
+	DrawBuffer(); // Draw all status messages
+	PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*16, "Nintendont kernel looping, loading game...");
+	GRRLIB_Render();
+	DrawBuffer(); // Draw all status messages
+}
+
+ //custom purple progress bar for light background bar
+	else if (which_bg == BG_LIGHT)
+	{ while(1)
+    {
+    	DCInvalidateRange( STATUS, 0x20 );
+		if( STATUS_LOADING == 0xdeadbeef )
+		break;
+		
+        PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 50*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING == 0)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 90*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING > 0 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 110*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING == 2)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 130*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING > 2 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 150*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+		if(STATUS_LOADING == -2)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*8, "Init USB/SD device... Error! %d  Shutting down", STATUS_ERROR);
+        if(STATUS_LOADING == 3)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 170*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING > 3 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 190*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+         if(STATUS_LOADING == -3)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*9, "Mounting USB/SD device... Error! %d  Shutting down", STATUS_ERROR);
+        if(STATUS_LOADING == 4)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 210*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING > 4 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 230*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+		if(STATUS_LOADING == 5) 
+			{ PrintFormat(DEFAULT_SIZE, (STATUS_ERROR == -7) ? MAROON:0x45587C00, MENU_POS_X + 230*1, MENU_POS_Y + 20*19, (STATUS_ERROR == -7) ? "Checking FS... Timeout!" : "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");}
+        if(STATUS_LOADING > 5 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 270*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+		if(STATUS_LOADING == -5)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*10, "Checking FS... Error! %d Shutting down", STATUS_ERROR);
+        if(STATUS_LOADING == 6)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 290*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING > 6 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 310*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+		if(STATUS_LOADING == -6)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*12, "ES_LoadModules... Error! %d Shutting down", STATUS_ERROR);
+        if(STATUS_LOADING == 7)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 330*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING > 7 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 350*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING == 8)
+        {
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 370*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+			hid_count++;
+			if ( (STATUS_ERROR) == 1 && (hid_count > 15))
+			{
+				PrintFormat(DEFAULT_SIZE, 0xFFD70000, MENU_POS_X, MENU_POS_Y + 17*24, "          Make sure the Controller is plugged in");
+			}			else
+				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*15, "%50s", " ");	
+		}
+        if(STATUS_LOADING > 8 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 390*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+		if(STATUS_LOADING == -8)
 		{
-			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Init CARD... Failed! Shutting down");
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*14, "Init HID devices... Failed! Shutting down");
 			switch (STATUS_ERROR)
 			{
 				case -1:
-					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*16, "Missing %s:/sneek/kenobiwii.bin", GetRootDevice());
-					break;
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "No Controller plugged in! %25s", " ");
+					break;	
 				case -2:
-					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*16, "Missing Cheat file", GetRootDevice());
-					break;
-				/*case -3:
-					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*16, "Cheat file too large", GetRootDevice());
-					break;
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Missing %s:/controller.ini %20s", GetRootDevice(), " ");
+					break;	
+				case -3:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Controller does not match %s:/controller.ini %6s", GetRootDevice(), " ");
+					break;	
 				case -4:
-					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*16, "Cheat path is empty", GetRootDevice());
-					break;*/
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Invalid Polltype in %s:/controller.ini %12s", GetRootDevice(), " ");
+					break;	
+				case -5:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Invalid DPAD value in %s:/controller.ini %9s", GetRootDevice(), " ");
+					break;	
+				case -6:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "PS3 controller init error %25s", " ");
+					break;	
+				case -7:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Gamecube adapter for Wii u init error %13s", " ");
+					break;	
 				default:
-					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*16, "Unknown error %d %35s", STATUS_ERROR, " ");
-					break;
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Unknown error %d %35s", STATUS_ERROR, " ");
+					break;	
 			}
 		}
+        if(STATUS_LOADING == 9)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 410*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING > 9 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 430*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING == 10)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 450*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING > 10 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 470*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        GRRLIB_Screen2Texture(0, 0, screen_buffer, GX_FALSE); // Copy all status messages
+        GRRLIB_Render();
+        ClearScreen();
+        PrintInfo();
+    }
+ 
+    //gprintf("Nintendont at your service!\r\n");
+ 
+    GRRLIB_DrawImg(0, 0, screen_buffer, 0, 1, 1, 0xFFFFFFFF); // Draw all status messages
+            PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 490*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+    GRRLIB_Render();
+}
+
+ //silver progress bar for dark background bar
+	else if (which_bg == BG_DARK)
+	{    while(1)
+    {
+    	DCInvalidateRange( STATUS, 0x20 );
+		if( STATUS_LOADING == 0xdeadbeef )
+		break;
+		
+        PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 50*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING == 0)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 90*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING > 0 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 110*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING == 2)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 130*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING > 2 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 150*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+		if(STATUS_LOADING == -2)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*8, "Init USB/SD device... Error! %d  Shutting down", STATUS_ERROR);
+        if(STATUS_LOADING == 3)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 170*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING > 3 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 190*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+         if(STATUS_LOADING == -3)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*9, "Mounting USB/SD device... Error! %d  Shutting down", STATUS_ERROR);
+        if(STATUS_LOADING == 4)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 210*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING > 4 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 230*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+ 		if(STATUS_LOADING == 5) 
+			{ PrintFormat(DEFAULT_SIZE, (STATUS_ERROR == -7) ? MAROON:0xC0C0C000, MENU_POS_X + 230*1, MENU_POS_Y + 20*19, (STATUS_ERROR == -7) ? "Checking FS... Timeout!" : "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");}
+        if(STATUS_LOADING > 5 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 270*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+		if(STATUS_LOADING == -5)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*10, "Checking FS... Error! %d Shutting down", STATUS_ERROR);
+        if(STATUS_LOADING == 6)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 290*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING > 6 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 310*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+		if(STATUS_LOADING == -6)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*12, "ES_LoadModules... Error! %d Shutting down", STATUS_ERROR);
+        if(STATUS_LOADING == 7)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 330*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING > 7 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 350*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING == 8)
+        {
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 370*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+			hid_count++;
+			if ( (STATUS_ERROR) == 1 && (hid_count > 15))
+			{
+				PrintFormat(DEFAULT_SIZE, 0xFFD70000, MENU_POS_X, MENU_POS_Y + 17*24, "          Make sure the Controller is plugged in");
+			}			else
+				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*15, "%50s", " ");		
+		}
+        if(STATUS_LOADING > 8 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 390*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+		if(STATUS_LOADING == -8)
+		{
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*14, "Init HID devices... Failed! Shutting down");
+			switch (STATUS_ERROR)
+			{
+				case -1:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "No Controller plugged in! %25s", " ");
+					break;	
+				case -2:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Missing %s:/controller.ini %20s", GetRootDevice(), " ");
+					break;	
+				case -3:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Controller does not match %s:/controller.ini %6s", GetRootDevice(), " ");
+					break;	
+				case -4:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Invalid Polltype in %s:/controller.ini %12s", GetRootDevice(), " ");
+					break;	
+				case -5:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Invalid DPAD value in %s:/controller.ini %9s", GetRootDevice(), " ");
+					break;	
+				case -6:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "PS3 controller init error %25s", " ");
+					break;	
+				case -7:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Gamecube adapter for Wii u init error %13s", " ");
+					break;	
+				default:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Unknown error %d %35s", STATUS_ERROR, " ");
+					break;	
+			}
+		}
+        if(STATUS_LOADING == 9)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 410*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING > 9 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 430*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING == 10)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 450*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        if(STATUS_LOADING > 10 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 470*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+        GRRLIB_Screen2Texture(0, 0, screen_buffer, GX_FALSE); // Copy all status messages
+        GRRLIB_Render();
+        ClearScreen();
+        PrintInfo();
+    }
+ 
+    //gprintf("Nintendont at your service!\r\n");
+ 
+    GRRLIB_DrawImg(0, 0, screen_buffer, 0, 1, 1, 0xFFFFFFFF); // Draw all status messages
+            PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 490*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88");
+    GRRLIB_Render();
+}	
+	
+ //white loading bars
+	else if (which_bg == BG_BARS)
+	{     while(1)
+    {
+    	DCInvalidateRange( STATUS, 0x20 );
+		if( STATUS_LOADING == 0xdeadbeef )
+		break;
+		
+        PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+        if(STATUS_LOADING == 0)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 90*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+        if(STATUS_LOADING > 0 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 110*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+        if(STATUS_LOADING == 2)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 130*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+        if(STATUS_LOADING > 2 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 150*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+		if(STATUS_LOADING == -2)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*8, "Init USB/SD device... Error! %d  Shutting down", STATUS_ERROR);
+        if(STATUS_LOADING == 3)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 170*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+        if(STATUS_LOADING > 3 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 190*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+         if(STATUS_LOADING == -3)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*9, "Mounting USB/SD device... Error! %d  Shutting down", STATUS_ERROR);
+        if(STATUS_LOADING == 4)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 210*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+        if(STATUS_LOADING > 4 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 230*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+ 		if(STATUS_LOADING == 5) 
+			{ PrintFormat(DEFAULT_SIZE, (STATUS_ERROR == -7) ? MAROON:WHITE, MENU_POS_X + 230*1, MENU_POS_Y + 20*19, (STATUS_ERROR == -7) ? "Checking FS... Timeout!" : "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");}
+        if(STATUS_LOADING > 5 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 270*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+		if(STATUS_LOADING == -5)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*10, "Checking FS... Error! %d Shutting down", STATUS_ERROR);
+        if(STATUS_LOADING == 6)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 290*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+        if(STATUS_LOADING > 6 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 310*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+		if(STATUS_LOADING == -6)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*12, "ES_LoadModules... Error! %d Shutting down", STATUS_ERROR);
+        if(STATUS_LOADING == 7)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 330*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+        if(STATUS_LOADING > 7 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 350*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+        if(STATUS_LOADING == 8)
+        {
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 370*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+			hid_count++;
+			if ( (STATUS_ERROR) == 1 && (hid_count > 15))
+			{
+				PrintFormat(DEFAULT_SIZE, 0xFFD70000, MENU_POS_X, MENU_POS_Y + 17*24, "          Make sure the Controller is plugged in");
+			}			else
+				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*15, "%50s", " ");	
+		}
+        if(STATUS_LOADING > 8 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 390*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+		if(STATUS_LOADING == -8)
+		{
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*14, "Init HID devices... Failed! Shutting down");
+			switch (STATUS_ERROR)
+			{
+				case -1:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "No Controller plugged in! %25s", " ");
+					break;	
+				case -2:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Missing %s:/controller.ini %20s", GetRootDevice(), " ");
+					break;	
+				case -3:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Controller does not match %s:/controller.ini %6s", GetRootDevice(), " ");
+					break;	
+				case -4:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Invalid Polltype in %s:/controller.ini %12s", GetRootDevice(), " ");
+					break;	
+				case -5:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Invalid DPAD value in %s:/controller.ini %9s", GetRootDevice(), " ");
+					break;	
+				case -6:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "PS3 controller init error %25s", " ");
+					break;	
+				case -7:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Gamecube adapter for Wii u init error %13s", " ");
+					break;	
+				default:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Unknown error %d %35s", STATUS_ERROR, " ");
+					break;	
+			}
+		}
+        if(STATUS_LOADING == 9)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 410*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+        if(STATUS_LOADING > 9 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+        if(STATUS_LOADING == 10)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 450*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+        if(STATUS_LOADING > 10 && STATUS_LOADING < 20)
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 470*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+        GRRLIB_Screen2Texture(0, 0, screen_buffer, GX_FALSE); // Copy all status messages
+        GRRLIB_Render();
+        ClearScreen();
+        PrintInfo();
+    }
+ 
+    //gprintf("Nintendont at your service!\r\n");
+ 
+    GRRLIB_DrawImg(0, 0, screen_buffer, 0, 1, 1, 0xFFFFFFFF); // Draw all status messages
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 490*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83");
+    GRRLIB_Render();
+}	
+	
+ //white no loading bar
+	else if ((which_bg == BG_NOBAR) || (which_bg == BG_BLACK))
+	{     while(1)
+    {
+    	DCInvalidateRange( STATUS, 0x20 );
+		if( STATUS_LOADING == 0xdeadbeef )
+		break;
+		
+		if(STATUS_LOADING == -2)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*8, "Init USB/SD device... Error! %d  Shutting down", STATUS_ERROR);
+         if(STATUS_LOADING == -3)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*9, "Mounting USB/SD device... Error! %d  Shutting down", STATUS_ERROR);
+ 		if(STATUS_LOADING == 5) 
+			{ PrintFormat(DEFAULT_SIZE, (STATUS_ERROR == -7) ? MAROON:WHITE, MENU_POS_X + 230*1, MENU_POS_Y + 20*19, (STATUS_ERROR == -7) ? "Checking FS... Timeout!" : " ");}
+		if(STATUS_LOADING == -5)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*10, "Checking FS... Error! %d Shutting down", STATUS_ERROR);
+		if(STATUS_LOADING == -6)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*12, "ES_LoadModules... Error! %d Shutting down", STATUS_ERROR);
+        if(STATUS_LOADING == 8)
+        {
+            PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 370*1, MENU_POS_Y + 20*19, " ");
+			hid_count++;
+			if ( (STATUS_ERROR) == 1 && (hid_count > 15))
+			{
+				PrintFormat(DEFAULT_SIZE, 0xFFD70000, MENU_POS_X, MENU_POS_Y + 17*24, "          Make sure the Controller is plugged in");
+			}			else
+				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*15, "%50s", " ");	
+		}
+		if(STATUS_LOADING == -8)
+		{
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*14, "Init HID devices... Failed! Shutting down");
+			switch (STATUS_ERROR)
+			{
+				case -1:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "No Controller plugged in! %25s", " ");
+					break;	
+				case -2:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Missing %s:/controller.ini %20s", GetRootDevice(), " ");
+					break;	
+				case -3:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Controller does not match %s:/controller.ini %6s", GetRootDevice(), " ");
+					break;	
+				case -4:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Invalid Polltype in %s:/controller.ini %12s", GetRootDevice(), " ");
+					break;	
+				case -5:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Invalid DPAD value in %s:/controller.ini %9s", GetRootDevice(), " ");
+					break;	
+				case -6:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "PS3 controller init error %25s", " ");
+					break;	
+				case -7:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Gamecube adapter for Wii u init error %13s", " ");
+					break;	
+				default:
+					PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*15, "Unknown error %d %35s", STATUS_ERROR, " ");
+					break;	
+			}
+		}
+        GRRLIB_Screen2Texture(0, 0, screen_buffer, GX_FALSE); // Copy all status messages
+        GRRLIB_Render();
+        ClearScreen();
+        PrintInfo();
+    }
+ 
+    //gprintf("Nintendont at your service!\r\n");
+ 
+    GRRLIB_DrawImg(0, 0, screen_buffer, 0, 1, 1, 0xFFFFFFFF); // Draw all status messages
+    GRRLIB_Render();
+}	
+	
+	//Dark Background & White text
+    else if (which_bg == BG_LEGACY)
+    {
+	while(1)
+	{
+		DCInvalidateRange( STATUS, 0x20 );
+		if( STATUS_LOADING == 0xdeadbeef )
+			break;
+		
+		PrintInfo();
+		
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*6, "Loading patched kernel... %d", STATUS_LOADING);
+		if(STATUS_LOADING == 0)
+		{
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*7, "ES_Init...");
+		// Cleans the -1 when it's past it to avoid confusion if another error happens. e.g. before it showed "81" instead of "8" if the controller was unplugged.
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 163, MENU_POS_Y + 20*6, " ");
+		}
+		if((STATUS_LOADING > 0 || abs(STATUS_LOADING) > 1) && STATUS_LOADING < 20)
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*7, "ES_Init... Done!");
+		if(STATUS_LOADING == 2)
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*8, "Initing storage devices...");
+		if(abs(STATUS_LOADING) > 2 && abs(STATUS_LOADING) < 20)
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*8, "Initing storage devices... Done!");
+		if(STATUS_LOADING == -2)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*8, "Initing storage devices... Error! %d  Shutting down", STATUS_ERROR);
+		if(STATUS_LOADING == 3)
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*9, "Mounting USB/SD device...");
+		if(abs(STATUS_LOADING) > 3 && abs(STATUS_LOADING) < 20)
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*9, "Mounting USB/SD device... Done!");
+		if(STATUS_LOADING == -3)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*9, "Mounting USB/SD device... Error! %d  Shutting down", STATUS_ERROR);
+		if(STATUS_LOADING == 5) {
+/*			if (timeout == 0)
+				timeout = ticks_to_secs(gettime()) + 20; // Set timer for 20 seconds
+			else if (timeout <= ticks_to_secs(gettime())) {
+				STATUS_ERROR = -7;
+				DCFlushRange(STATUS, 0x20);
+				usleep(100);
+				//memset( (void*)0x92f00000, 0, 0x100000 );
+				//DCFlushRange( (void*)0x92f00000, 0x100000 );
+				//ExitToLoader(1);
+			}
+*/		
+			PrintFormat(DEFAULT_SIZE, (STATUS_ERROR == -7) ? MAROON:WHITE, MENU_POS_X, MENU_POS_Y + 20*10, (STATUS_ERROR == -7) ? "Checking FS... Timeout!" : "Checking FS...");
+		}
+		if(abs(STATUS_LOADING) > 5 && abs(STATUS_LOADING) < 20)
+		{
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*10, "Checking FS... Done!");
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*11, "Drive size: %.02f%s Sector size: %d", STATUS_DRIVE, STATUS_GB_MB ? "GB" : "MB", STATUS_SECTOR);
+		}
+		if(STATUS_LOADING == -5)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*10, "Checking FS... Error! %d Shutting down", STATUS_ERROR);
+		if(STATUS_LOADING == 6)
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*12, "ES_LoadModules...");
+		if(abs(STATUS_LOADING) > 6 && abs(STATUS_LOADING) < 20)
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*12, "ES_LoadModules... Done!");
+		if(STATUS_LOADING == -6)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*12, "ES_LoadModules... Error! %d Shutting down", STATUS_ERROR);
+		if(STATUS_LOADING == 7)
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*13, "Loading config...");
+		if(abs(STATUS_LOADING) > 7 && abs(STATUS_LOADING) < 20)
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*13, "Loading config... Done!");
+		if(STATUS_LOADING == 9)
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*14, "Init DI... %40s", " ");
+		if(abs(STATUS_LOADING) > 9 && abs(STATUS_LOADING) < 20)
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*14, "Init DI... Done! %35s", " ");
+		if(STATUS_LOADING == 10)
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*15, "Init CARD...");
+		if(abs(STATUS_LOADING) > 10 && abs(STATUS_LOADING) < 20)
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*15, "Init CARD... Done!");
 		GRRLIB_Screen2Texture(0, 0, screen_buffer, GX_FALSE); // Copy all status messages
 		GRRLIB_Render();
 		ClearScreen();
-		while((STATUS_LOADING < -1) && (STATUS_LOADING > -20)) //displaying a fatal error
-				; //do nothing wait for shutdown
+		while ((STATUS_LOADING < -1) && (STATUS_LOADING > -20))	//displaying a fatal error
+			{ }	//do nothing wait for shutdown
 	}
+
+	gprintf("Nintendont at your service!\r\n");
+
 	DrawBuffer(); // Draw all status messages
-	PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*17, "Nintendont kernel looping, loading game...");
+	PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*16, "Nintendont kernel looping, loading game...");
 	GRRLIB_Render();
 	DrawBuffer(); // Draw all status messages
-//	memcpy( (void*)0x80000000, (void*)0x90140000, 0x1200000 );
+}	
+
+	else{}
+
 	GRRLIB_FreeTexture(background);
 	GRRLIB_FreeTexture(screen_buffer);
 	GRRLIB_FreeTTF(myFont);
 	GRRLIB_Exit();
-
+	
 	gprintf("GameRegion:");
 
-	if( ncfg->VideoMode & NIN_VID_FORCE )
+	u32 vidForce = (ncfg->VideoMode & NIN_VID_FORCE);
+	u32 vidForceMode = (ncfg->VideoMode & NIN_VID_FORCE_MASK);
+
+	progressive = (ncfg->Config & NIN_CFG_FORCE_PROG)
+		&& !useipl && !useipltri;
+
+	switch (ncfg->GameID & 0x000000FF)
 	{
-		gprintf("Force:%02X\r\n", ncfg->VideoMode & NIN_VID_FORCE_MASK );
-
-		switch( ncfg->VideoMode & NIN_VID_FORCE_MASK )
-		{
-			case NIN_VID_FORCE_NTSC:
+		// EUR
+		case 'D':
+		case 'F':
+		case 'H':
+		case 'I':
+		case 'M':
+		case 'P':
+		case 'S':
+		case 'U':
+		case 'X':
+		case 'Y':
+		case 'Z':
+			if(!progressive && vidForce && 
+				vidForceMode == NIN_VID_FORCE_PAL50)
 			{
-				*(vu32*)0x800000CC = 0;
-				Region = 0;
-			} break;
-			case NIN_VID_FORCE_MPAL:
+				*(vu32*)0x800000CC = 1;
+			}
+			else
 			{
+				*(vu32*)0x800000CC = 5;
+			}
+			vmode = &TVPal528IntDf;
+			break;
+		//US
+		case 'E':
+			if((vidForce && vidForceMode == NIN_VID_FORCE_MPAL)
+				|| (!vidForce && CONF_GetVideo() == CONF_VIDEO_MPAL))
+			{
 				*(vu32*)0x800000CC = 3;
-				Region = 2;
-			} break;
-			case NIN_VID_FORCE_PAL50:
+				vmode = &TVMpal480IntDf;
+			}
+			else
 			{
-				*(vu32*)0x800000CC = 1;
-				Region = 2;
-			} break;
-			case NIN_VID_FORCE_PAL60:
-			{
-				*(vu32*)0x800000CC = 5;
-				Region = 2;
-			} break;
-		}
+				*(vu32*)0x800000CC = 0;
+				vmode = &TVNtsc480IntDf;
+			}
+			break;
+		//JP
+		case 'J':
+		default:
+			*(vu32*)0x800000CC = 0;
+			vmode = &TVNtsc480IntDf;
+			break;
 	}
-	else
+
+	if(progressive)
+		vmode = &TVNtsc480Prog;
+	else if(vidForce)
 	{
-		switch (ncfg->GameID & 0x000000FF)
+		switch(vidForceMode)
 		{
-			// EUR
-			case 'D':
-			case 'F':
-			case 'H':
-			case 'I':
-			case 'M':
-			case 'P':
-			case 'S':
-			case 'U':
-			case 'X':
-			case 'Y':
-			case 'Z':
-				Region = 2;
+		case NIN_VID_FORCE_PAL50:
+			vmode = &TVPal528IntDf;
 				break;
-			// JP and US
-			case 'J':
-			case 'E':
+			case NIN_VID_FORCE_PAL60:
+				vmode = &TVEurgb60Hz480IntDf;
+				break;
+			case NIN_VID_FORCE_MPAL:
+				vmode = &TVMpal480IntDf;
+				break;
+			case NIN_VID_FORCE_NTSC:
 			default:
-				Region = 0;
+				vmode = &TVNtsc480IntDf;
 				break;
 		}
 	}
 	
-	gprintf("Region:%u\r\n", Region );
-	progressive = ncfg->Config & NIN_CFG_FORCE_PROG;
-	switch(Region)
+	if((ncfg->Config & NIN_CFG_MEMCARDEMU) == 0) //setup real sram video
 	{
-		default:
-		case 0:
-		case 1:
+		syssram *sram;
+		sram = __SYS_LockSram();
+		sram->display_offsetH = 0;	// Clear Offset
+		sram->ntd		&= ~0x40;	// Clear PAL60
+		sram->flags		&= ~0x80;	// Clear Progmode
+		sram->flags		&= ~3;		// Clear Videomode
+		switch(ncfg->GameID & 0xFF)
 		{
-			gprintf("NTSC\r\n");
-
-			*(vu32*)0x800000CC = 0;
-
-			if(progressive)
-				vmode = &TVNtsc480Prog;
-			else
-				vmode = &TVNtsc480IntDf;
-			
-		} break;
-		case 2:
-		{
-			if( *(vu32*)0x800000CC == 5 )
-			{
-				gprintf("PAL60\r\n");
-
-				if(progressive)
-					vmode = &TVNtsc480Prog;
-				else
-					vmode = &TVEurgb60Hz480IntDf;
-
-			} else if( *(vu32*)0x800000CC == 3 ) {
-				gprintf("MPAL\r\n");
-
-				if(progressive)
-					vmode = &TVNtsc480Prog;
-				else
-					vmode = &TVMpal480IntDf;
-			} else {
-				
-				gprintf("PAL50\r\n");
-
-				if(progressive)
-					vmode = &TVEurgb60Hz480Prog;
-				else
-					vmode = &TVPal528IntDf;
-			}
-
-			*(vu32*)0x800000CC = 1;
-
-		} break;
+			case 'E':
+			case 'J':
+				//BMX XXX doesnt even boot on a real gc with component cables
+				if( (ncfg->GameID >> 8) != 0x474233 &&
+					(ncfg->VideoMode & NIN_VID_PROG) )
+					sram->flags |= 0x80;	// Set Progmode
+				break;
+			default:
+				sram->ntd		|= 0x40;	// Set PAL60
+				break;
+		}
+		if(*(vu32*)0x800000CC == 1 || *(vu32*)0x800000CC == 5)
+			sram->flags	|= 1; //PAL Video Mode
+		__SYS_UnlockSram(1); // 1 -> write changes
+		while(!__SYS_SyncSram());
 	}
-	VIDEO_Configure( vmode );
+	
+	ReconfigVideo(vmode);
 	VIDEO_SetBlack(FALSE);
 	VIDEO_Flush();
 	VIDEO_WaitVSync();
@@ -913,7 +1540,7 @@
 		VIDEO_WaitVSync();
 	else while(VIDEO_GetNextField())
 		VIDEO_WaitVSync();
-
+	
 	*(u16*)(0xCC00501A) = 156;	// DSP refresh rate
 	/* from libogc, get all gc pads to work */
 	u32 buf[2];
@@ -965,26 +1592,30 @@
 	//0x9300300C is already used for multi-iso
 	memset((void*)0x93003010, 0, 0x10); //disable rumble on bootup
 	DCFlushRange((void*)0x93003000, 0x20);
-
-	//lets prevent weird events
-	__STM_Close();
-
-	//THIS thing right here, it interrupts some games and breaks them
-	//To fix that, call ExecSuspendScheduler so WC24 just sleeps
-	u32 out = 0;
-	fd = IOS_Open("/dev/net/kd/request", 0);
-	IOS_Ioctl(fd, IOCTL_ExecSuspendScheduler, NULL, 0, &out, 4);
-	IOS_Close(fd);
-
+	
+ 	//lets prevent weird events
+ 	__STM_Close();
+ 	
+ 	//THIS thing right here, it interrupts some games and breaks them
+ 	//To fix that, call ExecSuspendScheduler so WC24 just sleeps
+ 	u32 out = 0;
+ 	fd = IOS_Open("/dev/net/kd/request", 0);
+ 	IOS_Ioctl(fd, IOCTL_ExecSuspendScheduler, NULL, 0, &out, 4);
+ 	IOS_Close(fd);
+ 	
 	write16(0xD8B420A, 0); //disable MEMPROT again after reload
 	//u32 level = IRQ_Disable();
 	__exception_closeall();
 	__lwp_thread_closeall();
 
-	DVDStartCache(); //waits for kernel start
+ 	DVDStartCache(); //waits for kernel start
+	DCInvalidateRange((void*)0x90000000, 0x1000000);
+	memset((void*)(void*)0x90000000, 0, 0x1000000); //clear ARAM
+	DCFlushRange((void*)0x90000000, 0x1000000);
+
 	gprintf("Game Start\n");
-
-	if(useipl)
+	
+	if((useipl) && (memcmp(&(ncfg->GameID), "RELS", 4) != 0) && (memcmp(&(ncfg->GameID), "D4", 2) != 0)) //&& (ncfg->Config & NIN_CFG_MEMCARDEMU)
 	{
 		load_ipl(iplbuf);
 		*(vu32*)0xD3003420 = 0x5DEA;
@@ -1017,7 +1648,6 @@
 		"blr\n"
 	);
 	//IRQ_Restore(level);
-
 	return 0;
 }
 
Index: loader/source/MemCard.c
===================================================================
--- loader/source/MemCard.c	(revision 334)
+++ loader/source/MemCard.c	(working copy)
@@ -55,13 +55,14 @@
 	//Use current language for SRAM language
 	TmpU32 = ncfg->Language;
 	memcpy(MemcardBase + 0x18, &TmpU32, 4);
-	//Not sure what this area is about
-	memset(MemcardBase + 0x1C, 0, 6);
+	//Memory Card File Mode
+	TmpU32 = ((ncfg->GameID & 0xFF) == 'J' ? 2 : 0);
+	memcpy(MemcardBase + 0x1C, &TmpU32, 4);
 	//Memory Card size in MBits total
-	u16 TmpShort = MEM_CARD_SIZE(ncfg->MemCardBlocks) >> 17;
-	memcpy(MemcardBase + 0x22, &TmpShort, 2);
+	TmpU32 = MEM_CARD_SIZE(ncfg->MemCardBlocks) >> 17;
+	memcpy(MemcardBase + 0x20, &TmpU32, 4);
 	//Memory Card File Mode
-	TmpShort = (ncfg->GameID & 0xFF) == 'J';
+	u16 TmpShort = (ncfg->GameID & 0xFF) == 'J';
 	memcpy(MemcardBase + 0x24, &TmpShort, 2);
 	//Generate Header Checksum
 	doChecksum((u16*)(MemcardBase),0x1FC,(u16*)(MemcardBase+0x1FC),(u16*)(MemcardBase+0x1FE));
Index: loader/source/menu.c
===================================================================
--- loader/source/menu.c	(revision 334)
+++ loader/source/menu.c	(working copy)
@@ -18,7 +18,7 @@
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 
 */
-#include "menu.h"
+#include <gccore.h>
 #include "font.h"
 #include "exi.h"
 #include "global.h"
@@ -40,7 +40,24 @@
 #include <fat.h>
 #include <di/di.h>
 #include "../../common/include/CommonConfigStrings.h"
+#include "menu.h"
 
+// Device state.
+typedef enum {
+	// Device is open and has a "games" directory.
+	DEV_OK = 0,
+	// Device could not be opened.
+	DEV_NO_OPEN = 1,
+	// Device was opened but has no "games" directory.
+	DEV_NO_GAMES = 2,
+} DevState;
+static u8 devState = DEV_OK;
+
+/**
+ * Print information about the selected device.
+ */
+static void PrintDevInfo(void);
+
 extern NIN_CFG* ncfg;
 
 u32 Shutdown = 0;
@@ -73,50 +90,100 @@
 	const gameinfo *da = (const gameinfo *) a;
 	const gameinfo *db = (const gameinfo *) b;
 
-	return strcasecmp(da->Name, db->Name);
+	int ret = strcasecmp(da->Name, db->Name);
+	if (ret == 0)
+	{
+		// Names are equal. Check disc number.
+		if (da->DiscNumber < db->DiscNumber)
+			ret = -1;
+		else if (da->DiscNumber > db->DiscNumber)
+			ret = 1;
+		else
+			ret = 0;
+	}
+	return ret;
 }
-bool SelectGame( void )
-{
-//Create a list of games
-	char filename[MAXPATHLEN];
-	char gamename[MAXPATHLEN];
 
+/**
+ * Get all games from the games/ directory on the selected storage device.
+ * On Wii, this also adds a pseudo-game for loading GameCube games from disc.
+ *
+ * @param gi           [out] Array of gameinfo structs.
+ * @param sz           [in]  Maximum number of elements in gi.
+ * @param pGameCount   [out] Number of games loaded. (Includes GCN pseudo-game for Wii.)
+ *
+ * @return DevState value:
+ * - DEV_OK: Device opened and has a "games/" directory.
+ * - DEV_NO_OPEN: Could not open the storage device.
+ * - DEV_NO_GAMES: No "games/" directory was found.
+ */
+static DevState LoadGameList(gameinfo *gi, u32 sz, u32 *pGameCount)
+{	
+	// Create a list of games
+	char filename[MAXPATHLEN];	// Current filename.
+	char gamename[65];		// Game title.
+	char buf[0x100];		// Disc header.
+	int gamecount = 0;		// Current game count.
+
 	DIR *pdir;
 	struct dirent *pent;
 	struct stat statbuf;
-
-	sprintf(filename, "%s:/games", GetRootDevice());
-	pdir = opendir(filename);
-	if( !pdir )
-	{
-		ClearScreen();
-		gprintf("No FAT device found, or missing %s dir!\n", filename);
-		PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, 232, "No FAT device found, or missing %s dir!", filename );
-		ExitToLoader(1);
-	}
-
-	u32 gamecount = 0;
-	char buf[0x100];
-	gameinfo gi[MAX_GAMES];
-
-	memset( gi, 0, sizeof(gameinfo) * MAX_GAMES );
+	
 	if( !IsWiiU() )
 	{
-		gi[0].Name = strdup("Boot GC Disc in Drive");
+		// Pseudo game for booting a GameCube disc on Wii.
 		gi[0].ID[0] = 'D',gi[0].ID[1] = 'I',gi[0].ID[2] = 'S';
 		gi[0].ID[3] = 'C',gi[0].ID[4] = '0',gi[0].ID[5] = '1';
+		gi[0].Name = "Boot GC Disc in Drive";
+		gi[0].NameAlloc = 0;
+		gi[0].DiscNumber = 0;		
 		gi[0].Path = strdup("di:di");
 		gamecount++;
 	}
+
+	snprintf(filename, sizeof(filename), "%s:/games", GetRootDevice());
+	pdir = opendir(filename);
+	if( !pdir )
+	{
+		// Could not open the "games" directory.
+
+		// Attempt to open the device root.
+		char root_filename[8];
+		snprintf(root_filename, sizeof(root_filename), "%s:/", GetRootDevice());
+		pdir = opendir(root_filename);
+		if ( !pdir )
+		{
+			// Could not open the device root.
+			if (pGameCount)
+				*pGameCount = 0;
+			return DEV_NO_OPEN;
+		}
+
+		// Device root opened.
+		// This means the device is usable, but it
+		// doesn't have a "games" directory.
+		closedir(pdir);
+		if (pGameCount)
+			*pGameCount = gamecount;
+		return DEV_NO_GAMES;
+	}
+
+	// Process the directory.	
 	while( ( pent = readdir(pdir) ) != NULL )
 	{
+		// Game layout should be: /games/GAMEID/game.iso
+		// Search for subdirectories.	
 		stat( pent->d_name, &statbuf );
 		if( pent->d_type == DT_DIR )
 		{
-			if( pent->d_name[0] == '.' )	//skip current and previous directories
+			// Skip "." and "..".
+			// This will also skip "hidden" directories.
+			if( pent->d_name[0] == '.' )
 				continue;
 
-		//	gprintf( "%s", pent->d_name );
+			// Prepare the filename buffer with the directory name.
+			// game.iso/disc2.iso will be appended later.
+			int fnlen = snprintf(filename, sizeof(filename), "%s:/games/%s/", GetRootDevice(), pent->d_name);
 
 			//Test if game.iso exists and add to list
 
@@ -124,12 +191,15 @@
 			u32 DiscNumber;
 			for (DiscNumber = 0; DiscNumber < 2; DiscNumber++)
 			{
-				sprintf( filename, "%s:/games/%s/%s.iso", GetRootDevice(), pent->d_name, DiscNumber ? "disc2" : "game" );
-
+				if (DiscNumber)
+					memcpy(&filename[fnlen], "disc2.iso", 10);
+				else
+					memcpy(&filename[fnlen], "game.iso", 9);
 				FILE *in = fopen( filename, "rb" );
 				if( in != NULL )
 				{
-				//	gprintf("(%s) ok\n", filename );
+					// Read the disc header
+					//gprintf("(%s) ok\n", filename );
 					fread( buf, 1, 0x100, in );
 					fclose(in);
 
@@ -136,21 +206,38 @@
 					if( IsGCGame((u8*)buf) )	// Must be GC game
 					{
 						memcpy(gi[gamecount].ID, buf, 6); //ID for EXI
-						if(!SearchTitles(gi[gamecount].ID, gamename)) strcpy( gamename, buf + 0x20 );
-						if (DiscNumber)
-							strcat( gamename, " (2)" );
-						gi[gamecount].Name = strdup( gamename );
+						gi[gamecount].DiscNumber = DiscNumber;
+
+						// Check if this title is in titles.txt.
+						const char *dbTitle = SearchTitles(gi[gamecount].ID);
+						if (dbTitle)
+						{
+							// Title found.
+							gi[gamecount].Name = (char*)dbTitle;
+							gi[gamecount].NameAlloc = 0;
+						}
+						else
+						{
+							// Title not found.
+							// Use the title from the disc header.
+							strncpy(gamename, buf + 0x20, sizeof(gamename));
+							gamename[sizeof(gamename)] = 0;
+							gi[gamecount].Name = strdup(gamename);
+							gi[gamecount].NameAlloc = 1;
+						}
+
 						gi[gamecount].Path = strdup( filename );
-
 						gamecount++;
 						found = true;
 					}
 				}
 			}
-			if ( !found ) // Check for FST format
+
+			// If game.iso wasn't found, check for FST format.
+			if ( !found )
 			{
-				sprintf(filename, "%s:/games/%s/sys/boot.bin", GetRootDevice(), pent->d_name);
-
+				memcpy(&filename[fnlen], "sys/boot.bin", 13);
+ 
 				FILE *in = fopen( filename, "rb" );
 				if( in != NULL )
 				{
@@ -160,29 +247,95 @@
 
 					if( IsGCGame((u8*)buf) )	// Must be GC game
 					{
-						sprintf(filename, "%s:/games/%s/", GetRootDevice(), pent->d_name);
+						filename[fnlen] = 0;
+ 
+						memcpy(gi[gamecount].ID, buf, 6); //ID for EXI
+						gi[gamecount].DiscNumber = DiscNumber;
 
-						memcpy(gi[gamecount].ID, buf, 6); //ID for EXI
-						gi[gamecount].Name = strdup( buf + 0x20 );
+						// TODO: Check titles.txt?
+						strncpy(gamename, buf + 0x20, sizeof(gamename));
+						gamename[sizeof(gamename)] = 0;
+						gi[gamecount].Name = strdup(gamename);
+						gi[gamecount].NameAlloc = 1;
+						
 						gi[gamecount].Path = strdup( filename );
-						
-
 						gamecount++;
 					}
 				}
 			}
 		}
-		if (gamecount >= MAX_GAMES)	//if array is full
+
+		if (gamecount >= sz)	//if array is full
 			break;
 	}
-
+	closedir(pdir);
+	// Sort the list alphabetically.
+	// On Wii, the pseudo-entry for GameCube discs is always
+	// kept at the top.	
 	if( IsWiiU() )
 		qsort(gi, gamecount, sizeof(gameinfo), compare_names);
 	else if( gamecount > 1 )
 		qsort(&gi[1], gamecount-1, sizeof(gameinfo), compare_names);
+	// Save the game count.
+	if (pGameCount)
+		*pGameCount = gamecount;
 
+	return DEV_OK;
+}
+
+/**
+ * Select a game from the specified device.
+ * @return Bitfield indicating the user's selection:
+ * - 0 == go back
+ * - 1 == game selected
+ * - 2 == go back and save settings (UNUSED)
+ * - 3 == game selected and save settings
+ */
+static int SelectGame(void)
+{
+	// Create a list of games
+	char filename[MAXPATHLEN];
+
+	// Depending on how many games are on the storage device,
+	// this could take a while.
+	ShowLoadingScreen();
+
+	// Load the game list.
+	u32 gamecount = 0;
+	gameinfo gi[MAX_GAMES];
+
+	devState = LoadGameList(&gi[0], MAX_GAMES, &gamecount);
+	switch (devState)
+	{
+		case DEV_OK:
+			// Game list loaded successfully.
+			break;
+
+		case DEV_NO_GAMES:
+			// No "games" directory was found.
+			// The list will still be shown, since there's a
+			// "Boot GC Disc in Drive" option on Wii.
+			gprintf("WARNING: %s was not found.\n", filename);
+			break;
+
+		case DEV_NO_OPEN:
+		default:
+		{
+			// Could not open the device at all.
+			// The list won't be shown, since a storage device
+			// is required for various functionality, but the
+			// user will be able to go back to the previous menu.
+			const char *s_devType = (UseSD ? "SD" : "USB");
+			gprintf("No %s FAT device found.\n", s_devType);
+			break;
+		}
+	}
+
+	bool selected = false;	// Set to TRUE if the user selected a game.
+
 	u32 redraw = 1;
 	u32 i;
+	u32 settingPart = 0;
 	s32 PosX = 0, prevPosX = 0;
 	s32 ScrollX = 0, prevScrollX = 0;
 	u32 MenuMode = 0;
@@ -207,7 +360,7 @@
 			break;
 		}
 	}
-
+	UpdateScreen();
 	u32 UpHeld = 0, DownHeld = 0;
 	while(1)
 	{
@@ -216,9 +369,15 @@
 
 		if( FPAD_Start(1) )
 		{
-			ClearScreen();
-			PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Returning to loader..." );
-			ExitToLoader(0);
+		/*	ClearScreen();
+					if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Returning to loader..." );	}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, 212, 232, "Returning to loader..." );	}
+			ExitToLoader(0); */
+			// Go back to the Settings menu.
+			selected = false;
+			break;
 		}
 
 		if( FPAD_Cancel(0) )
@@ -235,12 +394,13 @@
 			}
 			else
 			{
-				ListMax = NIN_SETTINGS_LAST;
+				ListMax = (NIN_SETTINGS_LAST - 1);
 
 				prevPosX = PosX;
 				PosX	= 0;
 				prevScrollX = ScrollX;
 				ScrollX = 0;
+				settingPart = 0;
 			}
 
 			redraw = 1;
@@ -250,12 +410,26 @@
 
 		if( MenuMode == 0 )		//game select menu
 		{
+			if(FPAD_X(0)) {				
+				UpdateNintendont();
+				redraw = 1;
+			}
+			if(FPAD_Y(0)) {
+				Credits();
+				redraw = 1;
+			}			
 			if( FPAD_Down(1) )
 			{
 				if(DownHeld == 0 || DownHeld > 10)
 				{
+					if (which_bg == BG_NONE)
+					{
 					PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
-
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+					PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
+					}					
 					if( PosX + 1 >= ListMax )
 					{
 						if( PosX + 1 + ScrollX < gamecount)
@@ -279,8 +453,14 @@
 				DownHeld = 0;
 			if( FPAD_Right(0) )
 			{
-				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
-
+					if (which_bg == BG_NONE)
+					{
+					PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+					PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
+					}	
 				if( PosX == ListMax - 1 )
 				{
 					if( PosX + ListMax + ScrollX < gamecount)
@@ -301,12 +481,18 @@
 				redraw=1;
 				SaveSettings = true;
 			}
-			else if( FPAD_Up(1) )
+			if( FPAD_Up(1) )
 			{
 				if(UpHeld == 0 || UpHeld > 10)
 				{
+					if (which_bg == BG_NONE)
+					{
 					PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
-
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+					PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
+					}	
 					if( PosX <= 0 )
 					{
 						if( ScrollX > 0 )
@@ -330,8 +516,14 @@
 				UpHeld = 0;
 			if( FPAD_Left(0) )
 			{
-				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
-
+					if (which_bg == BG_NONE)
+					{
+					PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+					PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
+					}	
 				if( PosX == 0 )
 				{
 					if( ScrollX - (s32)ListMax >= 0 )
@@ -354,18 +546,103 @@
 
 			if( FPAD_OK(0) )
 			{
+				{
+				GRRLIB_FillScreen (BLACK);
+				// User selected a game.
+				selected = true;
 				break;
+				}
 			}
 
 			if( redraw )
 			{
 				PrintInfo();
-				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "Home: Exit");
-				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*2, "A   : %s", MenuMode ? "Modify" : "Select");
-				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*3, "B   : %s", MenuMode ? "Game List" : "Settings ");
-				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*4, MenuMode ? "X/1 : Update" : "");
-				for( i=0; i < ListMax; ++i )
-					PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*5 + i * 20, "%50.50s [%.6s]%s", gi[i+ScrollX].Name, gi[i+ScrollX].ID, i == PosX ? ARROW_LEFT : " " );
+					if (which_bg == BG_NONE)
+					{
+				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y, "  Home: Back");
+				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : %s", MenuMode ? "Modify" : "Select");
+				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : %s", MenuMode ? "Game List" : "Settings ");
+				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*2, "X / 1 : Updates & Themes");
+				PrintFormat(15, BLACK, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+				PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y, "  Home: Back");
+				PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : %s", MenuMode ? "Modify" : "Select");
+				PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : %s", MenuMode ? "Game List" : "Settings ");
+				PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*2, "X / 1 : Updates & Themes");
+				PrintFormat(15, WHITE, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");
+					}					
+
+				/* for( i=0; i < ListMax; ++i )
+					if (which_bg == BG_NONE)
+					{
+						PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, gamelist_y,
+							    "%46.46s (%d) [%.6s]%s",
+							    cur_gi->Name, cur_gi->DiscNumber+1, cur_gi->ID,
+							    i == PosX ? ARROW_LEFT : " ");		
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+						PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, gamelist_y,
+							    "%46.46s (%d) [%.6s]%s",
+							    cur_gi->Name, cur_gi->DiscNumber+1, cur_gi->ID,
+							    i == PosX ? ARROW_LEFT : " ");	
+					}
+				*/	
+				PrintDevInfo();
+
+				// Starting position.
+				int gamelist_y = MENU_POS_Y + 20*4;
+				if (devState != DEV_OK)
+				{
+					// The warning message overlaps "Boot GC Disc in Drive".
+					// Move the list down by one row.
+					gamelist_y += 20;
+				}
+
+				for (i = 0; i < ListMax; ++i, gamelist_y += 20)
+				{
+					// FIXME: Print all 64 characters of the game name?
+					// Currently truncated to 50.
+					const gameinfo *cur_gi = &gi[i+ScrollX];
+					if (cur_gi->DiscNumber == 0)
+					{
+						// Disc 1.
+					if (which_bg == BG_NONE)
+					{
+			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, gamelist_y,
+							    "%50.50s [%.6s]%s",
+							    cur_gi->Name, cur_gi->ID,
+							    i == PosX ? ARROW_LEFT : " ");			
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, gamelist_y,
+								"%50.50s [%.6s]%s",
+							    cur_gi->Name, cur_gi->ID,
+							    i == PosX ? ARROW_LEFT : " ");	
+					}
+					}
+					else
+					{
+						// Disc 2 or higher.
+					if (which_bg == BG_NONE)
+					{
+						PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, gamelist_y,
+							    "%46.46s (%d) [%.6s]%s",
+							    cur_gi->Name, cur_gi->DiscNumber+1, cur_gi->ID,
+							    i == PosX ? ARROW_LEFT : " ");		
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+						PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, gamelist_y,
+							    "%46.46s (%d) [%.6s]%s",
+							    cur_gi->Name, cur_gi->DiscNumber+1, cur_gi->ID,
+							    i == PosX ? ARROW_LEFT : " ");	
+					}
+					}
+				}
 				GRRLIB_Render();
 				Screenshot();
 				ClearScreen();
@@ -372,153 +649,305 @@
 				redraw = 0;
 			}
 
-		} else {	//settings menu
-			
+		} else {	//settings menu	
 			if(FPAD_X(0)) {
 				UpdateNintendont();
 				redraw = 1;
 			}
-			
+			if(FPAD_Y(0)) {
+				Credits();
+				redraw = 1;
+			}
 			if( FPAD_Down(0) )
 			{
-				PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+30, SettingY(PosX), " " );
-				
+					if (which_bg == BG_NONE)
+					{
+				if(settingPart == 0)
+					PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+30, SettingY(PosX), " " );
+				else
+					PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+300, SettingY(PosX), " " );
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+				if(settingPart == 0)
+					PrintFormat(MENU_SIZE, WHITE, MENU_POS_X+30, SettingY(PosX), " " );
+				else
+					PrintFormat(MENU_SIZE, WHITE, MENU_POS_X+300, SettingY(PosX), " " );
+					}			
+
 				PosX++;
-
-				if (((ncfg->VideoMode & NIN_VID_FORCE) == 0) && (PosX == NIN_SETTINGS_VIDEOMODE))
-					PosX++;
-				if ((!(ncfg->Config & NIN_CFG_MEMCARDEMU)) && (PosX == NIN_SETTINGS_MEMCARDBLOCKS))
-					PosX++;
-				if ((!(ncfg->Config & NIN_CFG_MEMCARDEMU)) && (PosX == NIN_SETTINGS_MEMCARDMULTI))
-					PosX++;
-				if(PosX == NIN_CFG_BIT_HID) //not needed anymore
-					PosX++;
-				if (PosX >= ListMax)
+				if(settingPart == 0)
 				{
+					if (((ncfg->VideoMode & NIN_VID_FORCE) == 0) && (PosX == NIN_SETTINGS_VIDEOMODE))
+						PosX++;
+					if ((!(ncfg->Config & NIN_CFG_MEMCARDEMU)) && (PosX == NIN_SETTINGS_MEMCARDBLOCKS))
+						PosX++;
+					if ((!(ncfg->Config & NIN_CFG_MEMCARDEMU)) && (PosX == NIN_SETTINGS_MEMCARDMULTI))
+						PosX++;
+					//if(PosX == NIN_CFG_BIT_HID) //not needed anymore
+					//	PosX++;
+				}
+				if ((settingPart == 0 && PosX >= ListMax)
+					|| (settingPart == 1 && PosX >= 3))
+				{
 					ScrollX = 0;
 					PosX	= 0;
+					settingPart ^= 1;
 				}
 			
 				redraw=1;
 
-			} else if( FPAD_Up(0) )
+			} 
+			if( FPAD_Up(0) )
 			{
-				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X+30, SettingY(PosX), " " );
+					if (which_bg == BG_NONE)
+					{
+				if(settingPart == 0)
+					PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+30, SettingY(PosX), " " );
+				else
+					PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+300, SettingY(PosX), " " );
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+				if(settingPart == 0)
+					PrintFormat(MENU_SIZE, WHITE, MENU_POS_X+30, SettingY(PosX), " " );
+				else
+					PrintFormat(MENU_SIZE, WHITE, MENU_POS_X+300, SettingY(PosX), " " );
+					}
 
 				PosX--;
 
 				if (PosX < 0)
-					PosX = ListMax - 1;
-				if ((!(ncfg->Config & NIN_CFG_MEMCARDEMU)) && (PosX == NIN_SETTINGS_MEMCARDMULTI))
-					PosX--;
-				if ((!(ncfg->Config & NIN_CFG_MEMCARDEMU)) && (PosX == NIN_SETTINGS_MEMCARDBLOCKS))
-					PosX--;
-				if (((ncfg->VideoMode & NIN_VID_FORCE) == 0) && (PosX == NIN_SETTINGS_VIDEOMODE))
-					PosX--;
-				if(PosX == NIN_CFG_BIT_HID) //not needed anymore
-					PosX--;
+				{
+					settingPart ^= 1;
+					if(settingPart == 0)
+						PosX = ListMax - 1;
+					else
+						PosX = 2;
+				}
+				if(settingPart == 0)
+				{
+					if ((!(ncfg->Config & NIN_CFG_MEMCARDEMU)) && (PosX == NIN_SETTINGS_MEMCARDMULTI))
+						PosX--;
+					if ((!(ncfg->Config & NIN_CFG_MEMCARDEMU)) && (PosX == NIN_SETTINGS_MEMCARDBLOCKS))
+						PosX--;
+					if (((ncfg->VideoMode & NIN_VID_FORCE) == 0) && (PosX == NIN_SETTINGS_VIDEOMODE))
+						PosX--;
+					//if(PosX == NIN_CFG_BIT_HID) //not needed anymore
+					//	PosX--;
+				}
 				redraw=1;
 			}
 
-			if( FPAD_OK(0) )
+			if( FPAD_Left(0) )
 			{
-				SaveSettings = true;
-				if ( PosX < NIN_CFG_BIT_LAST )
+				if(settingPart == 1)
 				{
-					if(PosX == NIN_CFG_BIT_USB) //Option gets replaced
-						ncfg->Config ^= NIN_CFG_WIIU_WIDE;
-					else
-						ncfg->Config ^= (1 << PosX);
+					SaveSettings = true;
+					if(PosX == 0)
+					{
+						if(ncfg->VideoScale == 0)
+							ncfg->VideoScale = 120;
+						else
+						{
+							ncfg->VideoScale-=2;
+							if(ncfg->VideoScale < 40 || ncfg->VideoScale > 120)
+								ncfg->VideoScale = 0; //auto
+						}
+						ReconfigVideo(rmode);
+						redraw = 1;
+					}
+					else if(PosX == 1)
+					{
+						ncfg->VideoOffset--;
+						if(ncfg->VideoOffset < -20 || ncfg->VideoOffset > 20)
+							ncfg->VideoOffset = 20;
+						ReconfigVideo(rmode);
+						redraw = 1;
+					}
 				}
-				else switch( PosX )
+			}
+			else if( FPAD_Right(0) )
+			{
+				if(settingPart == 1)
 				{
-					case NIN_SETTINGS_MAX_PADS:
+					SaveSettings = true;
+					if(PosX == 0)
 					{
-						ncfg->MaxPads++;
-						if (ncfg->MaxPads > NIN_CFG_MAXPAD)
-							ncfg->MaxPads = 0;
-					} break;
-					case NIN_SETTINGS_LANGUAGE:
+						if(ncfg->VideoScale == 0)
+							ncfg->VideoScale = 40;
+						else
+						{
+							ncfg->VideoScale+=2;
+							if(ncfg->VideoScale < 40 || ncfg->VideoScale > 120)
+								ncfg->VideoScale = 0; //auto
+						}
+						ReconfigVideo(rmode);
+						redraw = 1;
+					}
+					else if(PosX == 1)
 					{
-						ncfg->Language++;
-						if (ncfg->Language > NIN_LAN_DUTCH)
-							ncfg->Language = NIN_LAN_AUTO;
-					} break;
-					case NIN_SETTINGS_VIDEO:
+						ncfg->VideoOffset++;
+						if(ncfg->VideoOffset < -20 || ncfg->VideoOffset > 20)
+							ncfg->VideoOffset = -20;
+					ReconfigVideo(rmode);
+					redraw = 1;					
+					}
+				}
+			}
+
+			if( FPAD_OK(0) )
+			{
+				if(settingPart == 0)
+				{
+					SaveSettings = true;
+					if ( PosX < NIN_CFG_BIT_LAST )
 					{
-						u32 Video = (ncfg->VideoMode & NIN_VID_MASK);
-						switch (Video)
+						if(PosX == NIN_CFG_BIT_USB) //Option gets replaced
+							ncfg->Config ^= NIN_CFG_WIIU_WIDE;
+						else
+							ncfg->Config ^= (1 << PosX);
+					}
+					else switch( PosX )
+					{
+						case NIN_SETTINGS_MAX_PADS:
 						{
-							case NIN_VID_AUTO:
-								Video = NIN_VID_FORCE;
-								break;
-							case NIN_VID_FORCE:
-								Video = NIN_VID_FORCE | NIN_VID_FORCE_DF;
-								break;
-							case NIN_VID_FORCE | NIN_VID_FORCE_DF:
-								Video = NIN_VID_NONE;
-								break;
-							default:
-							case NIN_VID_NONE:
-								Video = NIN_VID_AUTO;
-								break;
-						}
-						ncfg->VideoMode &= ~NIN_VID_MASK;
-						ncfg->VideoMode |= Video;
-						if ((Video & NIN_VID_FORCE) == 0)
-							PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+50, SettingY(NIN_SETTINGS_VIDEOMODE), "%29s", "" );
-					} break;
-					case NIN_SETTINGS_VIDEOMODE:
+							ncfg->MaxPads++;
+							if (ncfg->MaxPads > NIN_CFG_MAXPAD)
+								ncfg->MaxPads = 0;
+						} break;
+						case NIN_SETTINGS_LANGUAGE:
+						{
+							ncfg->Language++;
+							if (ncfg->Language > NIN_LAN_DUTCH)
+								ncfg->Language = NIN_LAN_AUTO;
+						} break;
+						case NIN_SETTINGS_VIDEO:
+						{
+							u32 Video = (ncfg->VideoMode & NIN_VID_MASK);
+							switch (Video)
+							{
+								case NIN_VID_AUTO:
+									Video = NIN_VID_FORCE;
+									break;
+								case NIN_VID_FORCE:
+									Video = NIN_VID_FORCE | NIN_VID_FORCE_DF;
+									break;
+								case NIN_VID_FORCE | NIN_VID_FORCE_DF:
+									Video = NIN_VID_NONE;
+									break;
+								default:
+								case NIN_VID_NONE:
+									Video = NIN_VID_AUTO;
+									break;
+							}
+							ncfg->VideoMode &= ~NIN_VID_MASK;
+							ncfg->VideoMode |= Video;
+							if ((Video & NIN_VID_FORCE) == 0)
+					{			
+					if (which_bg == BG_NONE)
 					{
-						u32 Video = (ncfg->VideoMode & NIN_VID_FORCE_MASK);
-						Video = Video << 1;
-						if (Video > NIN_VID_FORCE_MPAL)
-							Video = NIN_VID_FORCE_PAL50;
-						ncfg->VideoMode &= ~NIN_VID_FORCE_MASK;
-						ncfg->VideoMode |= Video;
-					} break;
-					case NIN_SETTINGS_MEMCARDBLOCKS:
+					PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+50, SettingY(NIN_SETTINGS_VIDEOMODE), "%29s", "" );
+					}
+					else if (which_bg == BG_LEGACY)
 					{
-						ncfg->MemCardBlocks++;
-						if (ncfg->MemCardBlocks > MEM_CARD_MAX)
-							ncfg->MemCardBlocks = 0;
-					} break;
-					case NIN_SETTINGS_MEMCARDMULTI:
+					PrintFormat(MENU_SIZE, WHITE, MENU_POS_X+50, SettingY(NIN_SETTINGS_VIDEOMODE), "%29s", "" );
+					}}
+						} break;
+						case NIN_SETTINGS_VIDEOMODE:
+						{
+							u32 Video = (ncfg->VideoMode & NIN_VID_FORCE_MASK);
+							Video = Video << 1;
+							if (Video > NIN_VID_FORCE_MPAL)
+								Video = NIN_VID_FORCE_PAL50;
+							ncfg->VideoMode &= ~NIN_VID_FORCE_MASK;
+							ncfg->VideoMode |= Video;
+						} break;
+						case NIN_SETTINGS_MEMCARDBLOCKS:
+						{
+							ncfg->MemCardBlocks++;
+							if (ncfg->MemCardBlocks > MEM_CARD_MAX)
+								ncfg->MemCardBlocks = 0;
+						} break;
+						case NIN_SETTINGS_MEMCARDMULTI:
+						{
+							ncfg->Config ^= (NIN_CFG_MC_MULTI);
+						} break;
+						case NIN_SETTINGS_NATIVE_SI:
+						{
+							ncfg->Config ^= (NIN_CFG_NATIVE_SI);
+						} break;
+					}
+					if (!(ncfg->Config & NIN_CFG_MEMCARDEMU))
 					{
-						ncfg->Config ^= (NIN_CFG_MC_MULTI);
-					} break;
-					case NIN_SETTINGS_NATIVE_SI:
+					if (which_bg == BG_NONE)
 					{
-						ncfg->Config ^= (NIN_CFG_NATIVE_SI);
-					} break;
-				}
-				if (!(ncfg->Config & NIN_CFG_MEMCARDEMU))
-				{
 					PrintFormat(MENU_SIZE, BLACK, MENU_POS_X + 50, SettingY(NIN_SETTINGS_MEMCARDBLOCKS), "%29s", "");
 					PrintFormat(MENU_SIZE, BLACK, MENU_POS_X + 50, SettingY(NIN_SETTINGS_MEMCARDMULTI), "%29s", "");
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+					PrintFormat(MENU_SIZE, WHITE, MENU_POS_X + 50, SettingY(NIN_SETTINGS_MEMCARDBLOCKS), "%29s", "");
+					PrintFormat(MENU_SIZE, WHITE, MENU_POS_X + 50, SettingY(NIN_SETTINGS_MEMCARDMULTI), "%29s", "");
+					}
+					}
+					redraw = 1;
 				}
-				redraw = 1;
+				else if(settingPart == 1)
+				{
+					if(PosX == 2)
+					{
+						SaveSettings = true;
+						ncfg->VideoMode ^= (NIN_VID_PATCH_PAL50);
+						redraw = 1;
+					}
+				}
 			}
-
 			if( redraw )
 			{
 				u32 ListLoopIndex = 0;
 				for (ListLoopIndex = 0; ListLoopIndex < NIN_CFG_BIT_LAST; ListLoopIndex++)
 				{
-					if(ListLoopIndex == NIN_CFG_BIT_HID) //not needed anymore
-						continue;
+					//if(ListLoopIndex == NIN_CFG_BIT_HID) //not needed anymore
+					//	continue;
 					if(ListLoopIndex == NIN_CFG_BIT_USB) //Option gets replaced
-						PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+50, SettingY(ListLoopIndex), "%-18s:%s", OptionStrings[ListLoopIndex], (ncfg->Config & (NIN_CFG_WIIU_WIDE)) ? "On " : "Off");
+						{					if (which_bg == BG_NONE)
+					{
+PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+50, SettingY(ListLoopIndex), "%-18s:%s", OptionStrings[ListLoopIndex], (ncfg->Config & (NIN_CFG_WIIU_WIDE)) ? "On " : "Off");
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+PrintFormat(MENU_SIZE, WHITE, MENU_POS_X+50, SettingY(ListLoopIndex), "%-18s:%s", OptionStrings[ListLoopIndex], (ncfg->Config & (NIN_CFG_WIIU_WIDE)) ? "On " : "Off");
+					}}
 					else
-						PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+50, SettingY(ListLoopIndex), "%-18s:%s", OptionStrings[ListLoopIndex], (ncfg->Config & (1 << ListLoopIndex)) ? "On " : "Off" );
+						{					if (which_bg == BG_NONE)
+					{
+PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+50, SettingY(ListLoopIndex), "%-18s:%s", OptionStrings[ListLoopIndex], (ncfg->Config & (1 << ListLoopIndex)) ? "On " : "Off" );					}
+					else if (which_bg == BG_LEGACY)
+					{
+PrintFormat(MENU_SIZE, WHITE, MENU_POS_X+50, SettingY(ListLoopIndex), "%-18s:%s", OptionStrings[ListLoopIndex], (ncfg->Config & (1 << ListLoopIndex)) ? "On " : "Off" );					}}
 				}
-				PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+50, SettingY(ListLoopIndex), "%-18s:%d", OptionStrings[ListLoopIndex], (ncfg->MaxPads));
+									if (which_bg == BG_NONE)
+					{
+PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+50, SettingY(ListLoopIndex), "%-18s:%d", OptionStrings[ListLoopIndex], (ncfg->MaxPads));
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+PrintFormat(MENU_SIZE, WHITE, MENU_POS_X+50, SettingY(ListLoopIndex), "%-18s:%d", OptionStrings[ListLoopIndex], (ncfg->MaxPads));
+					}
 				ListLoopIndex++;
 
 				u32 LanIndex = ncfg->Language;
 				if (( LanIndex >= NIN_LAN_LAST ) ||  ( LanIndex < NIN_LAN_FIRST ))
 					LanIndex = NIN_LAN_LAST; //Auto
-				PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+50, SettingY(ListLoopIndex),"%-18s:%-4s", OptionStrings[ListLoopIndex], LanguageStrings[LanIndex] );
+										if (which_bg == BG_NONE)
+					{
+PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+50, SettingY(ListLoopIndex),"%-18s:%-4s", OptionStrings[ListLoopIndex], LanguageStrings[LanIndex] );
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+PrintFormat(MENU_SIZE, WHITE, MENU_POS_X+50, SettingY(ListLoopIndex),"%-18s:%-4s", OptionStrings[ListLoopIndex], LanguageStrings[LanIndex] );
+					}
 				ListLoopIndex++;
 
 				u32 VideoModeIndex;
@@ -542,7 +971,15 @@
 						ncfg->VideoMode |= NIN_VID_AUTO;
 						VideoModeIndex = NIN_VID_INDEX_AUTO;
 				}
-				PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+50, SettingY(ListLoopIndex),"%-18s:%-18s", OptionStrings[ListLoopIndex], VideoStrings[VideoModeIndex] );
+					if (which_bg == BG_NONE)
+					{
+PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+50, SettingY(ListLoopIndex),"%-18s:%-18s", OptionStrings[ListLoopIndex], VideoStrings[VideoModeIndex] );
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+PrintFormat(MENU_SIZE, WHITE, MENU_POS_X+50, SettingY(ListLoopIndex),"%-18s:%-18s", OptionStrings[ListLoopIndex], VideoStrings[VideoModeIndex] );
+					}
+				
 				ListLoopIndex++;
 
 				if( ncfg->VideoMode & NIN_VID_FORCE )
@@ -557,7 +994,14 @@
 						ncfg->VideoMode |= NIN_VID_FORCE_NTSC;
 						VideoModeIndex = NIN_VID_INDEX_FORCE_NTSC;
 					}
-					PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+50, SettingY(ListLoopIndex),"%-18s:%-5s", OptionStrings[ListLoopIndex], VideoModeStrings[VideoModeIndex] );
+					if (which_bg == BG_NONE)
+					{
+PrintFormat(MENU_SIZE, BLACK, MENU_POS_X+50, SettingY(ListLoopIndex),"%-18s:%-5s", OptionStrings[ListLoopIndex], VideoModeStrings[VideoModeIndex] );
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+PrintFormat(MENU_SIZE, WHITE, MENU_POS_X+50, SettingY(ListLoopIndex),"%-18s:%-5s", OptionStrings[ListLoopIndex], VideoModeStrings[VideoModeIndex] );
+					}
 				}
 				ListLoopIndex++;
 
@@ -566,21 +1010,83 @@
 					u32 MemCardBlocksVal = ncfg->MemCardBlocks;
 					if (MemCardBlocksVal > MEM_CARD_MAX)
 						MemCardBlocksVal = 0;
+					if (which_bg == BG_NONE)
+					{
 					PrintFormat(MENU_SIZE, BLACK, MENU_POS_X + 50, SettingY(ListLoopIndex), "%-18s:%-4d%s", OptionStrings[ListLoopIndex], MEM_CARD_BLOCKS(MemCardBlocksVal), MemCardBlocksVal > 2 ? "Unstable" : "");
 					PrintFormat(MENU_SIZE, BLACK, MENU_POS_X + 50, SettingY(ListLoopIndex+1), "%-18s:%-4s", OptionStrings[ListLoopIndex+1], (ncfg->Config & (NIN_CFG_MC_MULTI)) ? "On " : "Off");
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+					PrintFormat(MENU_SIZE, WHITE, MENU_POS_X + 50, SettingY(ListLoopIndex), "%-18s:%-4d%s", OptionStrings[ListLoopIndex], MEM_CARD_BLOCKS(MemCardBlocksVal), MemCardBlocksVal > 2 ? "Unstable" : "");
+					PrintFormat(MENU_SIZE, WHITE, MENU_POS_X + 50, SettingY(ListLoopIndex+1), "%-18s:%-4s", OptionStrings[ListLoopIndex+1], (ncfg->Config & (NIN_CFG_MC_MULTI)) ? "On " : "Off");
+					}						
 				}
 				ListLoopIndex+=2;
-
-				PrintFormat(MENU_SIZE, BLACK, MENU_POS_X + 50, SettingY(ListLoopIndex), "%-18s:%-4s", OptionStrings[ListLoopIndex], (ncfg->Config & (NIN_CFG_NATIVE_SI)) ? "On " : "Off");
+				char vidWidth[10];
+				if(ncfg->VideoScale < 40 || ncfg->VideoScale > 120)
+				{
+					ncfg->VideoScale = 0;
+					snprintf(vidWidth, sizeof(vidWidth), "Auto");
+				}	
+				else
+					snprintf(vidWidth, sizeof(vidWidth), "%i", ncfg->VideoScale + 600);
+				char vidOffset[10];
+				if(ncfg->VideoOffset < -20 || ncfg->VideoOffset > 20)
+					ncfg->VideoOffset = 0;
+				snprintf(vidOffset, sizeof(vidOffset), "%i", ncfg->VideoOffset);	
+				if (which_bg == BG_NONE)
+				{				
+				ListLoopIndex = 0; //reset on other side
+				PrintFormat(MENU_SIZE, BLACK, MENU_POS_X + 320, SettingY(ListLoopIndex), "%-18s:%-4s", "Video Width", vidWidth);
 				ListLoopIndex++;
-
-				PrintFormat(MENU_SIZE, BLACK, MENU_POS_X + 30, SettingY(PosX), ARROW_RIGHT);
-
+				PrintFormat(MENU_SIZE, BLACK, MENU_POS_X + 320, SettingY(ListLoopIndex), "%-18s:%-4s", "Screen Position", vidOffset);
+				ListLoopIndex++;
+				PrintFormat(MENU_SIZE, BLACK, MENU_POS_X + 320, SettingY(ListLoopIndex), "%-18s:%-4s", "Patch PAL50", (ncfg->VideoMode & (NIN_VID_PATCH_PAL50)) ? "On " : "Off");
+				ListLoopIndex++;
+				}
+				else if (which_bg == BG_LEGACY)
+				{				
+				ListLoopIndex = 0; //reset on other side
+				PrintFormat(MENU_SIZE, WHITE, MENU_POS_X + 320, SettingY(ListLoopIndex), "%-18s:%-4s", "Video Width", vidWidth);
+				ListLoopIndex++;
+				PrintFormat(MENU_SIZE, WHITE, MENU_POS_X + 320, SettingY(ListLoopIndex), "%-18s:%-4s", "Screen Position", vidOffset);
+				ListLoopIndex++;
+				PrintFormat(MENU_SIZE, WHITE, MENU_POS_X + 320, SettingY(ListLoopIndex), "%-18s:%-4s", "Patch PAL50", (ncfg->VideoMode & (NIN_VID_PATCH_PAL50)) ? "On " : "Off");
+				ListLoopIndex++;
+				}
+				if(settingPart == 0) {
+				if (which_bg == BG_NONE){
+					PrintFormat(MENU_SIZE, BLACK, MENU_POS_X + 30, SettingY(PosX), ARROW_RIGHT);}
+				else if (which_bg == BG_LEGACY){
+					PrintFormat(MENU_SIZE, WHITE, MENU_POS_X + 30, SettingY(PosX), ARROW_RIGHT);}}
+				else {
+				if (which_bg == BG_NONE){
+					PrintFormat(MENU_SIZE, BLACK, MENU_POS_X + 300, SettingY(PosX), ARROW_RIGHT);}
+				else if (which_bg == BG_LEGACY){
+				PrintFormat(MENU_SIZE, WHITE, MENU_POS_X + 300, SettingY(PosX), ARROW_RIGHT);}}
 				PrintInfo();
-				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "Home: Exit");
-				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*2, "A   : %s", MenuMode ? "Modify" : "Select");
-				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*3, "B   : %s", MenuMode ? "Game List" : "Settings ");
-				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*4, MenuMode ? "X/1 : Update" : "");
+					if (which_bg == BG_NONE)
+					{
+				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y, "  Home: Back");
+				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : %s", MenuMode ? "Modify" : "Select");
+				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : %s", MenuMode ? "Game List" : "Settings ");
+				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*2, "X / 1 : Updates & Themes");
+				PrintFormat(15, BLACK, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+				PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y, "  Home: Back");
+				PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : %s", MenuMode ? "Modify" : "Select");
+				PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : %s", MenuMode ? "Game List" : "Settings ");
+				PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*2, "X / 1 : Updates & Themes");
+				PrintFormat(15, WHITE, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");
+					}
+				if (devState == DEV_OK)
+				{
+					// FIXME: If devState != DEV_OK,
+					// the device info overlaps with the settings menu.
+					PrintDevInfo();
+				}
 				GRRLIB_Render();
 				Screenshot();
 				ClearScreen();
@@ -588,11 +1094,10 @@
 			}
 		}
 	}
-	ClearScreen();
-	PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Loading, please wait...");
+	GRRLIB_FillScreen (BLACK);
+	FadeOut();
+	//PrintFormat(DEFAULT_SIZE, WHITE, 212, 232, "Loading, please wait...");
 	GRRLIB_Render();
-	ClearScreen();
-
 	u32 SelectedGame = PosX + ScrollX;
 	char* StartChar = gi[SelectedGame].Path + 3;
 	if (StartChar[0] == ':')
@@ -601,17 +1106,1677 @@
 	memcpy(&(ncfg->GameID), gi[SelectedGame].ID, 4);
 	DCFlushRange((void*)ncfg, sizeof(NIN_CFG));
 
-	for( i=0; i < gamecount; ++i )
+	// Free allocated memory in the game list.
+	for (i = 0; i < gamecount; ++i)
 	{
-		free(gi[i].Name);
+		if (gi[i].NameAlloc)
+			free(gi[i].Name);
 		free(gi[i].Path);
 	}
+
+	if (!selected)
+	{
+		// No game selected.
+		return 0;
+	}
+
+	// Game is selected.
+	// TODO: Return an enum.
+	return (SaveSettings ? 3 : 1);
+}
+
+/**
+ * Select the source device and game.
+ * @return TRUE to save settings; FALSE if no settings have been changed.
+ */
+bool SelectDevAndGame(void)
+{
+	// Select the source device. (SD or USB)
+	bool SaveSettings = false;
+	while (1)
+	{
+		VIDEO_WaitVSync();
+		FPAD_Update();
+
+		UseSD = (ncfg->Config & NIN_CFG_USB) == 0;
+		PrintInfo();
+						if (which_bg == BG_NONE)
+					{
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*0, "Home: Exit");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "A   : Select");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 53 * 6 - 8, MENU_POS_Y + 20 * 6, UseSD ? ARROW_LEFT : "");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 53 * 6 - 8, MENU_POS_Y + 20 * 7, UseSD ? "" : ARROW_LEFT);
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 47 * 6 - 8, MENU_POS_Y + 20 * 6, " SD  ");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 47 * 6 - 8, MENU_POS_Y + 20 * 7, "USB  ");
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*0, "Home: Exit");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*1, "A   : Select");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 53 * 6 - 8, MENU_POS_Y + 20 * 6, UseSD ? ARROW_LEFT : "");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 53 * 6 - 8, MENU_POS_Y + 20 * 7, UseSD ? "" : ARROW_LEFT);
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 47 * 6 - 8, MENU_POS_Y + 20 * 6, " SD  ");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 47 * 6 - 8, MENU_POS_Y + 20 * 7, "USB  ");
+					}	
+		// Render the screen here to prevent a blank frame
+		// when returning from SelectGame().
+		GRRLIB_Render();
+		ClearScreen();
+
+		if (FPAD_OK(0))
+		{
+			// Select a game from the specified device.
+			int ret = SelectGame();
+			if (ret & 2) SaveSettings = true;
+			if (ret & 1) break;
+		}
+		else if (FPAD_Start(0))
+		{
+			ShowMessageScreenAndExit("Returning to loader...", 0);
+		}
+		else if (FPAD_Down(0))
+		{
+			ncfg->Config = ncfg->Config | NIN_CFG_USB;
+		}
+		else if (FPAD_Up(0))
+		{
+			ncfg->Config = ncfg->Config & ~NIN_CFG_USB;
+		}
+	}
+
 	return SaveSettings;
 }
 
-void PrintInfo()
+/**
+ * Show a single message screen.
+ * @param msg Message.
+ */
+void ShowMessageScreen(const char *msg)
 {
-	PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*1, "Nintendont Loader v%d.%d (%s)", NIN_VERSION>>16, NIN_VERSION&0xFFFF, IsWiiU() ? "Wii U" : "Wii");
-	PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*2, "Built   : %s %s", __DATE__, __TIME__ );
-	PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*3, "Firmware: %d.%d.%d", *(vu16*)0x80003140, *(vu8*)0x80003142, *(vu8*)0x80003143 );
+	const int len = strlen(msg);
+	const int x = (640 - (len*10)) / 2;
+
+	ClearScreen();
+	PrintInfo();
+					if (which_bg == BG_NONE)
+					{
+	PrintFormat(DEFAULT_SIZE, BLACK, x, 232, "%s", msg);
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+	PrintFormat(DEFAULT_SIZE, WHITE, x, 232, "%s", msg);
+					}		
+	GRRLIB_Render();
+	ClearScreen();
 }
+
+/**
+ * Show a single message screen and then exit to loader..
+ * @param msg Message.
+ * @param ret Return value. If non-zero, text will be printed in red.
+ */
+void ShowMessageScreenAndExit(const char *msg, int ret)
+{
+	const int len = strlen(msg);
+	const int x = (640 - (len*10)) / 2;
+	const u32 color = (ret == 0 ? BLACK : MAROON);
+
+	ClearScreen();
+	PrintInfo();
+	PrintFormat(DEFAULT_SIZE, color, x, 232, "%s", msg);
+	ExitToLoader(ret);
+
+	// gcc doesn't know ExitToLoader() exits.
+	exit(ret);
+}
+
+/**
+ * Print Nintendont version and system hardware information.
+ */
+void PrintInfo(void)
+{
+	if (which_bg == BG_NONE)
+	{
+	PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y, "Nintendont Loader v%d.%d (%s)", NIN_VERSION>>16, NIN_VERSION&0xFFFF, IsWiiU() ? "Wii U" : "Wii");
+	PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*1, "Built : %s %s", __DATE__, __TIME__ );
+	//PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*3, "Firmware: %d.%d.%d", *(vu16*)0x80003140, *(vu8*)0x80003142, *(vu8*)0x80003143 );
+	}
+	else if (which_bg == BG_LEGACY)
+	{
+	PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y, "Nintendont Loader v%d.%d (%s)", NIN_VERSION>>16, NIN_VERSION&0xFFFF, IsWiiU() ? "Wii U" : "Wii");
+	PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*1, "Built : %s %s", __DATE__, __TIME__ );
+	//PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*3, "Firmware: %d.%d.%d", *(vu16*)0x80003140, *(vu8*)0x80003142, *(vu8*)0x80003143 );
+	}
+}
+
+/**
+ * Print information about the selected device.
+ */
+static void PrintDevInfo(void)
+{
+	// Device type.
+	const char *s_devType = (UseSD ? "SD" : "USB");
+
+	// Device state.
+	// NOTE: If this is showing a message, the game list
+	// will be moved down by 1 row, which usually isn't
+	// a problem, since it will either be empty or showing
+	// "Boot GC Disc in Drive".
+	switch (devState) {
+		case DEV_NO_OPEN:
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*4,
+				"WARNING: %s FAT device could not be opened.", s_devType);
+			break;
+		case DEV_NO_GAMES:
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*4,
+				"WARNING: %s:/games/ was not found.", GetRootDevice());
+			break;
+		default:
+			break;
+	}
+}
+
+void ReconfigVideo(GXRModeObj *vidmode)
+{
+	if(ncfg->VideoScale >= 40 && ncfg->VideoScale <= 120)
+		vidmode->viWidth = ncfg->VideoScale + 600;
+	else
+		vidmode->viWidth = 640;
+	vidmode->viXOrigin = (720 - vidmode->viWidth) / 2;
+
+	if(ncfg->VideoOffset >= -20 && ncfg->VideoOffset <= 20)
+	{
+		if((vidmode->viXOrigin + ncfg->VideoOffset) < 0)
+			vidmode->viXOrigin = 0;
+		else if((vidmode->viXOrigin + ncfg->VideoOffset) > 80)
+			vidmode->viXOrigin = 80;
+		else
+			vidmode->viXOrigin += ncfg->VideoOffset;
+	}
+	VIDEO_Configure(vidmode);
+}
+
+void CheckTheme()
+{
+	char myid3x[8];
+	char GETID4[8];
+	memset(GETID4, 0, 8);
+	memcpy(GETID4, &(ncfg->GameID), 3);
+	sprintf(myid3x, "%sX.png", GETID4);
+	char myid3[8];	
+	char GETID3[8];
+	memset(GETID3, 0, 8);
+	memcpy(GETID3, &(ncfg->GameID), 3);
+	sprintf(myid3, "%s.png", GETID3);
+	if ((background = GRRLIB_LoadTextureFromFile(myid3x)))
+		{
+			which_bg = BG_LIGHT;
+		}
+	else if ((background = GRRLIB_LoadTextureFromFile(myid3)))
+		{
+			which_bg = BG_NOBAR;
+		}
+	else if ((background = GRRLIB_LoadTextureFromFile("NinBlack.png")))
+		{ 
+			which_bg = BG_BLACK;   
+		}
+	else if ((background = GRRLIB_LoadTextureFromFile("NinBackLight.png")))
+		{ 
+			which_bg = BG_LIGHT;	
+		}
+	else if ((background = GRRLIB_LoadTextureFromFile("NinBackDark.png")))
+		{ 
+			which_bg = BG_DARK;
+		}
+	else if ((background = GRRLIB_LoadTextureFromFile("NinBackBars.png")))
+		{ 
+			which_bg = BG_BARS;
+		}		
+	else if ((background = GRRLIB_LoadTextureFromFile("NinBackNoBar.png")))
+		{ 
+			which_bg = BG_NOBAR;   
+		}
+	else {
+			background = GRRLIB_LoadTextureFromFile("NinLegacy.png");
+			if (background != NULL)
+			{
+			which_bg = BG_LEGACY;
+			}
+			else
+			{
+			which_bg = BG_NONE;
+			background = GRRLIB_LoadTextureFromFile("NinBack.png");
+			if (background == NULL)
+			background = GRRLIB_LoadTexturePNG(background_png);
+			}
+		}
+}
+	
+int i = 0;
+void FadeIt()
+{
+	for (i=0; i<255; i +=5) // Fade background image in from black screen
+	{
+		GRRLIB_DrawImg(0, 0, background, 0, 1, 1, RGBA(255, 255, 255, i)); // Opacity increases as i does
+		GRRLIB_Render();
+	}
+	GRRLIB_DrawImg(0, 0, background, 0, 1, 1, 0xFFFFFFFF);
+}
+int z = 255;
+void FadeOut()
+{
+	GRRLIB_DrawImg(0, 0, background, 0, 1, 1, 0xFFFFFFFF);
+	for (z=255; z>0; z -=5) // Fade background image out to black screen
+	{
+		GRRLIB_DrawImg(0, 0, background, 0, 1, 1, RGBA(255, 255, 255, z)); // Opacity increases as i does
+		GRRLIB_Render();
+	}
+}
+void BackTheme()
+{
+			GRRLIB_FreeTexture(background);
+			background = GRRLIB_LoadTextureFromFile("NinLegacy.png");
+			if (background != NULL)
+			{
+			which_bg = BG_LEGACY;
+			}
+			else
+			{
+			which_bg = BG_NONE;
+			background = GRRLIB_LoadTextureFromFile("NinBack.png");
+			if (background == NULL)
+			background = GRRLIB_LoadTexturePNG(background_png);
+			}
+}
+void DeleteCache(){
+	remove( "back00.zip" );
+	remove( "back01.zip" );
+	remove( "back02.zip" );
+	remove( "back03.zip" );
+	remove( "back04.zip" );
+	remove( "back05.zip" );
+	remove( "back06.zip" );
+	remove( "back07.zip" );
+	remove( "back08.zip" );
+	remove( "back09.zip" );
+	remove( "back10.zip" );
+	remove( "back11.zip" );
+	remove( "back12.zip" );
+	remove( "back13.zip" );
+	remove( "back14.zip" );
+	remove( "back15.zip" );
+	remove( "legacy00.zip" );
+	remove( "legacy01.zip" );
+	remove( "legacy02.zip" );
+	remove( "legacy03.zip" );
+	remove( "legacy04.zip" );
+	remove( "legacy05.zip" );
+	remove( "legacy06.zip" );
+	remove( "legacy07.zip" );
+	remove( "legacy08.zip" );
+	remove( "legacy09.zip" );
+	remove( "legacy10.zip" );
+	remove( "legacy11.zip" );
+	remove( "legacy12.zip" );
+	remove( "legacy13.zip" );
+	remove( "legacy14.zip" );
+	remove( "legacy15.zip" );
+	remove( "grad00.zip" );
+	remove( "grad01.zip" );
+	remove( "grad02.zip" );
+	remove( "grad03.zip" );
+	remove( "grad04.zip" );
+	remove( "grad05.zip" );
+	remove( "grad06.zip" );
+	remove( "grad07.zip" );
+	remove( "grad08.zip" );
+	remove( "grad09.zip" );
+	remove( "grad10.zip" );
+	remove( "grad11.zip" );
+	remove( "grad12.zip" );
+	remove( "grad13.zip" );
+	remove( "grad14.zip" );
+	remove( "grad15.zip" );	
+	remove( "black.zip" );
+	remove( "aaa.zip" );
+	remove( "bars.zip" );
+	remove( "bbb.zip" );
+	remove( "ccc.zip" );
+	remove( "classic.zip" );
+	remove( "classicwii.zip" );
+	remove( "dark.zip" );
+	remove( "discs.zip" );
+	remove( "gcns.zip" );
+	remove( "light.zip" );
+	remove( "mmblue.zip" );
+	remove( "mmclassic.zip" );
+	remove( "mmdark1.zip" );
+	remove( "mmdark2.zip" );
+	remove( "orange.zip" );
+	remove( "purple.zip" );
+	remove( "smash.zip" );
+	remove( "theme0.zip" );
+	remove( "iplall.zip" );
+	remove( "iplusa.zip" );
+	remove( "iplpal.zip" );
+	remove( "ipljap.zip" );
+	remove( "segaboot.zip" );
+	remove( "controllers.zip" );
+	remove( "test.png" );}
+
+void DeleteCustom()
+{
+remove( "test.png" );
+remove( "D42X.png" );
+remove( "D43X.png" );
+remove( "D44X.png" );
+remove( "D45X.png" );
+remove( "D4LX.png" );
+remove( "D56X.png" );
+remove( "G2BX.png" );
+remove( "G2CX.png" );
+remove( "G2FX.png" );
+remove( "G2GX.png" );
+remove( "G2KX.png" );
+remove( "G2MX.png" );
+remove( "G2OX.png" );
+remove( "G2PX.png" );
+remove( "G2RX.png" );
+remove( "G2SX.png" );
+remove( "G2TX.png" );
+remove( "G2VX.png" );
+remove( "G2XX.png" );
+remove( "G3AX.png" );
+remove( "G3BX.png" );
+remove( "G3DX.png" );
+remove( "G3EX.png" );
+remove( "G3FX.png" );
+remove( "G3JX.png" );
+remove( "G3LX.png" );
+remove( "G3MX.png" );
+remove( "G3NX.png" );
+remove( "G3QX.png" );
+remove( "G3RX.png" );
+remove( "G3SX.png" );
+remove( "G3VX.png" );
+remove( "G3XX.png" );
+remove( "G3YX.png" );
+remove( "G4AX.png" );
+remove( "G4BX.png" );
+remove( "G4CX.png" );
+remove( "G4FX.png" );
+remove( "G4GX.png" );
+remove( "G4IX.png" );
+remove( "G4MX.png" );
+remove( "G4NX.png" );
+remove( "G4OX.png" );
+remove( "G4QX.png" );
+remove( "G4SX.png" );
+remove( "G4ZX.png" );
+remove( "G5BX.png" );
+remove( "G5DX.png" );
+remove( "G5NX.png" );
+remove( "G5SX.png" );
+remove( "G5TX.png" );
+remove( "G62X.png" );
+remove( "G63X.png" );
+remove( "G6FX.png" );
+remove( "G6MX.png" );
+remove( "G6NX.png" );
+remove( "G6QX.png" );
+remove( "G6SX.png" );
+remove( "G6TX.png" );
+remove( "G6WX.png" );
+remove( "G7MX.png" );
+remove( "G89X.png" );
+remove( "G8FX.png" );
+remove( "G8MX.png" );
+remove( "G8SX.png" );
+remove( "G8WX.png" );
+remove( "G9BX.png" );
+remove( "G9RX.png" );
+remove( "G9SX.png" );
+remove( "G9TX.png" );
+remove( "GA2X.png" );
+remove( "GA3X.png" );
+remove( "GA4X.png" );
+remove( "GA7X.png" );
+remove( "GAAX.png" );
+remove( "GABX.png" );
+remove( "GACX.png" );
+remove( "GAFX.png" );
+remove( "GAGX.png" );
+remove( "GAHX.png" );
+remove( "GAKX.png" );
+remove( "GALX.png" );
+remove( "GAMX.png" );
+remove( "GANX.png" );
+remove( "GAPX.png" );
+remove( "GAQX.png" );
+remove( "GARX.png" );
+remove( "GATX.png" );
+remove( "GAUX.png" );
+remove( "GAVX.png" );
+remove( "GAXX.png" );
+remove( "GAYX.png" );
+remove( "GAZX.png" );
+remove( "GB2X.png" );
+remove( "GB3X.png" );
+remove( "GB4X.png" );
+remove( "GBAX.png" );
+remove( "GBDX.png" );
+remove( "GBFX.png" );
+remove( "GBGX.png" );
+remove( "GBHX.png" );
+remove( "GBIX.png" );
+remove( "GBKX.png" );
+remove( "GBLX.png" );
+remove( "GBMX.png" );
+remove( "GBNX.png" );
+remove( "GBOX.png" );
+remove( "GBQX.png" );
+remove( "GBSX.png" );
+remove( "GBTX.png" );
+remove( "GBVX.png" );
+remove( "GBWX.png" );
+remove( "GBXX.png" );
+remove( "GBYX.png" );
+remove( "GBZX.png" );
+remove( "GC2X.png" );
+remove( "GC3X.png" );
+remove( "GC4X.png" );
+remove( "GC5X.png" );
+remove( "GC6X.png" );
+remove( "GC7X.png" );
+remove( "GC9X.png" );
+remove( "GCAX.png" );
+remove( "GCBX.png" );
+remove( "GCCX.png" );
+remove( "GCDX.png" );
+remove( "GCEX.png" );
+remove( "GCFX.png" );
+remove( "GCGX.png" );
+remove( "GCHX.png" );
+remove( "GCJX.png" );
+remove( "GCLX.png" );
+remove( "GCNX.png" );
+remove( "GCOX.png" );
+remove( "GCPX.png" );
+remove( "GCQX.png" );
+remove( "GCSX.png" );
+remove( "GCTX.png" );
+remove( "GCUX.png" );
+remove( "GCVX.png" );
+remove( "GCWX.png" );
+remove( "GCZX.png" );
+remove( "GD4X.png" );
+remove( "GD5X.png" );
+remove( "GD6X.png" );
+remove( "GD7X.png" );
+remove( "GD9X.png" );
+remove( "GDCX.png" );
+remove( "GDDX.png" );
+remove( "GDEX.png" );
+remove( "GDFX.png" );
+remove( "GDGX.png" );
+remove( "GDIX.png" );
+remove( "GDJX.png" );
+remove( "GDKX.png" );
+remove( "GDLX.png" );
+remove( "GDMX.png" );
+remove( "GDOX.png" );
+remove( "GDPX.png" );
+remove( "GDQX.png" );
+remove( "GDRX.png" );
+remove( "GDSX.png" );
+remove( "GDTX.png" );
+remove( "GDVX.png" );
+remove( "GDWX.png" );
+remove( "GDXX.png" );
+remove( "GE3X.png" );
+remove( "GE4X.png" );
+remove( "GE5X.png" );
+remove( "GE9X.png" );
+remove( "GEAX.png" );
+remove( "GEBX.png" );
+remove( "GEDX.png" );
+remove( "GEMX.png" );
+remove( "GENX.png" );
+remove( "GEOX.png" );
+remove( "GESX.png" );
+remove( "GEVX.png" );
+remove( "GEWX.png" );
+remove( "GEXX.png" );
+remove( "GEYX.png" );
+remove( "GEZX.png" );
+remove( "GF2X.png" );
+remove( "GF3X.png" );
+remove( "GF4X.png" );
+remove( "GF5X.png" );
+remove( "GF6X.png" );
+remove( "GF7X.png" );
+remove( "GFAX.png" );
+remove( "GFBX.png" );
+remove( "GFDX.png" );
+remove( "GFEX.png" );
+remove( "GFFX.png" );
+remove( "GFGX.png" );
+remove( "GFHX.png" );
+remove( "GFIX.png" );
+remove( "GFKX.png" );
+remove( "GFNX.png" );
+remove( "GFOX.png" );
+remove( "GFPX.png" );
+remove( "GFQX.png" );
+remove( "GFSX.png" );
+remove( "GFTX.png" );
+remove( "GFUX.png" );
+remove( "GFVX.png" );
+remove( "GFWX.png" );
+remove( "GFXX.png" );
+remove( "GFYX.png" );
+remove( "GFZX.png" );
+remove( "GG2X.png" );
+remove( "GG4X.png" );
+remove( "GG5X.png" );
+remove( "GGAX.png" );
+remove( "GGCX.png" );
+remove( "GGEX.png" );
+remove( "GGNX.png" );
+remove( "GGPX.png" );
+remove( "GGRX.png" );
+remove( "GGSX.png" );
+remove( "GGTX.png" );
+remove( "GGVX.png" );
+remove( "GGYX.png" );
+remove( "GGZX.png" );
+remove( "GH2X.png" );
+remove( "GH3X.png" );
+remove( "GH4X.png" );
+remove( "GH5X.png" );
+remove( "GH6X.png" );
+remove( "GH7X.png" );
+remove( "GH9X.png" );
+remove( "GHAX.png" );
+remove( "GHBX.png" );
+remove( "GHCX.png" );
+remove( "GHEX.png" );
+remove( "GHFX.png" );
+remove( "GHGX.png" );
+remove( "GHKX.png" );
+remove( "GHLX.png" );
+remove( "GHMX.png" );
+remove( "GHNX.png" );
+remove( "GHPX.png" );
+remove( "GHQX.png" );
+remove( "GHRX.png" );
+remove( "GHSX.png" );
+remove( "GHUX.png" );
+remove( "GHVX.png" );
+remove( "GHWX.png" );
+remove( "GHYX.png" );
+remove( "GHZX.png" );
+remove( "GIAX.png" );
+remove( "GIBX.png" );
+remove( "GICX.png" );
+remove( "GIGX.png" );
+remove( "GIHX.png" );
+remove( "GIJX.png" );
+remove( "GIKX.png" );
+remove( "GILX.png" );
+remove( "GINX.png" );
+remove( "GIPX.png" );
+remove( "GIQX.png" );
+remove( "GISX.png" );
+remove( "GITX.png" );
+remove( "GIVX.png" );
+remove( "GIZX.png" );
+remove( "GJ2X.png" );
+remove( "GJ3X.png" );
+remove( "GJBX.png" );
+remove( "GJCX.png" );
+remove( "GJDX.png" );
+remove( "GJFX.png" );
+remove( "GJKX.png" );
+remove( "GJNX.png" );
+remove( "GJSX.png" );
+remove( "GJUX.png" );
+remove( "GJWX.png" );
+remove( "GJXX.png" );
+remove( "GJYX.png" );
+remove( "GJZX.png" );
+remove( "GK2X.png" );
+remove( "GK3X.png" );
+remove( "GK4X.png" );
+remove( "GK5X.png" );
+remove( "GK7X.png" );
+remove( "GK9X.png" );
+remove( "GKAX.png" );
+remove( "GKBX.png" );
+remove( "GKDX.png" );
+remove( "GKFX.png" );
+remove( "GKGX.png" );
+remove( "GKHX.png" );
+remove( "GKJX.png" );
+remove( "GKKX.png" );
+remove( "GKLX.png" );
+remove( "GKMX.png" );
+remove( "GKNX.png" );
+remove( "GKOX.png" );
+remove( "GKQX.png" );
+remove( "GKRX.png" );
+remove( "GKSX.png" );
+remove( "GKTX.png" );
+remove( "GKUX.png" );
+remove( "GKWX.png" );
+remove( "GKYX.png" );
+remove( "GKZX.png" );
+remove( "GL2X.png" );
+remove( "GL5X.png" );
+remove( "GL7X.png" );
+remove( "GL8X.png" );
+remove( "GLBX.png" );
+remove( "GLCX.png" );
+remove( "GLEX.png" );
+remove( "GLGX.png" );
+remove( "GLHX.png" );
+remove( "GLLX.png" );
+remove( "GLMX.png" );
+remove( "GLMEX.png" );
+remove( "GLNX.png" );
+remove( "GLOX.png" );
+remove( "GLQX.png" );
+remove( "GLRX.png" );
+remove( "GLSX.png" );
+remove( "GLUX.png" );
+remove( "GLVX.png" );
+remove( "GLWX.png" );
+remove( "GLYX.png" );
+remove( "GLZX.png" );
+remove( "GM2X.png" );
+remove( "GM3X.png" );
+remove( "GM4X.png" );
+remove( "GM5X.png" );
+remove( "GM6X.png" );
+remove( "GM8X.png" );
+remove( "GM9X.png" );
+remove( "GMAX.png" );
+remove( "GMBX.png" );
+remove( "GMDX.png" );
+remove( "GMEX.png" );
+remove( "GMFX.png" );
+remove( "GMHX.png" );
+remove( "GMIX.png" );
+remove( "GMJX.png" );
+remove( "GMKX.png" );
+remove( "GMLX.png" );
+remove( "GMNX.png" );
+remove( "GMOX.png" );
+remove( "GMPX.png" );
+remove( "GMQX.png" );
+remove( "GMRX.png" );
+remove( "GMSX.png" );
+remove( "GMTX.png" );
+remove( "GMUX.png" );
+remove( "GMWX.png" );
+remove( "GMXX.png" );
+remove( "GMYX.png" );
+remove( "GMZX.png" );
+remove( "GN2X.png" );
+remove( "GN3X.png" );
+remove( "GN4X.png" );
+remove( "GN5X.png" );
+remove( "GN6X.png" );
+remove( "GN7X.png" );
+remove( "GN8X.png" );
+remove( "GN9X.png" );
+remove( "GNAX.png" );
+remove( "GNBX.png" );
+remove( "GNCX.png" );
+remove( "GNDX.png" );
+remove( "GNEX.png" );
+remove( "GNFX.png" );
+remove( "GNGX.png" );
+remove( "GNHX.png" );
+remove( "GNIX.png" );
+remove( "GNJX.png" );
+remove( "GNKX.png" );
+remove( "GNNX.png" );
+remove( "GNOX.png" );
+remove( "GNPX.png" );
+remove( "GNQX.png" );
+remove( "GNRX.png" );
+remove( "GNSX.png" );
+remove( "GNUX.png" );
+remove( "GNVX.png" );
+remove( "GNWX.png" );
+remove( "GNXX.png" );
+remove( "GNZX.png" );
+remove( "GO2X.png" );
+remove( "GO3X.png" );
+remove( "GO7X.png" );
+remove( "GOAX.png" );
+remove( "GOBX.png" );
+remove( "GOCX.png" );
+remove( "GOFX.png" );
+remove( "GOGX.png" );
+remove( "GOMX.png" );
+remove( "GONX.png" );
+remove( "GOOX.png" );
+remove( "GOPX.png" );
+remove( "GOQX.png" );
+remove( "GOSX.png" );
+remove( "GOWX.png" );
+remove( "GOYX.png" );
+remove( "GP2X.png" );
+remove( "GP3X.png" );
+remove( "GP4X.png" );
+remove( "GP5X.png" );
+remove( "GP6X.png" );
+remove( "GP7X.png" );
+remove( "GP8X.png" );
+remove( "GP9X.png" );
+remove( "GPAX.png" );
+remove( "GPDX.png" );
+remove( "GPEX.png" );
+remove( "GPHX.png" );
+remove( "GPIX.png" );
+remove( "GPKX.png" );
+remove( "GPLX.png" );
+remove( "GPMX.png" );
+remove( "GPNX.png" );
+remove( "GPOX.png" );
+remove( "GPQX.png" );
+remove( "GPRX.png" );
+remove( "GPSX.png" );
+remove( "GPTX.png" );
+remove( "GPUX.png" );
+remove( "GPVX.png" );
+remove( "GPWX.png" );
+remove( "GPXX.png" );
+remove( "GPYX.png" );
+remove( "GPZX.png" );
+remove( "GQ4X.png" );
+remove( "GQ8X.png" );
+remove( "GQBX.png" );
+remove( "GQCX.png" );
+remove( "GQLX.png" );
+remove( "GQNX.png" );
+remove( "GQPX.png" );
+remove( "GQQX.png" );
+remove( "GQRX.png" );
+remove( "GQSX.png" );
+remove( "GQTX.png" );
+remove( "GQWX.png" );
+remove( "GQXX.png" );
+remove( "GR2X.png" );
+remove( "GR3X.png" );
+remove( "GR4X.png" );
+remove( "GR5X.png" );
+remove( "GR6X.png" );
+remove( "GR8X.png" );
+remove( "GRAX.png" );
+remove( "GRBX.png" );
+remove( "GREX.png" );
+remove( "GRFX.png" );
+remove( "GRHX.png" );
+remove( "GRJX.png" );
+remove( "GRLX.png" );
+remove( "GRMX.png" );
+remove( "GRNX.png" );
+remove( "GROX.png" );
+remove( "GRQX.png" );
+remove( "GRRX.png" );
+remove( "GRSX.png" );
+remove( "GRUX.png" );
+remove( "GRVX.png" );
+remove( "GRWX.png" );
+remove( "GRYX.png" );
+remove( "GS2X.png" );
+remove( "GS3X.png" );
+remove( "GS7X.png" );
+remove( "GS8X.png" );
+remove( "GS9X.png" );
+remove( "GSAX.png" );
+remove( "GSBX.png" );
+remove( "GSCX.png" );
+remove( "GSDX.png" );
+remove( "GSEX.png" );
+remove( "GSGX.png" );
+remove( "GSHX.png" );
+remove( "GSKX.png" );
+remove( "GSMX.png" );
+remove( "GSNX.png" );
+remove( "GSOX.png" );
+remove( "GSPX.png" );
+remove( "GSQX.png" );
+remove( "GSRX.png" );
+remove( "GSSX.png" );
+remove( "GSTX.png" );
+remove( "GSUX.png" );
+remove( "GSVX.png" );
+remove( "GSWX.png" );
+remove( "GSXX.png" );
+remove( "GSYX.png" );
+remove( "GSZX.png" );
+remove( "GT3X.png" );
+remove( "GT4X.png" );
+remove( "GT5X.png" );
+remove( "GT6X.png" );
+remove( "GT7X.png" );
+remove( "GT8X.png" );
+remove( "GTAX.png" );
+remove( "GTCX.png" );
+remove( "GTDX.png" );
+remove( "GTEX.png" );
+remove( "GTFX.png" );
+remove( "GTGX.png" );
+remove( "GTIX.png" );
+remove( "GTJX.png" );
+remove( "GTKX.png" );
+remove( "GTLX.png" );
+remove( "GTNX.png" );
+remove( "GTPX.png" );
+remove( "GTQX.png" );
+remove( "GTRX.png" );
+remove( "GTSX.png" );
+remove( "GTUX.png" );
+remove( "GTVX.png" );
+remove( "GTWX.png" );
+remove( "GTYX.png" );
+remove( "GTZX.png" );
+remove( "GU2X.png" );
+remove( "GU3X.png" );
+remove( "GU4X.png" );
+remove( "GU6X.png" );
+remove( "GUBX.png" );
+remove( "GUCX.png" );
+remove( "GUFX.png" );
+remove( "GUGX.png" );
+remove( "GUMX.png" );
+remove( "GUNX.png" );
+remove( "GUPX.png" );
+remove( "GUSX.png" );
+remove( "GUTX.png" );
+remove( "GUVX.png" );
+remove( "GUZX.png" );
+remove( "GV3X.png" );
+remove( "GV4X.png" );
+remove( "GVCX.png" );
+remove( "GVDX.png" );
+remove( "GVHX.png" );
+remove( "GVJX.png" );
+remove( "GVKX.png" );
+remove( "GVLX.png" );
+remove( "GVMX.png" );
+remove( "GVOX.png" );
+remove( "GVPX.png" );
+remove( "GVRX.png" );
+remove( "GVSX.png" );
+remove( "GW2X.png" );
+remove( "GW3X.png" );
+remove( "GW4X.png" );
+remove( "GW5X.png" );
+remove( "GW6X.png" );
+remove( "GW7X.png" );
+remove( "GW8X.png" );
+remove( "GW9X.png" );
+remove( "GWAX.png" );
+remove( "GWBX.png" );
+remove( "GWEX.png" );
+remove( "GWGX.png" );
+remove( "GWHX.png" );
+remove( "GWJX.png" );
+remove( "GWKX.png" );
+remove( "GWLX.png" );
+remove( "GWMX.png" );
+remove( "GWOX.png" );
+remove( "GWPX.png" );
+remove( "GWQX.png" );
+remove( "GWRX.png" );
+remove( "GWSX.png" );
+remove( "GWTX.png" );
+remove( "GWUX.png" );
+remove( "GWVX.png" );
+remove( "GWWX.png" );
+remove( "GWYX.png" );
+remove( "GWZX.png" );
+remove( "GX2X.png" );
+remove( "GX3X.png" );
+remove( "GXAX.png" );
+remove( "GXBX.png" );
+remove( "GXCX.png" );
+remove( "GXEX.png" );
+remove( "GXFX.png" );
+remove( "GXGX.png" );
+remove( "GXLX.png" );
+remove( "GXMX.png" );
+remove( "GXNX.png" );
+remove( "GXOX.png" );
+remove( "GXPX.png" );
+remove( "GXQX.png" );
+remove( "GXRX.png" );
+remove( "GXSX.png" );
+remove( "GXUX.png" );
+remove( "GXXX.png" );
+remove( "GY2X.png" );
+remove( "GY3X.png" );
+remove( "GYAX.png" );
+remove( "GYBX.png" );
+remove( "GYFX.png" );
+remove( "GYKX.png" );
+remove( "GYQX.png" );
+remove( "GYRX.png" );
+remove( "GYTX.png" );
+remove( "GYWX.png" );
+remove( "GZ2X.png" );
+remove( "GZ3X.png" );
+remove( "GZCX.png" );
+remove( "GZDX.png" );
+remove( "GZEX.png" );
+remove( "GZHX.png" );
+remove( "GZLX.png" );
+remove( "GZMX.png" );
+remove( "GZOX.png" );
+remove( "GZPX.png" );
+remove( "GZQX.png" );
+remove( "GZSX.png" );
+remove( "GZVX.png" );
+remove( "GZWX.png" );
+remove( "P2MX.png" );
+remove( "PC6X.png" );
+remove( "PM4X.png" );
+remove( "PRJX.png" );
+remove( "PZLX.png" );
+remove( "D42.png" );
+remove( "D43.png" );
+remove( "D44.png" );
+remove( "D45.png" );
+remove( "D4L.png" );
+remove( "D56.png" );
+remove( "G2B.png" );
+remove( "G2C.png" );
+remove( "G2F.png" );
+remove( "G2G.png" );
+remove( "G2K.png" );
+remove( "G2M.png" );
+remove( "G2O.png" );
+remove( "G2P.png" );
+remove( "G2R.png" );
+remove( "G2S.png" );
+remove( "G2T.png" );
+remove( "G2V.png" );
+remove( "G2X.png" );
+remove( "G3A.png" );
+remove( "G3B.png" );
+remove( "G3D.png" );
+remove( "G3E.png" );
+remove( "G3F.png" );
+remove( "G3J.png" );
+remove( "G3L.png" );
+remove( "G3M.png" );
+remove( "G3N.png" );
+remove( "G3Q.png" );
+remove( "G3R.png" );
+remove( "G3S.png" );
+remove( "G3V.png" );
+remove( "G3X.png" );
+remove( "G3Y.png" );
+remove( "G4A.png" );
+remove( "G4B.png" );
+remove( "G4C.png" );
+remove( "G4F.png" );
+remove( "G4G.png" );
+remove( "G4I.png" );
+remove( "G4M.png" );
+remove( "G4N.png" );
+remove( "G4O.png" );
+remove( "G4Q.png" );
+remove( "G4S.png" );
+remove( "G4Z.png" );
+remove( "G5B.png" );
+remove( "G5D.png" );
+remove( "G5N.png" );
+remove( "G5S.png" );
+remove( "G5T.png" );
+remove( "G62.png" );
+remove( "G63.png" );
+remove( "G6F.png" );
+remove( "G6M.png" );
+remove( "G6N.png" );
+remove( "G6Q.png" );
+remove( "G6S.png" );
+remove( "G6T.png" );
+remove( "G6W.png" );
+remove( "G7M.png" );
+remove( "G89.png" );
+remove( "G8F.png" );
+remove( "G8M.png" );
+remove( "G8S.png" );
+remove( "G8W.png" );
+remove( "G9B.png" );
+remove( "G9R.png" );
+remove( "G9S.png" );
+remove( "G9T.png" );
+remove( "GA2.png" );
+remove( "GA3.png" );
+remove( "GA4.png" );
+remove( "GA7.png" );
+remove( "GAA.png" );
+remove( "GAB.png" );
+remove( "GAC.png" );
+remove( "GAF.png" );
+remove( "GAG.png" );
+remove( "GAH.png" );
+remove( "GAK.png" );
+remove( "GAL.png" );
+remove( "GAM.png" );
+remove( "GAN.png" );
+remove( "GAP.png" );
+remove( "GAQ.png" );
+remove( "GAR.png" );
+remove( "GAT.png" );
+remove( "GAU.png" );
+remove( "GAV.png" );
+remove( "GAX.png" );
+remove( "GAY.png" );
+remove( "GAZ.png" );
+remove( "GB2.png" );
+remove( "GB3.png" );
+remove( "GB4.png" );
+remove( "GBA.png" );
+remove( "GBD.png" );
+remove( "GBF.png" );
+remove( "GBG.png" );
+remove( "GBH.png" );
+remove( "GBI.png" );
+remove( "GBK.png" );
+remove( "GBL.png" );
+remove( "GBM.png" );
+remove( "GBN.png" );
+remove( "GBO.png" );
+remove( "GBQ.png" );
+remove( "GBS.png" );
+remove( "GBT.png" );
+remove( "GBV.png" );
+remove( "GBW.png" );
+remove( "GBX.png" );
+remove( "GBY.png" );
+remove( "GBZ.png" );
+remove( "GC2.png" );
+remove( "GC3.png" );
+remove( "GC4.png" );
+remove( "GC5.png" );
+remove( "GC6.png" );
+remove( "GC7.png" );
+remove( "GC9.png" );
+remove( "GCA.png" );
+remove( "GCB.png" );
+remove( "GCC.png" );
+remove( "GCD.png" );
+remove( "GCE.png" );
+remove( "GCF.png" );
+remove( "GCG.png" );
+remove( "GCH.png" );
+remove( "GCJ.png" );
+remove( "GCL.png" );
+remove( "GCN.png" );
+remove( "GCO.png" );
+remove( "GCP.png" );
+remove( "GCQ.png" );
+remove( "GCS.png" );
+remove( "GCT.png" );
+remove( "GCU.png" );
+remove( "GCV.png" );
+remove( "GCW.png" );
+remove( "GCZ.png" );
+remove( "GD4.png" );
+remove( "GD5.png" );
+remove( "GD6.png" );
+remove( "GD7.png" );
+remove( "GD9.png" );
+remove( "GDC.png" );
+remove( "GDD.png" );
+remove( "GDE.png" );
+remove( "GDF.png" );
+remove( "GDG.png" );
+remove( "GDI.png" );
+remove( "GDJ.png" );
+remove( "GDK.png" );
+remove( "GDL.png" );
+remove( "GDM.png" );
+remove( "GDO.png" );
+remove( "GDP.png" );
+remove( "GDQ.png" );
+remove( "GDR.png" );
+remove( "GDS.png" );
+remove( "GDT.png" );
+remove( "GDV.png" );
+remove( "GDW.png" );
+remove( "GDX.png" );
+remove( "GE3.png" );
+remove( "GE4.png" );
+remove( "GE5.png" );
+remove( "GE9.png" );
+remove( "GEA.png" );
+remove( "GEB.png" );
+remove( "GED.png" );
+remove( "GEM.png" );
+remove( "GEN.png" );
+remove( "GEO.png" );
+remove( "GES.png" );
+remove( "GEV.png" );
+remove( "GEW.png" );
+remove( "GEX.png" );
+remove( "GEY.png" );
+remove( "GEZ.png" );
+remove( "GF2.png" );
+remove( "GF3.png" );
+remove( "GF4.png" );
+remove( "GF5.png" );
+remove( "GF6.png" );
+remove( "GF7.png" );
+remove( "GFA.png" );
+remove( "GFB.png" );
+remove( "GFD.png" );
+remove( "GFE.png" );
+remove( "GFF.png" );
+remove( "GFG.png" );
+remove( "GFH.png" );
+remove( "GFI.png" );
+remove( "GFK.png" );
+remove( "GFN.png" );
+remove( "GFO.png" );
+remove( "GFP.png" );
+remove( "GFQ.png" );
+remove( "GFS.png" );
+remove( "GFT.png" );
+remove( "GFU.png" );
+remove( "GFV.png" );
+remove( "GFW.png" );
+remove( "GFX.png" );
+remove( "GFY.png" );
+remove( "GFZ.png" );
+remove( "GG2.png" );
+remove( "GG4.png" );
+remove( "GG5.png" );
+remove( "GGA.png" );
+remove( "GGC.png" );
+remove( "GGE.png" );
+remove( "GGN.png" );
+remove( "GGP.png" );
+remove( "GGR.png" );
+remove( "GGS.png" );
+remove( "GGT.png" );
+remove( "GGV.png" );
+remove( "GGY.png" );
+remove( "GGZ.png" );
+remove( "GH2.png" );
+remove( "GH3.png" );
+remove( "GH4.png" );
+remove( "GH5.png" );
+remove( "GH6.png" );
+remove( "GH7.png" );
+remove( "GH9.png" );
+remove( "GHA.png" );
+remove( "GHB.png" );
+remove( "GHC.png" );
+remove( "GHE.png" );
+remove( "GHF.png" );
+remove( "GHG.png" );
+remove( "GHK.png" );
+remove( "GHL.png" );
+remove( "GHM.png" );
+remove( "GHN.png" );
+remove( "GHP.png" );
+remove( "GHQ.png" );
+remove( "GHR.png" );
+remove( "GHS.png" );
+remove( "GHU.png" );
+remove( "GHV.png" );
+remove( "GHW.png" );
+remove( "GHY.png" );
+remove( "GHZ.png" );
+remove( "GIA.png" );
+remove( "GIB.png" );
+remove( "GIC.png" );
+remove( "GIG.png" );
+remove( "GIH.png" );
+remove( "GIJ.png" );
+remove( "GIK.png" );
+remove( "GIL.png" );
+remove( "GIN.png" );
+remove( "GIP.png" );
+remove( "GIQ.png" );
+remove( "GIS.png" );
+remove( "GIT.png" );
+remove( "GIV.png" );
+remove( "GIZ.png" );
+remove( "GJ2.png" );
+remove( "GJ3.png" );
+remove( "GJB.png" );
+remove( "GJC.png" );
+remove( "GJD.png" );
+remove( "GJF.png" );
+remove( "GJK.png" );
+remove( "GJN.png" );
+remove( "GJS.png" );
+remove( "GJU.png" );
+remove( "GJW.png" );
+remove( "GJX.png" );
+remove( "GJY.png" );
+remove( "GJZ.png" );
+remove( "GK2.png" );
+remove( "GK3.png" );
+remove( "GK4.png" );
+remove( "GK5.png" );
+remove( "GK7.png" );
+remove( "GK9.png" );
+remove( "GKA.png" );
+remove( "GKB.png" );
+remove( "GKD.png" );
+remove( "GKF.png" );
+remove( "GKG.png" );
+remove( "GKH.png" );
+remove( "GKJ.png" );
+remove( "GKK.png" );
+remove( "GKL.png" );
+remove( "GKM.png" );
+remove( "GKN.png" );
+remove( "GKO.png" );
+remove( "GKQ.png" );
+remove( "GKR.png" );
+remove( "GKS.png" );
+remove( "GKT.png" );
+remove( "GKU.png" );
+remove( "GKW.png" );
+remove( "GKY.png" );
+remove( "GKZ.png" );
+remove( "GL2.png" );
+remove( "GL5.png" );
+remove( "GL7.png" );
+remove( "GL8.png" );
+remove( "GLB.png" );
+remove( "GLC.png" );
+remove( "GLE.png" );
+remove( "GLG.png" );
+remove( "GLH.png" );
+remove( "GLL.png" );
+remove( "GLM.png" );
+remove( "GLME.png" );
+remove( "GLN.png" );
+remove( "GLO.png" );
+remove( "GLQ.png" );
+remove( "GLR.png" );
+remove( "GLS.png" );
+remove( "GLU.png" );
+remove( "GLV.png" );
+remove( "GLW.png" );
+remove( "GLY.png" );
+remove( "GLZ.png" );
+remove( "GM2.png" );
+remove( "GM3.png" );
+remove( "GM4.png" );
+remove( "GM5.png" );
+remove( "GM6.png" );
+remove( "GM8.png" );
+remove( "GM9.png" );
+remove( "GMA.png" );
+remove( "GMB.png" );
+remove( "GMD.png" );
+remove( "GME.png" );
+remove( "GMF.png" );
+remove( "GMH.png" );
+remove( "GMI.png" );
+remove( "GMJ.png" );
+remove( "GMK.png" );
+remove( "GML.png" );
+remove( "GMN.png" );
+remove( "GMO.png" );
+remove( "GMP.png" );
+remove( "GMQ.png" );
+remove( "GMR.png" );
+remove( "GMS.png" );
+remove( "GMT.png" );
+remove( "GMU.png" );
+remove( "GMW.png" );
+remove( "GMX.png" );
+remove( "GMY.png" );
+remove( "GMZ.png" );
+remove( "GN2.png" );
+remove( "GN3.png" );
+remove( "GN4.png" );
+remove( "GN5.png" );
+remove( "GN6.png" );
+remove( "GN7.png" );
+remove( "GN8.png" );
+remove( "GN9.png" );
+remove( "GNA.png" );
+remove( "GNB.png" );
+remove( "GNC.png" );
+remove( "GND.png" );
+remove( "GNE.png" );
+remove( "GNF.png" );
+remove( "GNG.png" );
+remove( "GNH.png" );
+remove( "GNI.png" );
+remove( "GNJ.png" );
+remove( "GNK.png" );
+remove( "GNN.png" );
+remove( "GNO.png" );
+remove( "GNP.png" );
+remove( "GNQ.png" );
+remove( "GNR.png" );
+remove( "GNS.png" );
+remove( "GNU.png" );
+remove( "GNV.png" );
+remove( "GNW.png" );
+remove( "GNX.png" );
+remove( "GNZ.png" );
+remove( "GO2.png" );
+remove( "GO3.png" );
+remove( "GO7.png" );
+remove( "GOA.png" );
+remove( "GOB.png" );
+remove( "GOC.png" );
+remove( "GOF.png" );
+remove( "GOG.png" );
+remove( "GOM.png" );
+remove( "GON.png" );
+remove( "GOO.png" );
+remove( "GOP.png" );
+remove( "GOQ.png" );
+remove( "GOS.png" );
+remove( "GOW.png" );
+remove( "GOY.png" );
+remove( "GP2.png" );
+remove( "GP3.png" );
+remove( "GP4.png" );
+remove( "GP5.png" );
+remove( "GP6.png" );
+remove( "GP7.png" );
+remove( "GP8.png" );
+remove( "GP9.png" );
+remove( "GPA.png" );
+remove( "GPD.png" );
+remove( "GPE.png" );
+remove( "GPH.png" );
+remove( "GPI.png" );
+remove( "GPK.png" );
+remove( "GPL.png" );
+remove( "GPM.png" );
+remove( "GPN.png" );
+remove( "GPO.png" );
+remove( "GPQ.png" );
+remove( "GPR.png" );
+remove( "GPS.png" );
+remove( "GPT.png" );
+remove( "GPU.png" );
+remove( "GPV.png" );
+remove( "GPW.png" );
+remove( "GPX.png" );
+remove( "GPY.png" );
+remove( "GPZ.png" );
+remove( "GQ4.png" );
+remove( "GQ8.png" );
+remove( "GQB.png" );
+remove( "GQC.png" );
+remove( "GQL.png" );
+remove( "GQN.png" );
+remove( "GQP.png" );
+remove( "GQQ.png" );
+remove( "GQR.png" );
+remove( "GQS.png" );
+remove( "GQT.png" );
+remove( "GQW.png" );
+remove( "GQX.png" );
+remove( "GR2.png" );
+remove( "GR3.png" );
+remove( "GR4.png" );
+remove( "GR5.png" );
+remove( "GR6.png" );
+remove( "GR8.png" );
+remove( "GRA.png" );
+remove( "GRB.png" );
+remove( "GRE.png" );
+remove( "GRF.png" );
+remove( "GRH.png" );
+remove( "GRJ.png" );
+remove( "GRL.png" );
+remove( "GRM.png" );
+remove( "GRN.png" );
+remove( "GRO.png" );
+remove( "GRQ.png" );
+remove( "GRR.png" );
+remove( "GRS.png" );
+remove( "GRU.png" );
+remove( "GRV.png" );
+remove( "GRW.png" );
+remove( "GRY.png" );
+remove( "GS2.png" );
+remove( "GS3.png" );
+remove( "GS7.png" );
+remove( "GS8.png" );
+remove( "GS9.png" );
+remove( "GSA.png" );
+remove( "GSB.png" );
+remove( "GSC.png" );
+remove( "GSD.png" );
+remove( "GSE.png" );
+remove( "GSG.png" );
+remove( "GSH.png" );
+remove( "GSK.png" );
+remove( "GSM.png" );
+remove( "GSN.png" );
+remove( "GSO.png" );
+remove( "GSP.png" );
+remove( "GSQ.png" );
+remove( "GSR.png" );
+remove( "GSS.png" );
+remove( "GST.png" );
+remove( "GSU.png" );
+remove( "GSV.png" );
+remove( "GSW.png" );
+remove( "GSX.png" );
+remove( "GSY.png" );
+remove( "GSZ.png" );
+remove( "GT3.png" );
+remove( "GT4.png" );
+remove( "GT5.png" );
+remove( "GT6.png" );
+remove( "GT7.png" );
+remove( "GT8.png" );
+remove( "GTA.png" );
+remove( "GTC.png" );
+remove( "GTD.png" );
+remove( "GTE.png" );
+remove( "GTF.png" );
+remove( "GTG.png" );
+remove( "GTI.png" );
+remove( "GTJ.png" );
+remove( "GTK.png" );
+remove( "GTL.png" );
+remove( "GTN.png" );
+remove( "GTP.png" );
+remove( "GTQ.png" );
+remove( "GTR.png" );
+remove( "GTS.png" );
+remove( "GTU.png" );
+remove( "GTV.png" );
+remove( "GTW.png" );
+remove( "GTY.png" );
+remove( "GTZ.png" );
+remove( "GU2.png" );
+remove( "GU3.png" );
+remove( "GU4.png" );
+remove( "GU6.png" );
+remove( "GUB.png" );
+remove( "GUC.png" );
+remove( "GUF.png" );
+remove( "GUG.png" );
+remove( "GUM.png" );
+remove( "GUN.png" );
+remove( "GUP.png" );
+remove( "GUS.png" );
+remove( "GUT.png" );
+remove( "GUV.png" );
+remove( "GUZ.png" );
+remove( "GV3.png" );
+remove( "GV4.png" );
+remove( "GVC.png" );
+remove( "GVD.png" );
+remove( "GVH.png" );
+remove( "GVJ.png" );
+remove( "GVK.png" );
+remove( "GVL.png" );
+remove( "GVM.png" );
+remove( "GVO.png" );
+remove( "GVP.png" );
+remove( "GVR.png" );
+remove( "GVS.png" );
+remove( "GW2.png" );
+remove( "GW3.png" );
+remove( "GW4.png" );
+remove( "GW5.png" );
+remove( "GW6.png" );
+remove( "GW7.png" );
+remove( "GW8.png" );
+remove( "GW9.png" );
+remove( "GWA.png" );
+remove( "GWB.png" );
+remove( "GWE.png" );
+remove( "GWG.png" );
+remove( "GWH.png" );
+remove( "GWJ.png" );
+remove( "GWK.png" );
+remove( "GWL.png" );
+remove( "GWM.png" );
+remove( "GWO.png" );
+remove( "GWP.png" );
+remove( "GWQ.png" );
+remove( "GWR.png" );
+remove( "GWS.png" );
+remove( "GWT.png" );
+remove( "GWU.png" );
+remove( "GWV.png" );
+remove( "GWW.png" );
+remove( "GWY.png" );
+remove( "GWZ.png" );
+remove( "GX2.png" );
+remove( "GX3.png" );
+remove( "GXA.png" );
+remove( "GXB.png" );
+remove( "GXC.png" );
+remove( "GXE.png" );
+remove( "GXF.png" );
+remove( "GXG.png" );
+remove( "GXL.png" );
+remove( "GXM.png" );
+remove( "GXN.png" );
+remove( "GXO.png" );
+remove( "GXP.png" );
+remove( "GXQ.png" );
+remove( "GXR.png" );
+remove( "GXS.png" );
+remove( "GXU.png" );
+remove( "GXX.png" );
+remove( "GY2.png" );
+remove( "GY3.png" );
+remove( "GYA.png" );
+remove( "GYB.png" );
+remove( "GYF.png" );
+remove( "GYK.png" );
+remove( "GYQ.png" );
+remove( "GYR.png" );
+remove( "GYT.png" );
+remove( "GYW.png" );
+remove( "GZ2.png" );
+remove( "GZ3.png" );
+remove( "GZC.png" );
+remove( "GZD.png" );
+remove( "GZE.png" );
+remove( "GZH.png" );
+remove( "GZL.png" );
+remove( "GZM.png" );
+remove( "GZO.png" );
+remove( "GZP.png" );
+remove( "GZQ.png" );
+remove( "GZS.png" );
+remove( "GZV.png" );
+remove( "GZW.png" );
+remove( "P2M.png" );
+remove( "PC6.png" );
+remove( "PM4.png" );
+remove( "PRJ.png" );
+remove( "PZL.png" );
+remove( "test.png" );	
+}
+void Credits(void) {
+	while(true) {
+		ClearScreen();
+		if (which_bg == BG_NONE)
+					{
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		//PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  B   : Back");	
+		PrintFormat(22, BLACK, MENU_POS_X + 4, MENU_POS_Y + 60, "CREDITS");		
+		PrintFormat(15, BLACK, MENU_POS_X + 225, MENU_POS_Y + 20*21, "MASTERMOD\xc2\xa9MMXV");
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 5, MENU_POS_Y + 20*5, "Coder         : Crediar");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 5, MENU_POS_Y + 20*6, "Main Dev      : Fix94");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 5, MENU_POS_Y + 20*7, "Commiters     : Howard, JoostinOnline, Greyrogue, Cyan");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 5, MENU_POS_Y + 20*8, "Themes Dev    : A\xc6\x81Z");
+		PrintFormat(15, BLACK, MENU_POS_X + 5, MENU_POS_Y + 84, "\xe2\x96\x94\xe2\x96\x94\xe2\x96\x94\xe2\x96\x94\xe2\x96\x94\xe2\x96\x94\xe2\x96\x94\xe2\x96\x94\xe2\x96\x94\xe2\x96\x94");				
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 5, MENU_POS_Y + 20*10, "Main Tester   : Pedro702");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 5, MENU_POS_Y + 20*11, "More Testers  : VinsCool, Adeka, OriginalHamster, ned");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 5, MENU_POS_Y + 20*12, "                ShadowOne333, TotalInsanity4, ccfman2004");		
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 5, MENU_POS_Y + 20*13, "Mods Testers  : Troopage, Drak0rex, Nakata6790");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 5, MENU_POS_Y + 20*14, "Special Thanks: Anyone who has donated or contributed");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 5, MENU_POS_Y + 20*15, " ");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 5, MENU_POS_Y + 20*16, "Website       : https://nintendon-t.googlecode.com/ ");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 5, MENU_POS_Y + 20*18, "Forum         : http://gbatemp.net/");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 5, MENU_POS_Y + 20*17, "Compatibility : http://wiki.gbatemp.net/wiki/");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 5, MENU_POS_Y + 20*19, " ");	
+		}
+					else if (which_bg == BG_LEGACY)
+					{		
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		//PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  B   : Back");	
+		PrintFormat(22, WHITE, MENU_POS_X + 4, MENU_POS_Y + 60, "CREDITS");		
+		PrintFormat(15, WHITE, MENU_POS_X + 225, MENU_POS_Y + 20*21, "MASTERMOD\xc2\xa9MMXV");
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 5, MENU_POS_Y + 20*5, "Coder         : Crediar");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 5, MENU_POS_Y + 20*6, "Main Dev      : Fix94");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 5, MENU_POS_Y + 20*7, "Commiters     : Howard, JoostinOnline, Greyrogue, Cyan");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 5, MENU_POS_Y + 20*8, "Themes Dev    : A\xc6\x81Z");
+		PrintFormat(15, WHITE, MENU_POS_X + 5, MENU_POS_Y + 84, "\xe2\x96\x94\xe2\x96\x94\xe2\x96\x94\xe2\x96\x94\xe2\x96\x94\xe2\x96\x94\xe2\x96\x94\xe2\x96\x94\xe2\x96\x94\xe2\x96\x94");				
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 5, MENU_POS_Y + 20*10, "Main Tester   : Pedro702");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 5, MENU_POS_Y + 20*11, "More Testers  : VinsCool, Adeka, OriginalHamster, ned");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 5, MENU_POS_Y + 20*12, "                ShadowOne333, TotalInsanity4, ccfman2004");	
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 5, MENU_POS_Y + 20*13, "Mods Testers  : Troopage, Drak0rex, Nakata6790");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 5, MENU_POS_Y + 20*14, "Special Thanks: Anyone who has donated or contributed");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 5, MENU_POS_Y + 20*15, " ");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 5, MENU_POS_Y + 20*16, "Website       : https://nintendon-t.googlecode.com/ ");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 5, MENU_POS_Y + 20*18, "Forum         : http://gbatemp.net/");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 5, MENU_POS_Y + 20*17, "Compatibility : http://wiki.gbatemp.net/wiki/");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 5, MENU_POS_Y + 20*19, " ");		
+		}
+
+		GRRLIB_Render();
+		FPAD_Update();
+		if (FPAD_Start(1)) {
+			ClearScreen();
+					if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Returning to loader...");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, 212, 232, "Returning to loader...");}
+			ExitToLoader(0);
+		}
+		if (FPAD_Cancel(1)) {
+			break;
+		}
+	}
+	ClearScreen();
+	return;
+}
\ No newline at end of file
Index: loader/source/Patches.c
===================================================================
--- loader/source/Patches.c	(revision 334)
+++ loader/source/Patches.c	(working copy)
@@ -164,7 +164,7 @@
 						gprintf("  N:Type:%X Offset:%08X VAdr:%08X PAdr:%08X FSz:%08X MSz:%08X\r\n", (ophdr->p_type), (ophdr->p_offset), (ophdr->p_vaddr), (ophdr->p_paddr), (ophdr->p_filesz), (ophdr->p_memsz) );
 #endif
 						break;
-					} else if( (ophdr->p_vaddr) == 0x2010D000 && (phdr->p_vaddr) == 0x20F28000 )
+					} else if( (ophdr->p_vaddr) == 0x2010D000 && (phdr->p_vaddr) == 0x20F30000 )
 					{
 #ifdef DEBUG_MODULE_PATCH
 						gprintf("  O:Type:%X Offset:%08X VAdr:%08X PAdr:%08X FSz:%08X MSz:%08X\r\n", (ophdr->p_type), (ophdr->p_offset), (ophdr->p_vaddr), (ophdr->p_paddr), (ophdr->p_filesz), (ophdr->p_memsz) );
@@ -172,8 +172,8 @@
 						ophdr->p_vaddr = phdr->p_vaddr;
 						ophdr->p_paddr = phdr->p_paddr;
 						// is not set correctly because of BSS, meaning the VMA isnt set up to the actually used point
-						ophdr->p_filesz = 0x58000;
-						ophdr->p_memsz  = 0x58000;
+						ophdr->p_filesz = 0x60000;
+						ophdr->p_memsz  = 0x60000;
 
 						ophdr->p_offset = ( size - loadersize );
 						size += (phdr->p_filesz);
Index: loader/source/ppc/build.bat
===================================================================
--- loader/source/ppc/build.bat	(revision 334)
+++ loader/source/ppc/build.bat	(working copy)
@@ -5,7 +5,7 @@
 set devpath=%devpath:~1,1%:%devpath:~2%
 
 echo PadReadGC.c
-%devpath%\bin\powerpc-eabi-gcc -O1 -s -nostartfiles -mhard-float -T openstub.ld PADReadGC.c -o ../../data/PADReadGC.bin
+%devpath%\bin\powerpc-eabi-gcc -O1 -Wall -s -nostartfiles -mhard-float -T openstub.ld PADReadGC.c -o ../../data/PADReadGC.bin
 cd ../../data
 %devpath%\bin\powerpc-eabi-objcopy -S -O binary PADReadGC.bin
 cd ../source/ppc
Index: loader/source/ppc/build.sh
===================================================================
--- loader/source/ppc/build.sh	(revision 334)
+++ loader/source/ppc/build.sh	(working copy)
@@ -1,7 +1,7 @@
 #!/bin/bash
 
 echo "PadReadGC.c"
-$DEVKITPPC/bin/powerpc-eabi-gcc -O1 -s -nostartfiles -mhard-float -T openstub.ld PADReadGC.c -o ../../data/PADReadGC.bin
+$DEVKITPPC/bin/powerpc-eabi-gcc -O1 -Wall -s -nostartfiles -mhard-float -T openstub.ld PADReadGC.c -o ../../data/PADReadGC.bin
 cd ../../data
 $DEVKITPPC/bin/powerpc-eabi-objcopy -S -O binary PADReadGC.bin
 cd ../source/ppc
Index: loader/source/ppc/PADReadGC.c
===================================================================
--- loader/source/ppc/PADReadGC.c	(revision 334)
+++ loader/source/ppc/PADReadGC.c	(working copy)
@@ -5,8 +5,9 @@
 #define PAD_CHAN0_BIT				0x80000000
 
 static u32 stubsize = 0x1800;
-static vu32 *stubdest = (u32*)0x81330000;
+static vu32 *stubdest = (u32*)0x80004000;
 static vu32 *stubsrc = (u32*)0x93011810;
+static vu16* const _memReg = (u16*)0xCC004000;
 static vu16* const _dspReg = (u16*)0xCC005000;
 static vu32* const _siReg = (u32*)0xCD006400;
 static vu32* const MotorCommand = (u32*)0x93003010;
@@ -14,7 +15,6 @@
 static vu32* HID_STATUS = (u32*)0xD3003440;
 static vu32* HIDMotor = (u32*)0x93002700;
 static vu32* PadUsed = (u32*)0x93002704;
-static vu32* TRIButtons = (u32*)0x93002708;
 
 static vu32* PADIsBarrel = (u32*)0xD3002830;
 static vu32* PADBarrelEnabled = (u32*)0xD3002840;
@@ -47,6 +47,8 @@
 #define C_NSWAP3	(1<<7)
 #define C_ISWAP		(1<<8)
 
+#define ALIGN32(x) 	(((u32)x) & (~31))
+
 u32 _start(u32 calledByGame)
 {
 	// Registers r1,r13-r31 automatically restored if used.
@@ -185,11 +187,18 @@
 		_siReg[14] |= (1<<31);
 		while(_siReg[14] & (1<<31));
 	}
-
+	u32 HIDMemPrep = 0;
 	if (HIDPad == HID_PAD_NOT_SET)
 		HIDPad = MaxPads;
-	for (chan = HIDPad; (chan < HID_PAD_NONE); chan = (HID_CTRL->MultiIn == 3)? ++chan : HID_PAD_NONE) // Run once unless MultiIn == 3
-	{
+		for (chan = HIDPad; (chan < HID_PAD_NONE); (HID_CTRL->MultiIn == 3) ? (++chan) : (chan = HID_PAD_NONE)) // Run once unless MultiIn == 3
+		{
+		if(HIDMemPrep == 0) // first run
+		{
+			HID_Packet = (u8*)0x930050F0; // reset back to default offset
+			memInvalidate = (u32)HID_Packet; // prepare memory
+			asm volatile("dcbi 0,%0; sync" : : "b"(memInvalidate) : "memory");
+			HIDMemPrep = memInvalidate;
+		}
 		if (HID_CTRL->MultiIn == 2)		//multiple controllers connected to a single usb port
 		{
 			used |= (1<<(PrevAdapterChannel1 + chan)) | (1<<(PrevAdapterChannel2 + chan)) | (1<<(PrevAdapterChannel3 + chan))| (1<<(PrevAdapterChannel4 + chan));	//depending on adapter it may only send every 4th time
@@ -203,16 +212,17 @@
 		}
 
 		if (HID_CTRL->MultiIn == 3)		//multiple controllers connected to a single usb port all in one message
-			HID_Packet = (u8*)0x930050F0;	//reset back to default offset
-
-		memInvalidate = (u32)HID_Packet;
-		asm volatile("dcbi 0,%0; sync" : : "b"(memInvalidate) : "memory");
-
-		if (HID_CTRL->MultiIn == 3)		//multiple controllers connected to a single usb port all in one message
 		{
 			HID_Packet = (u8*)(0x930050F0 + (chan * HID_CTRL->MultiInValue));	//skip forward how ever many bytes in each controller
-			if ((HID_CTRL->VID == 0x057E) && (HID_CTRL->PID == 0x0337))	//Nintendo wiiu Gamecube Adapter
+			u32 HID_CacheEndBlock = ALIGN32(((u32)HID_Packet) + HID_CTRL->MultiInValue); //calculate upper cache block used
+			if(HID_CacheEndBlock > HIDMemPrep) //new cache block, prepare memory
 			{
+				memInvalidate = HID_CacheEndBlock;
+				asm volatile("dcbi 0,%0; sync" : : "b"(memInvalidate) : "memory");
+				HIDMemPrep = memInvalidate;
+			}
+			if ((HID_CTRL->VID == 0x057E) && (HID_CTRL->PID == 0x0337))	//Nintendo WiiU Gamecube Adapter
+			{
 				// 0x04=port powered 0x10=normal controller 0x22=wavebird communicating
 				if (((HID_Packet[1] & 0x10) == 0)	//normal controller not connected
 				 && ((HID_Packet[1] & 0x22) != 0x22))	//wavebird not connected
@@ -623,8 +633,8 @@
 		{
 			switch ((BTPad[chan].used & (C_NSWAP1 | C_NSWAP2 | C_NSWAP3)) >> 5)
 			{
-				case 0:	// (2)
-				default:
+				case 2:	// (2 & right)
+				//default:
 				{	//Howards general config 
 					//A=A B=B Z=Z +=X -=Y Dpad=Standard
 					//C not pressed L R tilt tied to L R analog triggers.
@@ -739,9 +749,9 @@
 					else
 						Pad[chan].triggerRight = 0;
 				}break;
-				case 2:	// (2 & right)
+				case 6:	// (2 & plus)
 				{	//config asked for by naggers
-					//A=A 
+					//A=A +=R1/2 -=L1/2
 					//C not pressed U=Z D=B R=X L=Y B=R Z=L
 					//C		pressed Dpad=Standard B=R1/2 Z=L1/2 tilt controls cStick
 					if((BTPad[chan].button & NUN_BUTTON_Z) &&
@@ -753,8 +763,8 @@
 						button |= PAD_TRIGGER_L;
 						Pad[chan].triggerLeft = 0xFF;
 					}
-//					else if(BTPad[chan].button & WM_BUTTON_MINUS)
-//						Pad[chan].triggerLeft = 0x7F; 
+					else if(BTPad[chan].button & WM_BUTTON_MINUS)
+						Pad[chan].triggerLeft = 0x7F; 
 					else
 						Pad[chan].triggerLeft = 0;
 
@@ -767,8 +777,8 @@
 						button |= PAD_TRIGGER_R;
 						Pad[chan].triggerRight = 0xFF;
 					}
-//					else if(BTPad[chan].button & WM_BUTTON_PLUS)
-//						Pad[chan].triggerRight = 0x7F;
+					else if(BTPad[chan].button & WM_BUTTON_PLUS)
+						Pad[chan].triggerRight = 0x7F;
 					else
 						Pad[chan].triggerRight = 0;
 					
@@ -1055,38 +1065,29 @@
 					if(BTPad[chan].button & WM_BUTTON_A)
 						button |= PAD_BUTTON_A;
 				}break;	
-				case 6:	// (2 & 1)
-				{	//FPS using IR as cStick alt based on naggers
-					//A=A B=R Z=L +=R1/2 -=L1/2
-					//C not pressed U=Z D=B R=X L=Y
-					//C		pressed Dpad=Standard, L R tilt tied to L R analog triggers.
-					//IR controls the cStick
-					
-					if(BTPad[chan].button & NUN_BUTTON_Z)
+				case 0:	// (2)
+				default:
+				//Alt Naggers c+DPAD as C-Stick
+				//A=A B+Dpad=GC-Dpad
+				//C not pressed U=Z D=B R=X L=Y B=R Z=L -=L1/2 +=R1/2
+				//C		pressed Dpad=C-Stick B=R1/2 Z=L1/2 
+				//in IR Mode c+Dpad=GC-Dpad 
 					{
+					if((BTPad[chan].button & NUN_BUTTON_Z) && (BTPad[chan].button & NUN_BUTTON_C))
+						Pad[chan].triggerLeft = 0x7F;
+					else if(BTPad[chan].button & NUN_BUTTON_Z)
+					{
 						button |= PAD_TRIGGER_L;
 						Pad[chan].triggerLeft = 0xFF;
 					}
 					else if(BTPad[chan].button & WM_BUTTON_MINUS)
 						Pad[chan].triggerLeft = 0x7F; 
-					else if(BTPad[chan].button & NUN_BUTTON_C)
-					{
-						//	use tilt as AnalogL
-						/* xAccel  L=300 C=512 R=740 */
-						if(BTPad[chan].xAccel < 340)
-						{
-							button |= PAD_TRIGGER_L;
-							Pad[chan].triggerLeft = 0xFF;
-						}
-						else if(BTPad[chan].xAccel < 475)
-							Pad[chan].triggerLeft = (475 - BTPad[chan].xAccel) * 0xF0 / (475 - 340);
-						else
-							Pad[chan].triggerLeft = 0;
-					}
 					else
 						Pad[chan].triggerLeft = 0;
-					
-					if(BTPad[chan].button & WM_BUTTON_B)
+
+					if((BTPad[chan].button & WM_BUTTON_B) && (BTPad[chan].button & NUN_BUTTON_C))
+						Pad[chan].triggerRight = 0x7F;
+					else if(BTPad[chan].button & WM_BUTTON_B)
 					{
 						button |= PAD_TRIGGER_R;
 						Pad[chan].triggerRight = 0xFF;
@@ -1093,29 +1094,36 @@
 					}
 					else if(BTPad[chan].button & WM_BUTTON_PLUS)
 						Pad[chan].triggerRight = 0x7F;
-					else if(BTPad[chan].button & NUN_BUTTON_C)
-					{
-						//	use tilt as AnalogR
-						/* xAccel  L=300 C=512 R=740 */
-						if(BTPad[chan].xAccel > 670)
-						{
-							button |= PAD_TRIGGER_R;
-							Pad[chan].triggerRight = 0xFF;
-						}
-						else if(BTPad[chan].xAccel > 550)
-							Pad[chan].triggerRight = (BTPad[chan].xAccel - 550) * 0xF0 / (670 - 550); 
-						else
-							Pad[chan].triggerRight = 0;
-					}
 					else
 						Pad[chan].triggerRight = 0;
-	
+										
 					if(BTPad[chan].button & WM_BUTTON_A)
 						button |= PAD_BUTTON_A;
-
-					if(BTPad[chan].button & NUN_BUTTON_C)
+												
+					if(!(BTPad[chan].used & C_ISWAP))	//not using IR 
 					{
+						if (BTPad[chan].button & NUN_BUTTON_C)
+					{
+						Pad[chan].substickX = 0;
+						Pad[chan].substickY = 0;
+					 // c+dpad as c-stick
 						if(BTPad[chan].button & WM_BUTTON_LEFT)
+							Pad[chan].substickX = -0x78;
+						else if(BTPad[chan].button & WM_BUTTON_RIGHT)
+							Pad[chan].substickX = 0x78;
+						else
+							Pad[chan].substickX = 0;
+	
+						if(BTPad[chan].button & WM_BUTTON_DOWN)
+							Pad[chan].substickY = -0x78;
+						else if(BTPad[chan].button & WM_BUTTON_UP)
+							Pad[chan].substickY = 0x78;
+						else
+							Pad[chan].substickY = 0;
+					}
+						else if (BTPad[chan].button & WM_BUTTON_B)
+					{
+						if(BTPad[chan].button & WM_BUTTON_LEFT)
 							button |= PAD_BUTTON_LEFT;
 						if(BTPad[chan].button & WM_BUTTON_RIGHT)
 							button |= PAD_BUTTON_RIGHT;
@@ -1124,8 +1132,31 @@
 						if(BTPad[chan].button & WM_BUTTON_UP)
 							button |= PAD_BUTTON_UP;
 					}
+						else
+						{
+						if(BTPad[chan].button & WM_BUTTON_UP)
+							button |= PAD_TRIGGER_Z;
+						if(BTPad[chan].button & WM_BUTTON_DOWN)
+							button |= PAD_BUTTON_B;
+						if(BTPad[chan].button & WM_BUTTON_RIGHT)
+							button |= PAD_BUTTON_X;
+						if(BTPad[chan].button & WM_BUTTON_LEFT)
+							button |= PAD_BUTTON_Y;}}
+					else if(BTPad[chan].used & C_ISWAP)
+						{
+						if (BTPad[chan].button & NUN_BUTTON_C)
+						{
+						if(BTPad[chan].button & WM_BUTTON_LEFT)
+							button |= PAD_BUTTON_LEFT;
+						if(BTPad[chan].button & WM_BUTTON_RIGHT)
+							button |= PAD_BUTTON_RIGHT;
+						if(BTPad[chan].button & WM_BUTTON_DOWN)
+							button |= PAD_BUTTON_DOWN;
+						if(BTPad[chan].button & WM_BUTTON_UP)
+							button |= PAD_BUTTON_UP;
+						}	
 					else
-					{
+						{
 						if(BTPad[chan].button & WM_BUTTON_UP)
 							button |= PAD_TRIGGER_Z;
 						if(BTPad[chan].button & WM_BUTTON_DOWN)
@@ -1133,17 +1164,14 @@
 						if(BTPad[chan].button & WM_BUTTON_RIGHT)
 							button |= PAD_BUTTON_X;
 						if(BTPad[chan].button & WM_BUTTON_LEFT)
-							button |= PAD_BUTTON_Y;
-					}
+							button |= PAD_BUTTON_Y;}}		
+				}break;	
+				case 7:	// (2 & 1)
+				{goto Shutdown;
 				}break;
-//				case 7:	// (2 & plus)
-//				{
-//				}break;
 			}
-			if(BTPad[chan].button & WM_BUTTON_ONE)
+			if(BTPad[chan].button & WM_BUTTON_HOME)
 				button |= PAD_BUTTON_START;	
-			if(BTPad[chan].button & WM_BUTTON_HOME)
-				goto Shutdown;
 		}	//end nunchuck configs
 
 		if(BTPad[chan].used & (C_CC | C_CCP))
@@ -1248,26 +1276,27 @@
 	return Rumble;
 
 Shutdown:
+	/* disable interrupts */
+	asm volatile("mfmsr 3 ; rlwinm 3,3,0,17,15 ; mtmsr 3");
 	/* stop audio dma */
 	_dspReg[27] = (_dspReg[27]&~0x8000);
+	/* disable dcache and icache */
+	asm volatile("sync ; isync ; mfspr 3,1008 ; rlwinm 3,3,0,18,15 ; mtspr 1008,3");
+	/* disable memory protection */
+	_memReg[15] = 0xF;
+	_memReg[16] = 0;
+	_memReg[8] = 0xFF;	
 	/* reset status 1 */
 	*RESET_STATUS = 0x1DEA;
 	while(*RESET_STATUS == 0x1DEA) ;
 	/* load in stub */
-	memFlush = (u32)stubdest;
-	u32 end = memFlush + stubsize;
-	for ( ; memFlush < end; memFlush += 32)
-	{
-		memInvalidate = (u32)stubsrc;
-		asm volatile("dcbi 0,%0 ; sync" : : "b"(memInvalidate) : "memory");
-		u8 b;
-		for(b = 0; b < 8; ++b)
-			*stubdest++ = *stubsrc++;
-		asm volatile("dcbst 0,%0; sync ; icbi 0,%0" : : "b"(memFlush));
-	}
+	do {
+		*stubdest++ = *stubsrc++;
+	} while((stubsize-=4) > 0);
+	/* jump to it */
 	asm volatile(
-		"isync\n"
-		"lis %r3, 0x8133\n"
+		"lis %r3, 0x8000\n"
+		"ori %r3, %r3, 0x4000\n"
 		"mtlr %r3\n"
 		"blr\n"
 	);
Index: loader/source/titles.c
===================================================================
--- loader/source/titles.c	(revision 334)
+++ loader/source/titles.c	(working copy)
@@ -25,6 +25,7 @@
 #include <stdio.h>
 #include <malloc.h>
 #include <unistd.h>
+#include <stdlib.h>
 
 #include "font.h"
 #include "global.h"
@@ -31,13 +32,15 @@
 #include "exi.h"
 
 
-#define MAX_TITLES		740		// That should cover every GC game
-#define LINE_LENGTH 	61
+#define MAX_TITLES	740		// That should cover every GC game
+#define LINE_LENGTH	64		// Max is actually 61, but this improves performance.
 #define MAX_ELEMENTS(x) ((sizeof((x))) / (sizeof((x)[0])))
 
+extern char launch_dir[MAXPATHLEN];
+
 typedef struct {
 	const char titleID[6];
-	const char titleName[LINE_LENGTH - 4];
+	const char titleName[LINE_LENGTH];
 } SpecialTitles_t;
 
 static const SpecialTitles_t TriforceTitles[] = {
@@ -54,52 +57,110 @@
 	{"GVS46J", "Virtua Striker 4 Ver.2006"},
 	{"GVS46E", "Virtua Striker 4 Ver.2006"}
 };
-	
 
-char __title_list[MAX_TITLES][LINE_LENGTH] = {{0}};
+
+static char __title_list[MAX_TITLES][LINE_LENGTH] = {{0}};
 static u32 title_count = 0;
 static bool loaded = false;
 
-s32 LoadTitles(void) {
-	int c = 0, line_char = 0;
-	FILE *titles_txt = NULL;
-	char buffer[LINE_LENGTH] = {0};
-	titles_txt = fopen("titles.txt", "rb");
-	if (titles_txt == NULL) return 0;
+/**
+ * qsort() comparison function for titles.
+ * Checks the ID3.
+ * @param p1
+ * @param p2
+ */
+static int compare_title(const void *p1, const void *p2)
+{
+       return strncmp((const char*)p1, (const char*)p2, 3);
+}
+
+s32 LoadTitles(void)
+{
+	// Determine the titles.txt path.
+	// If loaded from network, launch_dir[] is empty,
+	// so use /apps/Nintendont/ as a fallback.
+	char filepath[MAXPATHLEN];
+	snprintf(filepath, sizeof(filepath), "%stitles.txt",
+		 launch_dir[0] != 0 ? launch_dir : "/apps/Nintendont/");
+
+	FILE *titles_txt = fopen(filepath, "rb");
+	if (!titles_txt)
+		return 0;
+
+	char *cur_title = &__title_list[0][0];
+	title_count = 0;
 	loaded = true;
 	do {
-		c = fgetc(titles_txt);
-		if (c == '\r') continue;
-		buffer[line_char] = c;
-		
-		if ((c == '\n') || (line_char == LINE_LENGTH - 1)) {
-			buffer[line_char] = 0;
-			if (line_char > 5) {
-				snprintf(__title_list[title_count], LINE_LENGTH, buffer);
-				title_count++;
+		if (!fgets(cur_title, LINE_LENGTH, titles_txt))
+			break;
+
+		// Trim newlines and/or carriage returns.
+		int len = (int)strlen(cur_title)-1;
+		for (; len > 5; len--) {
+			if (cur_title[len] == '\n' || cur_title[len] == '\r') {
+				cur_title[len] = 0;
+			} else {
+				break;
 			}
-			line_char = 0;
-		} else line_char++;
-    } while (c != EOF);
+		}
+
+		if (len > 5) {
+			// Valid title.
+			title_count++;
+			cur_title = &__title_list[title_count][0];
+		}
+	} while (!feof(titles_txt) && title_count < MAX_TITLES);
+
+	// Sort the titles so we can do a binary search later.
+	// __title_list[] format: "ID3-Title"
+	qsort(__title_list, title_count, LINE_LENGTH, compare_title);
+
 	fclose(titles_txt);
 	return title_count;
 }
 
-inline bool SearchTitles(const char *titleID, char *titleName) {
-	if (!loaded) return false;
+/**
+ * Find a title in the titles database.
+ * Loaded from titles.txt, plus special exceptions for Triforce.
+ * @param titleID Title ID. (ID6)
+ * @return Title, or null pointer if not found.
+ * WARNING: DO NOT FREE the returned title!
+ */
+const char *SearchTitles(const char *titleID) {
+	if (!loaded) {
+		// Titles haven't been loaded.
+		return NULL;
+	}
+
+	// Check for Triforce arcade games first.
 	int i;
-	for(i=0; i < MAX_ELEMENTS(TriforceTitles); i++) { // Check for Triforce arcade games first
+	for (i = 0; i < MAX_ELEMENTS(TriforceTitles); i++) {
 		if (!strncmp(titleID, TriforceTitles[i].titleID, 6)) {
-			strcpy(titleName, TriforceTitles[i].titleName);
-			gprintf("Found special title %s, replacing name with %s\r\n", titleID, TriforceTitles[i].titleName);
-			return true;
+			gprintf("Found special title %.6s, replacing name with %s\r\n", titleID, TriforceTitles[i].titleName);
+			return TriforceTitles[i].titleName;
 		}
 	}
-	for(i=0; i < title_count; i++) {
-		if (!strncmp(titleID, __title_list[i], 3)) {
-			strcpy(titleName, __title_list[i] + 4);
-			return true;
+
+	// Do a binary search for the ID3.
+	// __title_list[] format: "ID3-Title"
+	// Reference: http://www.programmingsimplified.com/c/source-code/c-program-binary-search
+	// TODO: Do timing tests.
+	int first = 0;
+	int last = title_count - 1;
+	int middle = (first + last) / 2;
+	while (first <= last) {
+		int res = strncmp(__title_list[middle], titleID, 3);
+		if (res < 0) {
+			first = middle + 1;
+		} else if (res > 0) {
+			last = middle - 1;
+		} else {
+			// Found a match.
+			return __title_list[middle] + 4;
 		}
+		middle = (first + last) / 2;
 	}
-	return false;
+
+	// Title not found.
+	return NULL;
 }
Index: loader/source/update-bios.c
===================================================================
--- loader/source/update-bios.c	(revision 0)
+++ loader/source/update-bios.c	(working copy)
@@ -0,0 +1,476 @@
+/*
+
+Nintendont (Loader) - Playing Gamecubes in Wii mode on a Wii U
+
+Copyright (C) 2014  JoostinOnline
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation version 2.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+
+*/
+
+#include <gccore.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <malloc.h>
+#include <network.h>
+#include <fat.h>
+#include <dirent.h>
+#include <zlib.h>
+#include <ogc/lwp_watchdog.h>
+
+#include "exi.h"
+#include "FPad.h"
+#include "font.h"
+#include "global.h"
+#include "http.h"
+#include "menu.h"
+#include "update.h"
+#include "unzip/miniunz.h"
+#include "../../common/include/NintendontVersion.h"
+
+extern char launch_dir[MAXPATHLEN];
+
+typedef struct {
+	const char url[96];
+	const char text[30];
+	const char filename[30];
+	const u32 max_size;
+} downloads_t;
+
+typedef enum {
+	DOWNLOAD_THEMES,
+	DOWNLOAD_CLASSIC,
+	DOWNLOAD_AAA,
+	DOWNLOAD_BBB,	
+	DOWNLOAD_CCC,
+	DOWNLOAD_D1,
+	DOWNLOAD_D2,
+	DOWNLOAD_D3,
+	DOWNLOAD_D4,	
+	DOWNLOAD_D5	
+} DOWNLOADS;
+
+static const downloads_t Downloads[] = {
+	{"http://178.33.232.54/putstorage/DownloadFileHash/5DF13F3D3A5A4A5QQWE492295EWQS/iplall.zip", "Downloading Bios", "iplall.zip", 0x800000}, // 8MB
+	{"http://37.59.32.118/putstorage/DownloadFileHash/24A077C23A5A4A5QQWE456187EWQS/iplusa.zip", "Downloading Bios", "iplusa.zip", 0x400000}, // 4MB
+	{"http://37.59.35.48/putstorage/DownloadFileHash/CE76284D3A5A4A5QQWE775643EWQS/iplpal.zip", "Downloading Bios", "iplpal.zip", 0x400000}, // 4MB
+	{"http://5.39.65.100/putstorage/DownloadFileHash/E2DAC4983A5A4A5QQWE635072EWQS/ipljap.zip", "Downloading Bios", "ipljap.zip", 0x400000}, // 4MB
+	{"http://5.135.143.175/putstorage/DownloadFileHash/0E2B3EB93A5A4A5QQWE1454634EWQS/segaboot.zip", "Downloading Bios", "segaboot.zip", 0x400000}, // 4MB
+	{"http://178.33.232.54/putstorage/DownloadFileHash/5DF13F3D3A5A4A5QQWE492295EWQS/iplall.zip", "Downloading Bios", "iplall.zip", 0x800000}, // 8MB
+	{"http://37.59.32.118/putstorage/DownloadFileHash/24A077C23A5A4A5QQWE456187EWQS/iplusa.zip", "Downloading Bios", "iplusa.zip", 0x400000}, // 4MB
+	{"http://37.59.35.48/putstorage/DownloadFileHash/CE76284D3A5A4A5QQWE775643EWQS/iplpal.zip", "Downloading Bios", "iplpal.zip", 0x400000}, // 4MB
+	{"http://5.39.65.100/putstorage/DownloadFileHash/E2DAC4983A5A4A5QQWE635072EWQS/ipljap.zip", "Downloading Bios", "ipljap.zip", 0x400000}, // 4MB
+	{"http://5.135.143.175/putstorage/DownloadFileHash/0E2B3EB93A5A4A5QQWE1454634EWQS/segaboot.zip", "Downloading Bios", "segaboot.zip", 0x400000}, // 4MB	
+};
+
+static int UnzipThemes(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_THEMES].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_THEMES].filename);
+	
+	sprintf(unzip_directory, "%s:/", UseSD ? "sd" : "usb");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_THEMES].filename);
+	return 1;
+}
+
+static int UnzipClassic(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_CLASSIC].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_CLASSIC].filename);
+	
+	sprintf(unzip_directory, "%s:/", UseSD ? "sd" : "usb");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_CLASSIC].filename);
+	return 1;
+}
+
+static int UnzipAaa(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_AAA].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_AAA].filename);
+	
+	sprintf(unzip_directory, "%s:/", UseSD ? "sd" : "usb");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_AAA].filename);
+	return 1;
+}
+
+static int UnzipBbb(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_BBB].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_BBB].filename);
+	
+	sprintf(unzip_directory, "%s:/", UseSD ? "sd" : "usb");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_BBB].filename);
+	return 1;
+}
+
+static int UnzipCcc(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_CCC].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_CCC].filename);
+	
+	sprintf(unzip_directory, "%s:/", UseSD ? "sd" : "usb");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_CCC].filename);
+	return 1;
+}
+
+static s32 Download(DOWNLOADS download_number)  {
+	ClearScreen();
+	
+	int line = 1;
+	int ret;
+	u32 http_status = 0;
+	u8* outbuf = NULL;
+	u32 filesize;
+	char filepath[MAXPATHLEN];
+	FILE *file;
+	bool dir_argument_exists = strlen(launch_dir);
+	snprintf(filepath, sizeof(filepath), "%s%s", dir_argument_exists ? launch_dir : "./", Downloads[download_number].filename);
+				if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[download_number].text);}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[download_number].text);}
+	UpdateScreen();
+	
+	line++;
+	gprintf("Downloading %s to %s\r\n", Downloads[download_number].url, filepath);
+	ret = net_init();
+	if(ret < 0) {
+		gprintf("Failed to init network\r\n");
+		goto end;
+	}
+	gprintf("Network Initialized\r\n");
+				if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Network Initialized");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Network Initialized");}
+	UpdateScreen();
+	
+	int i;
+	for (i = 0; i <= 10; i++) {
+		ret = http_request(Downloads[download_number].url, Downloads[download_number].max_size);
+		if (ret) break;
+		if (i == 10) {
+			gprintf("Error making http request\r\n");
+			ret = -1;
+			goto end;
+		}
+	}
+
+	ret = http_get_result(&http_status, &outbuf, &filesize); 
+	if(((int)*outbuf & 0xF0000000) == 0xF0000000) 
+	{
+		ret = -2;
+		goto end;
+	}
+	UpdateScreen();
+	line++;
+	if (!dir_argument_exists) {
+		gprintf("Creating new directory\r\n");
+		mkdir("/apps/Nintendont", S_IWRITE|S_IREAD);
+	}
+	file = fopen(filepath, "wb");
+	if(!file)
+	{
+		gprintf("File Error\r\n");
+		ret = -3;
+		goto end;
+	} else {
+		fwrite(outbuf, filesize, 1, file);
+		fclose(file);
+		if (download_number == DOWNLOAD_THEMES) ret = UnzipThemes(filepath);
+		if (download_number == DOWNLOAD_CLASSIC) ret = UnzipClassic(filepath);
+		if (download_number == DOWNLOAD_AAA) ret = UnzipAaa(filepath);
+		if (download_number == DOWNLOAD_BBB) ret = UnzipBbb(filepath);
+		if (download_number == DOWNLOAD_CCC) ret = UnzipCcc(filepath);		
+		if (ret == 1) {
+					if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*(line), "Update Complete");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*(line), "Update Complete");}
+			UpdateScreen();
+			line++;
+		}
+	}
+
+end:
+	if (ret != 1)
+		{
+			if (which_bg == BG_NONE)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*(line+1), "Update Error: %i", ret);
+			else if (which_bg == BG_LEGACY)
+			PrintFormat(DEFAULT_SIZE, YELLOW, MENU_POS_X, MENU_POS_Y + 20*(line+1), "Update Error: %i", ret);
+		}
+			else {
+	if (which_bg == BG_NONE)
+	{PrintFormat(31, 0x80000000, MENU_POS_X, MENU_POS_Y + 20*(line+15), "GameCube Bios Download Complete");}
+	else if (which_bg == BG_LEGACY)
+	{PrintFormat(31, WHITE, MENU_POS_X, MENU_POS_Y + 20*(line+15), "GameCube Bios Download Complete");}}
+	UpdateScreen();
+	if (outbuf != NULL) free(outbuf);
+	net_deinit();
+	sleep(2);
+	//BackTheme();
+	return ret;
+}
+
+void UpdateBios(void) {
+	int selected = 0;
+	u64 delay = ticks_to_millisecs(gettime()) + 500;
+	while(true) {
+		ClearScreen();
+					if (which_bg == BG_NONE)
+					{		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");		
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*2, "Bios Download/Delete Menu");
+		PrintFormat(27, BLACK, MENU_POS_X, MENU_POS_Y + 20*19, "PAL Bios is not compatible with WiiU");		
+		PrintFormat(15, BLACK, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");	
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Download All Bios Files");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Download USA Bios Only");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Download PAL Bios Only");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Download JAP BIOS Only");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Download Triforce SegaBoot BIOS Only");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*9, "Delete All Bios Files");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*10, "Delete USA Bios Only");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*11, "Delete PAL Bios Only (Recommended for WiiU)");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*12, "Delete JAP BIOS Only");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*13, "Delete Triforce SegaBoot BIOS Only");			
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*14, "Return to Update Menu");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+					else if (which_bg == BG_LEGACY)
+					{		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");	
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*2, "Bios Download/Delete Menu");	
+		PrintFormat(27, WHITE, MENU_POS_X, MENU_POS_Y + 20*19, "PAL Bios is not compatible with WiiU");		
+		PrintFormat(15, WHITE, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");		
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Download All Bios Files");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Download USA Bios Only");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Download PAL Bios Only");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Download JAP BIOS Only");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Download Triforce BIOS Only");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*9, "Delete All Bios Files");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*10, "Delete USA Bios Only");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*11, "Delete PAL Bios Only (Recommended for WiiU)");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*12, "Delete JAP BIOS Only");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*13, "Delete Triforce BIOS Only");			
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*14, "Return to Update Menu");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+		GRRLIB_Render();
+		FPAD_Update();
+		if (delay > ticks_to_millisecs(gettime())) continue;
+		if (FPAD_Start(1)) {
+			ClearScreen();
+						if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Returning to loader...");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, 212, 232, "Returning to loader...");}
+			ExitToLoader(0);
+		}
+			if (FPAD_OK(1)) {
+			if (selected <= (DOWNLOAD_CCC))
+			Download(selected);
+			else if (selected == (DOWNLOAD_D1))
+				{
+				if (UseSD) {
+				remove( "sd:/iplpal.bin" );
+				remove( "sd:/iplusa.bin" );
+				remove( "sd:/ipljap.bin" );
+				remove( "sd:/segaboot.bin" );}
+				else {
+				remove( "usb:/iplpal.bin" );
+				remove( "usb:/iplusa.bin" );
+				remove( "usb:/ipljap.bin" );
+				remove( "usb:/segaboot.bin" );}
+				ClearScreen();
+			//BackTheme();
+			if (which_bg == BG_NONE)
+			{PrintFormat(31, BLACK, MENU_POS_X, MENU_POS_Y + 20*10, "Bios Files Successfully Deleted");}
+			else if (which_bg == BG_LEGACY)
+			{PrintFormat(31, WHITE, MENU_POS_X, MENU_POS_Y + 20*10, "Bios Files Successfully Deleted");}
+			UpdateScreen();
+			sleep (2);
+			UpdateBios();}
+			else if (selected == (DOWNLOAD_D2))
+				{
+				if (UseSD) {
+				remove( "sd:/iplusa.bin" );}
+				else {
+				remove( "usb:/iplusa.bin" );}
+				ClearScreen();
+			//BackTheme();
+			if (which_bg == BG_NONE)
+			{PrintFormat(31, BLACK, MENU_POS_X, MENU_POS_Y + 20*10, "Bios File Successfully Deleted");}
+			else if (which_bg == BG_LEGACY)
+			{PrintFormat(31, WHITE, MENU_POS_X, MENU_POS_Y + 20*10, "Bios File Successfully Deleted");}
+			UpdateScreen();
+			sleep (2);
+			UpdateBios();}
+			else if (selected == (DOWNLOAD_D3))
+				{
+				if (UseSD) {
+				remove( "sd:/iplpal.bin" );}
+				else {
+				remove( "usb:/iplpal.bin" );}
+				ClearScreen();
+			//BackTheme();
+			if (which_bg == BG_NONE)
+			{PrintFormat(31, BLACK, MENU_POS_X, MENU_POS_Y + 20*10, "Bios File Successfully Deleted");}
+			else if (which_bg == BG_LEGACY)
+			{PrintFormat(31, WHITE, MENU_POS_X, MENU_POS_Y + 20*10, "Bios File Successfully Deleted");}
+			UpdateScreen();
+			sleep (2);
+			UpdateBios();}
+			else if (selected == (DOWNLOAD_D4))
+				{
+				if (UseSD) {
+				remove( "sd:/ipljap.bin" );}
+				else {
+				remove( "usb:/ipljap.bin" );}
+				ClearScreen();
+			//BackTheme();
+			if (which_bg == BG_NONE)
+			{PrintFormat(31, BLACK, MENU_POS_X, MENU_POS_Y + 20*10, "Bios File Successfully Deleted");}
+			else if (which_bg == BG_LEGACY)
+			{PrintFormat(31, WHITE, MENU_POS_X, MENU_POS_Y + 20*10, "Bios File Successfully Deleted");}
+			UpdateScreen();
+			sleep (2);
+			UpdateBios();}
+			else if (selected == (DOWNLOAD_D5))
+				{
+				if (UseSD) {
+				remove( "sd:/segaboot.bin" );}
+				else {
+				remove( "usb:/segaboot.bin" );}
+				ClearScreen();
+			//BackTheme();
+			if (which_bg == BG_NONE)
+			{PrintFormat(31, BLACK, MENU_POS_X, MENU_POS_Y + 20*10, "Bios File Successfully Deleted");}
+			else if (which_bg == BG_LEGACY)
+			{PrintFormat(31, WHITE, MENU_POS_X, MENU_POS_Y + 20*10, "Bios File Successfully Deleted");}
+			UpdateScreen();
+			sleep (2);
+			UpdateBios();}			
+			else
+				break;
+		}
+		if (FPAD_Down(1)) {
+			delay = ticks_to_millisecs(gettime()) + 150;
+			selected++;
+			if (selected > 10) selected = 0;
+		}
+		if (FPAD_Up(1)) {
+			delay = ticks_to_millisecs(gettime()) + 150;
+			selected--;
+			if (selected < 0) selected = 10;
+		}
+		if(FPAD_Y(0)) {
+				Credits();
+		}
+		if (FPAD_Cancel(1)) {
+			break;
+		}
+	}
+	ClearScreen();
+	UpdateNintendont();
+}
\ No newline at end of file
Index: loader/source/update-custom-menu.c
===================================================================
--- loader/source/update-custom-menu.c	(revision 0)
+++ loader/source/update-custom-menu.c	(working copy)
@@ -0,0 +1,156 @@
+/*
+
+Nintendont (Loader) - Playing Gamecubes in Wii mode on a Wii U
+
+Copyright (C) 2014  JoostinOnline
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation version 2.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+
+*/
+
+#include <gccore.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <malloc.h>
+#include <network.h>
+#include <fat.h>
+#include <dirent.h>
+#include <zlib.h>
+#include <ogc/lwp_watchdog.h>
+
+#include "exi.h"
+#include "FPad.h"
+#include "font.h"
+#include "global.h"
+#include "menu.h"
+#include "update.h"
+#include "unzip/miniunz.h"
+#include "../../common/include/NintendontVersion.h"
+
+extern char launch_dir[MAXPATHLEN];
+int menumod = 0;
+typedef struct {
+	const char url[96];
+	const char text[30];
+	const char filename[30];
+	const u32 max_size;
+} downloads_t;
+
+typedef enum {
+	DOWNLOAD_01,
+	DOWNLOAD_02,
+	DOWNLOAD_03,
+	DOWNLOAD_04,
+	DOWNLOAD_05
+} DOWNLOADS;
+
+static const downloads_t Downloads[] = {
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400} // 1KB
+};
+
+void GDMenu(void) {
+	int selected = 0;
+	u64 delay = ticks_to_millisecs(gettime()) + 500;
+	while(true) {
+		ClearScreen();
+		if (which_bg == BG_NONE)
+					{		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");	
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*2, "Custom Game Themes Menu");	
+		PrintFormat(15, BLACK, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");	
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Download Custom Game Theme (Without Progress Bar)");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Download Custom Game Theme (With Progress Bar)");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Manually Delete Individual Custom Game Themes");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Delete All Custom Game Themes Now");		
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Return to Update Menu");	
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+					else if (which_bg == BG_LEGACY)
+					{		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");	
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*2, "Custom Game Themes Menu");		
+		PrintFormat(15, WHITE, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");	
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Download Custom Game Theme (Without Progress Bar)");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Download Custom Game Theme (With Progress Bar)");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Manually Delete Individual Custom Game Themes");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Delete All Custom Game Themes Now");		
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Return to Update Menu");	
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+
+		GRRLIB_Render();
+		FPAD_Update();
+		if (delay > ticks_to_millisecs(gettime())) continue;
+		if (FPAD_Start(1)) {
+			ClearScreen();
+					if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Returning to loader...");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, 212, 232, "Returning to loader...");}
+			ExitToLoader(0);
+		}
+		if (FPAD_OK(1)) {
+			if (selected == (DOWNLOAD_01))
+			{menumod = 1;
+			DownloadGame();}
+			if (selected == (DOWNLOAD_02))
+			{menumod = 2;
+			DownloadGame();}
+			if (selected == (DOWNLOAD_03))
+			{menumod = 3;
+			DownloadGame();}
+			if (selected == (DOWNLOAD_04)) 
+			{
+			DeleteCustom();
+			ClearScreen();
+			BackTheme();
+			if (which_bg == BG_NONE)
+			{PrintFormat(30, BLACK, MENU_POS_X, MENU_POS_Y + 20*10, "Game Theme Successfully Deleted");}
+			else if (which_bg == BG_LEGACY)
+			{PrintFormat(30, WHITE, MENU_POS_X, MENU_POS_Y + 20*10, "Game Theme Successfully Deleted");}
+			UpdateScreen();
+			sleep (2);
+			GDMenu();}
+			if (selected == (DOWNLOAD_05)) 
+			break;
+			else
+				break;}
+		if (FPAD_Down(1)) {
+			delay = ticks_to_millisecs(gettime()) + 150;
+			selected++;
+			if (selected > 4) selected = 0;
+		}
+		if (FPAD_Up(1)) {
+			delay = ticks_to_millisecs(gettime()) + 150;
+			selected--;
+			if (selected < 0) selected = 4;
+		}
+		if(FPAD_Y(0)) {
+				Credits();
+		}				
+		if (FPAD_Cancel(1)) {
+			break;
+		}
+	}
+	ClearScreen();
+	UpdateNintendont();
+}
\ No newline at end of file
Index: loader/source/update-custom.c
===================================================================
--- loader/source/update-custom.c	(revision 0)
+++ loader/source/update-custom.c	(working copy)
@@ -0,0 +1,566 @@
+/*
+
+Nintendont (Loader) - Playing Gamecubes in Wii mode on a Wii U
+
+Copyright (C) 2014  JoostinOnline
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation version 2.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+
+*/
+
+#include <gccore.h>
+#include <string.h>
+#include <unistd.h>
+#include <malloc.h>
+#include <network.h>
+#include <fat.h>
+#include <dirent.h>
+#include <zlib.h>
+#include <ogc/lwp_watchdog.h>
+#include "http.h"
+#include "menu.h"
+#include "font.h"
+#include "exi.h"
+#include "global.h"
+#include "FPad.h"
+#include "Config.h"
+#include "update.h"
+#include "titles.h"
+#include "dip.h"
+#include <dirent.h>
+#include <sys/dir.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <ogc/stm.h>
+#include <ogc/consol.h>
+#include <ogc/system.h>
+#include <fat.h>
+#include <di/di.h>
+#include "unzip/miniunz.h"
+#include "../../common/include/NintendontVersion.h"
+
+extern char launch_dir[MAXPATHLEN];
+extern int menumod;
+
+typedef struct {
+	const char url[96];
+	const char text[30];
+	const char filename[30];
+	const u32 max_size;
+} downloads_t;
+
+typedef enum {
+	DOWNLOAD_CUSTOM,
+} DOWNLOADS;
+char url[96] = "http://nintendont.gxarena.com/themes/test.png";
+char filename[30] = "test.png";
+static const downloads_t Downloads[] = {
+	{"http://nintendont.gxarena.com/themes/test.png", "Downloading Custom Game Theme", "test.png", 0x400000}, // 4MB
+};
+
+extern NIN_CFG* ncfg;
+
+int compare_names2(const void *a, const void *b)
+{
+	const gameinfo *da = (const gameinfo *) a;
+	const gameinfo *db = (const gameinfo *) b;
+
+	return strcasecmp(da->Name, db->Name);
+}
+
+static s32 Download(DOWNLOADS download_number)  {
+	ClearScreen();
+	
+	int line = 1;
+	int ret;
+	u32 http_status = 0;
+	u8* outbuf = NULL;
+	u32 filesize;
+	char filepath[MAXPATHLEN];
+	FILE *file;
+	bool dir_argument_exists = strlen(launch_dir);
+	snprintf(filepath, sizeof(filepath), "%s%s", dir_argument_exists ? launch_dir : "./", filename);
+				if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[0].text);}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[0].text);}
+	UpdateScreen();
+	
+	line++;
+	gprintf("Downloading %s to %s\r\n", Downloads[download_number].url, filepath);
+	ret = net_init();
+	if(ret < 0) {
+		gprintf("Failed to init network\r\n");
+		goto end;
+	}
+	gprintf("Network Initialized\r\n");
+				if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Network Initialized");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Network Initialized");}
+	UpdateScreen();
+	
+	int i;
+	for (i = 0; i <= 10; i++) {
+		ret = http_request(url, Downloads[0].max_size);
+		if (ret) break;
+		if (i == 10) {
+			gprintf("Error making http request\r\n");
+			ret = -1;
+			goto end;
+		}
+	}
+
+	ret = http_get_result(&http_status, &outbuf, &filesize); 
+	if(((int)*outbuf & 0xF0000000) == 0xF0000000) 
+	{
+		ret = -2;
+		goto end;
+	}
+	UpdateScreen();
+	line++;
+	if (!dir_argument_exists) {
+		gprintf("Creating new directory\r\n");
+		mkdir("/apps/Nintendont", S_IWRITE|S_IREAD);
+	}
+	file = fopen(filepath, "wb");
+	if(!file)
+	{
+		gprintf("File Error\r\n");
+		ret = -3;
+		goto end;
+	} else {
+		fwrite(outbuf, filesize, 1, file);
+		fclose(file);
+		if (download_number == DOWNLOAD_CUSTOM) ret = 1;
+		if (ret == 1) {
+					if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*(line), "Update Complete");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*(line), "Update Complete");}
+			UpdateScreen();
+			line++;
+		}
+	}
+
+end:
+	if (ret != 1)
+		{
+			if (which_bg == BG_NONE)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*(line+1), "Update Error: %i", ret);
+			else if (which_bg == BG_LEGACY)
+			PrintFormat(DEFAULT_SIZE, YELLOW, MENU_POS_X, MENU_POS_Y + 20*(line+1), "Update Error: %i", ret);
+		UpdateScreen();
+		sleep(3);
+		}
+	else
+	{									if (which_bg == BG_NONE)
+					{
+					PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Custom Game Loader Theme Downloaded Successfully");
+					PrintFormat(27, BLACK, MENU_POS_X, MENU_POS_Y + 20*(line+15), "You'll Watch a 3 Seconds Preview Now");
+					PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Custom Game Loader Theme Downloaded Successfully");
+					PrintFormat(27, BLACK, MENU_POS_X, MENU_POS_Y + 20*(line+15), "You'll Watch a 3 Seconds Preview Now");
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+					PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Custom Game Loader Theme Downloaded Successfully");
+					PrintFormat(27, WHITE, MENU_POS_X, MENU_POS_Y + 20*(line+15), "You'll Watch a 3 Seconds Preview Now");
+					PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Custom Game Loader Theme Downloaded Successfully");
+					PrintFormat(27, WHITE, MENU_POS_X, MENU_POS_Y + 20*(line+15), "You'll Watch a 3 Seconds Preview Now");					
+					}	
+	UpdateScreen();
+	sleep(3);
+	rename("test.png", filename);
+	GRRLIB_FreeTexture(background);
+	background = GRRLIB_LoadTextureFromFile(filename);
+	FadeIt();
+	sleep(3);
+	BackTheme();
+	}
+	UpdateScreen();
+	if (outbuf != NULL) free(outbuf);
+	net_deinit();
+	return ret;
+}
+
+void DownloadGame( void )
+{	
+//Create a list of games
+	char filename[MAXPATHLEN];
+	char gamename[MAXPATHLEN];
+	int selected = 0;
+	DIR *pdir;
+	struct dirent *pent;
+	struct stat statbuf;
+	start:
+	sprintf(filename, "%s:/games", GetRootDevice());
+	pdir = opendir(filename);
+	if( !pdir )
+	{
+		ClearScreen();
+		gprintf("No FAT device found, or missing %s dir!\n", filename);
+		PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, 232, "No FAT device found, or missing %s dir!", filename );
+		ExitToLoader(1);
+	}
+
+	u32 gamecount = 0;
+	char buf[0x100];
+	gameinfo gi[MAX_GAMES];
+
+	memset( gi, 0, sizeof(gameinfo) * MAX_GAMES );
+	if( !IsWiiU() )
+	{
+		gi[0].Name = strdup("Boot GC Disc in Drive");
+		gi[0].ID[0] = 'D',gi[0].ID[1] = 'I',gi[0].ID[2] = 'S';
+		gi[0].ID[3] = 'C',gi[0].ID[4] = '0',gi[0].ID[5] = '1';
+		gi[0].Path = strdup("di:di");
+		gamecount++;
+	}
+	while( ( pent = readdir(pdir) ) != NULL )
+	{
+		stat( pent->d_name, &statbuf );
+		if( pent->d_type == DT_DIR )
+		{
+			if( pent->d_name[0] == '.' )	//skip current and previous directories
+				continue;
+
+		//	gprintf( "%s", pent->d_name );
+
+			//Test if game.iso exists and add to list
+
+			bool found = false;
+			u32 DiscNumber;
+			for (DiscNumber = 0; DiscNumber < 2; DiscNumber++)
+			{
+				sprintf( filename, "%s:/games/%s/%s.iso", GetRootDevice(), pent->d_name, DiscNumber ? "disc2" : "game" );
+
+				FILE *in = fopen( filename, "rb" );
+				if( in != NULL )
+				{
+				//	gprintf("(%s) ok\n", filename );
+					fread( buf, 1, 0x100, in );
+					fclose(in);
+
+					if( IsGCGame((u8*)buf) )	// Must be GC game
+					{
+						memcpy(gi[gamecount].ID, buf, 6); //ID for EXI
+						if(!SearchTitles(gi[gamecount].ID)) strcpy( gamename, buf + 0x20 );
+						if (DiscNumber)
+							strcat( gamename, " (2)" );
+						gi[gamecount].Name = strdup( gamename );
+						gi[gamecount].Path = strdup( filename );
+
+						gamecount++;
+						found = true;
+					}
+				}
+			}
+			if ( !found ) // Check for FST format
+			{
+				sprintf(filename, "%s:/games/%s/sys/boot.bin", GetRootDevice(), pent->d_name);
+
+				FILE *in = fopen( filename, "rb" );
+				if( in != NULL )
+				{
+				//	gprintf("(%s) ok\n", filename );
+					fread( buf, 1, 0x100, in );
+					fclose(in);
+
+					if( IsGCGame((u8*)buf) )	// Must be GC game
+					{
+						sprintf(filename, "%s:/games/%s/", GetRootDevice(), pent->d_name);
+
+						memcpy(gi[gamecount].ID, buf, 6); //ID for EXI
+						gi[gamecount].Name = strdup( buf + 0x20 );
+						gi[gamecount].Path = strdup( filename );
+						
+
+						gamecount++;
+					}
+				}
+			}
+		}
+		if (gamecount >= MAX_GAMES)	//if array is full
+			break;
+	}
+
+	if( IsWiiU() )
+		qsort(gi, gamecount, sizeof(gameinfo), compare_names2);
+	else if( gamecount > 1 )
+		qsort(&gi[1], gamecount-1, sizeof(gameinfo), compare_names2);
+
+	u32 redraw = 1;
+	u32 i;
+	s32 PosX = 0;
+	s32 ScrollX = 0;
+	u32 MenuMode = 0;
+
+	u32 ListMax = gamecount;
+	if( ListMax > 15 )
+		ListMax = 15;
+	FadeIt();
+//	set default game to game that currently set in configuration
+	for (i = 0; i < gamecount; ++i)
+	{
+		if (strcasecmp(strchr(gi[i].Path,':')+1, ncfg->GamePath) == 0)
+		{
+			if( i >= ListMax )
+			{
+				PosX	= ListMax - 1;
+				ScrollX = i - ListMax + 1;
+			} else {
+				PosX = i;
+			}
+			break;
+		}
+	}
+	UpdateScreen();
+	u32 UpHeld = 0, DownHeld = 0;
+	while(1)
+	{
+		VIDEO_WaitVSync();
+		FPAD_Update();
+
+		if( FPAD_Start(1) )
+		{
+			ClearScreen();
+					if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Returning to loader..." );	}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, 212, 232, "Returning to loader..." );	}
+			ExitToLoader(0);
+		}
+
+		if( FPAD_Cancel(0) )
+		{
+			return;
+			redraw = 1;
+		}
+
+	//	gprintf("\rS:%u P:%u G:%u M:%u    ", ScrollX, PosX, gamecount, ListMax );
+
+		if( MenuMode == 0 )		//game select menu
+		{
+			if(FPAD_X(0)) {				
+				UpdateNintendont();
+				redraw = 1;
+			}
+			if(FPAD_Y(0)) {
+				Credits();
+				redraw = 1;
+			}			
+			if( FPAD_Down(1) )
+			{
+				if(DownHeld == 0 || DownHeld > 10)
+				{
+					if (which_bg == BG_NONE)
+					{
+					PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+					PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
+					}					
+					if( PosX + 1 >= ListMax )
+					{
+						if( PosX + 1 + ScrollX < gamecount)
+							ScrollX++;
+						else {
+							PosX	= 0;
+							ScrollX = 0;
+						}
+					} else {
+						PosX++;
+					}
+					redraw=1;
+					}
+				DownHeld++;
+			}
+			else
+				DownHeld = 0;
+			if( FPAD_Right(0) )
+			{
+					if (which_bg == BG_NONE)
+					{
+					PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+					PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
+					}	
+				if( PosX == ListMax - 1 )
+				{
+					if( PosX + ListMax + ScrollX < gamecount)
+						ScrollX = ScrollX + ListMax;
+					else
+					if( PosX + ScrollX != gamecount -1)
+						ScrollX = gamecount - ListMax;
+					else {
+						PosX	= 0;
+						ScrollX = 0;
+					}
+				} else {
+					PosX = ListMax - 1;
+				}
+				redraw=1;
+			}
+			if( FPAD_Up(1) )
+			{
+				if(UpHeld == 0 || UpHeld > 10)
+				{
+					if (which_bg == BG_NONE)
+					{
+					PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+					PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
+					}	
+					if( PosX <= 0 )
+					{
+						if( ScrollX > 0 )
+							ScrollX--;
+						else {
+							PosX	= ListMax - 1;
+							ScrollX = gamecount - ListMax;
+						}
+					} else {
+						PosX--;
+					}
+					redraw=1;
+				}
+				UpHeld++;
+			}
+			else
+				UpHeld = 0;
+			if( FPAD_Left(0) )
+			{
+					if (which_bg == BG_NONE)
+					{
+					PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+					PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X+51*6-8, MENU_POS_Y + 20*6 + PosX * 20, " " );
+					}	
+				if( PosX == 0 )
+				{
+					if( ScrollX - (s32)ListMax >= 0 )
+						ScrollX = ScrollX - ListMax;
+					else
+					if( ScrollX != 0 )
+						ScrollX = 0;
+					else {
+						ScrollX = gamecount - ListMax;
+					}
+				} else {
+					PosX = 0;
+				}
+				redraw=1;
+			}
+
+			if( FPAD_OK(0) )
+			{
+				break;
+			}
+
+			if( redraw )
+			{
+				PrintInfo();
+					if (which_bg == BG_NONE)
+					{
+				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+				if (menumod == 3)
+				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Delete");
+				else 
+				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Download");
+				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Game List");
+				PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*2, "Custom Game Themes Manager");
+				PrintFormat(15, BLACK, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+				PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+				if (menumod == 3)
+				PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Delete");
+				else 
+				PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Download");
+				PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Game List");
+				PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*2, "Custom Game Themes Manager");
+				PrintFormat(15, WHITE, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");
+					}					
+
+				for( i=0; i < ListMax; ++i )
+					if (which_bg == BG_NONE)
+					{
+			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*5 + i * 20, "%s[%.6s] %50.50s", i == PosX ? ARROW_RIGHT : " ", gi[i+ScrollX].ID, gi[i+ScrollX].Name);
+					}
+					else if (which_bg == BG_LEGACY)
+					{
+			PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*5 + i * 20, "%s[%.6s] %50.50s", i == PosX ? ARROW_RIGHT : " ", gi[i+ScrollX].ID, gi[i+ScrollX].Name);
+					}	
+				GRRLIB_Render();
+				Screenshot();
+				ClearScreen();
+				redraw = 0;
+			}
+
+		}
+	}
+	u32 SelectedGame = PosX + ScrollX;
+	char* StartChar = gi[SelectedGame].Path + 3;
+	if (StartChar[0] == ':')
+		StartChar++;
+	memcpy(&(ncfg->GameID), gi[SelectedGame].ID, 3);
+	char GETID3[8];
+	memset(GETID3, 0, 8);
+	char fileid4[8];
+	memset(fileid4, 0, 8);	
+	memcpy(GETID3, &(ncfg->GameID), 3);
+	if (menumod == 2)
+	sprintf(filename, "%sX.png", GETID3);
+	else
+	sprintf(filename, "%s.png", GETID3);
+	sprintf(fileid4, "%sX.png", GETID3);
+	if (menumod == 1)
+	sprintf(url, "http://nintendont.gxarena.com/themes/%s.png", GETID3);
+	else if (menumod == 2)
+	sprintf(url, "http://nintendont.gxarena.com/themes/%sX.png", GETID3);
+	else
+	{
+	BackTheme();
+	remove(filename);
+	remove(fileid4);
+	if (which_bg == BG_NONE)
+	{PrintFormat(30, BLACK, MENU_POS_X, MENU_POS_Y + 20*10, "Game Theme Successfully Deleted");}
+	else if (which_bg == BG_LEGACY)
+	{PrintFormat(30, WHITE, MENU_POS_X, MENU_POS_Y + 20*10, "Game Theme Successfully Deleted");}
+	UpdateScreen();
+	sleep (2);
+	}
+	for( i=0; i < gamecount; ++i )
+	{
+		free(gi[i].Name);
+		free(gi[i].Path);
+	}
+	if (menumod != 3)
+	{remove(filename);
+	remove(fileid4);
+	Download(selected);
+	rename("./test.png", filename);
+	rename("test.png", filename);}
+	redraw = 1;
+	goto start;
+}
Index: loader/source/update-dark.c
===================================================================
--- loader/source/update-dark.c	(revision 0)
+++ loader/source/update-dark.c	(working copy)
@@ -0,0 +1,747 @@
+/*
+
+Nintendont (Loader) - Playing Gamecubes in Wii mode on a Wii U
+
+Copyright (C) 2014  JoostinOnline
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation version 2.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+
+*/
+
+#include <gccore.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <malloc.h>
+#include <network.h>
+#include <fat.h>
+#include <dirent.h>
+#include <zlib.h>
+#include <ogc/lwp_watchdog.h>
+
+#include "exi.h"
+#include "FPad.h"
+#include "font.h"
+#include "global.h"
+#include "http.h"
+#include "menu.h"
+#include "update.h"
+#include "unzip/miniunz.h"
+#include "../../common/include/NintendontVersion.h"
+
+extern char launch_dir[MAXPATHLEN];
+
+typedef struct {
+	const char url[96];
+	const char text[30];
+	const char filename[30];
+	const u32 max_size;
+} downloads_t;
+
+typedef enum {
+	DOWNLOAD_THEMES,
+	DOWNLOAD_CLASSIC,
+	DOWNLOAD_CLASSICWII,
+	DOWNLOAD_DISCS,
+	DOWNLOAD_GCNS,
+	DOWNLOAD_MMBLUE,
+	DOWNLOAD_MMCLASSIC,
+	DOWNLOAD_MMDARK1,
+	DOWNLOAD_MMDARK2,
+	DOWNLOAD_ORANGE,
+	DOWNLOAD_PURPLE,
+	DOWNLOAD_SMASH,
+	DOWNLOAD_BARS,
+	DOWNLOAD_AAA,
+	DOWNLOAD_BBB,
+	DOWNLOAD_CCC	
+} DOWNLOADS;
+
+static const downloads_t Downloads[] = {
+	{"http://178.33.61.6/putstorage/DownloadFileHash/294987DD3A5A4A5QQWE2740263EWQS/legacy00.zip", "Downloading Theme", "legacy00.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/EDF86F4E3A5A4A5QQWE2740264EWQS/legacy01.zip", "Downloading Theme", "legacy01.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/2C064AAA3A5A4A5QQWE2740265EWQS/legacy02.zip", "Downloading Theme", "legacy02.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/3E5A4BAF3A5A4A5QQWE2740266EWQS/legacy03.zip", "Downloading Theme", "legacy03.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/877E01BA3A5A4A5QQWE2740267EWQS/legacy04.zip", "Downloading Theme", "legacy04.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/412D2CEC3A5A4A5QQWE2740268EWQS/legacy05.zip", "Downloading Theme", "legacy05.zip", 0x80000}, // 512KB	
+	{"http://178.33.61.6/putstorage/DownloadFileHash/FF8185F33A5A4A5QQWE2740269EWQS/legacy06.zip", "Downloading Theme", "legacy06.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/13072FF13A5A4A5QQWE2740270EWQS/legacy07.zip", "Downloading Theme", "legacy07.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/FADBA55D3A5A4A5QQWE2740272EWQS/legacy08.zip", "Downloading Theme", "legacy08.zip", 0x80000}, // 512KB	
+	{"http://178.33.61.6/putstorage/DownloadFileHash/FF0DE55A3A5A4A5QQWE2740274EWQS/legacy09.zip", "Downloading Theme", "legacy09.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/C84360D13A5A4A5QQWE2740275EWQS/legacy10.zip", "Downloading Theme", "legacy10.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/DBFFFEF23A5A4A5QQWE2740277EWQS/legacy11.zip", "Downloading Theme", "legacy11.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/36F4C2983A5A4A5QQWE2740278EWQS/legacy12.zip", "Downloading Theme", "legacy12.zip", 0x80000}, // 512KB	
+	{"http://178.33.61.6/putstorage/DownloadFileHash/16EFF6803A5A4A5QQWE2740279EWQS/legacy13.zip", "Downloading Theme", "legacy13.zip", 0x80000}, // 512KB
+	{"http://178.33.238.21/putstorage/DownloadFileHash/8B98EB473A5A4A5QQWE865804EWQS/legacy14.zip", "Downloading Theme", "legacy14.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/D2BA1A7F3A5A4A5QQWE2740281EWQS/legacy15.zip", "Downloading Theme", "legacy15.zip", 0x80000}, // 512KB		
+};
+
+static int UnzipThemes(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_THEMES].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_THEMES].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_THEMES].filename);
+	return 1;
+}
+
+static int UnzipClassic(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_CLASSIC].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_CLASSIC].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_CLASSIC].filename);
+	return 1;
+}
+
+static int UnzipClassicwii(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_CLASSICWII].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_CLASSICWII].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_CLASSICWII].filename);
+	return 1;
+}
+
+static int UnzipDiscs(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_DISCS].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_DISCS].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_DISCS].filename);
+	return 1;
+}
+
+static int UnzipGcns(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_GCNS].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_GCNS].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_GCNS].filename);
+	return 1;
+}
+
+static int UnzipMmblue(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_MMBLUE].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_MMBLUE].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_MMBLUE].filename);
+	return 1;
+}
+
+static int UnzipMmclassic(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_MMCLASSIC].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_MMCLASSIC].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_MMCLASSIC].filename);
+	return 1;
+}
+
+static int UnzipMmdark1(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_MMDARK1].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_MMDARK1].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_MMDARK1].filename);
+	return 1;
+}
+
+static int UnzipMmdark2(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_MMDARK2].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_MMDARK2].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_MMDARK2].filename);
+	return 1;
+}
+
+static int UnzipOrange(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_ORANGE].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_ORANGE].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_ORANGE].filename);
+	return 1;
+}
+
+static int UnzipPurple(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_PURPLE].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_PURPLE].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_PURPLE].filename);
+	return 1;
+}
+
+static int UnzipSmash(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_SMASH].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_SMASH].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_SMASH].filename);
+	return 1;
+}
+
+static int UnzipBars(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_BARS].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_BARS].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_BARS].filename);
+	return 1;
+}
+
+static int UnzipAaa(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_AAA].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_AAA].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_AAA].filename);
+	return 1;
+}
+
+static int UnzipBbb(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_BBB].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_BBB].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_BBB].filename);
+	return 1;
+}
+
+static int UnzipCcc(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_CCC].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_CCC].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_CCC].filename);
+	return 1;
+}
+
+static s32 Download(DOWNLOADS download_number)  {
+	ClearScreen();
+	
+	int line = 1;
+	int ret;
+	u32 http_status = 0;
+	u8* outbuf = NULL;
+	u32 filesize;
+	char filepath[MAXPATHLEN];
+	FILE *file;
+	bool dir_argument_exists = strlen(launch_dir);
+	snprintf(filepath, sizeof(filepath), "%s%s", dir_argument_exists ? launch_dir : "/apps/Nintendont/", Downloads[download_number].filename);
+	if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[download_number].text);}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[download_number].text);}
+	UpdateScreen();
+	
+	line++;
+	gprintf("Downloading %s to %s\r\n", Downloads[download_number].url, filepath);
+	ret = net_init();
+	if(ret < 0) {
+		gprintf("Failed to init network\r\n");
+		goto end;
+	}
+	gprintf("Network Initialized\r\n");
+	if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Network Initialized");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Network Initialized");}
+	UpdateScreen();
+	
+	int i;
+	for (i = 0; i <= 10; i++) {
+		ret = http_request(Downloads[download_number].url, Downloads[download_number].max_size);
+		if (ret) break;
+		if (i == 10) {
+			gprintf("Error making http request\r\n");
+			ret = -1;
+			goto end;
+		}
+	}
+
+	ret = http_get_result(&http_status, &outbuf, &filesize); 
+	if(((int)*outbuf & 0xF0000000) == 0xF0000000) 
+	{
+		ret = -2;
+		goto end;
+	}
+
+	UpdateScreen();
+	line++;
+	if (!dir_argument_exists) {
+		gprintf("Creating new directory\r\n");
+		mkdir("/apps/Nintendont", S_IWRITE|S_IREAD);
+	}
+	file = fopen(filepath, "wb");
+	if(!file)
+	{
+		gprintf("File Error\r\n");
+		ret = -3;
+		goto end;
+	} else {
+		fwrite(outbuf, filesize, 1, file);
+		fclose(file);
+		if (download_number == DOWNLOAD_THEMES) ret = UnzipThemes(filepath);
+		if (download_number == DOWNLOAD_CLASSIC) ret = UnzipClassic(filepath);
+		if (download_number == DOWNLOAD_CLASSICWII) ret = UnzipClassicwii(filepath);
+		if (download_number == DOWNLOAD_DISCS) ret = UnzipDiscs(filepath);
+		if (download_number == DOWNLOAD_GCNS) ret = UnzipGcns(filepath);
+		if (download_number == DOWNLOAD_MMBLUE) ret = UnzipMmblue(filepath);
+		if (download_number == DOWNLOAD_MMCLASSIC) ret = UnzipMmclassic(filepath);
+		if (download_number == DOWNLOAD_MMDARK1) ret = UnzipMmdark1(filepath);
+		if (download_number == DOWNLOAD_MMDARK2) ret = UnzipMmdark2(filepath);
+		if (download_number == DOWNLOAD_ORANGE) ret = UnzipOrange(filepath);
+		if (download_number == DOWNLOAD_PURPLE) ret = UnzipPurple(filepath);
+		if (download_number == DOWNLOAD_SMASH) ret = UnzipSmash(filepath);
+		if (download_number == DOWNLOAD_BARS) ret = UnzipBars(filepath);
+		if (download_number == DOWNLOAD_AAA) ret = UnzipAaa(filepath);
+		if (download_number == DOWNLOAD_BBB) ret = UnzipBbb(filepath);
+		if (download_number == DOWNLOAD_CCC) ret = UnzipCcc(filepath);		
+		if (ret == 1) {
+		if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*(line), "Update Complete");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*(line), "Update Complete");}
+			UpdateScreen();
+			line++;
+		}
+	}
+
+end:
+	if (ret != 1)
+		{
+			if (which_bg == BG_NONE)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*(line+1), "Update Error: %i", ret);
+			else if (which_bg == BG_LEGACY)
+			PrintFormat(DEFAULT_SIZE, YELLOW, MENU_POS_X, MENU_POS_Y + 20*(line+1), "Update Error: %i", ret);
+			rename( "./NinBack.old", "./NinBack.png");
+			rename( "./NinBlack.old", "./NinBlack.png");
+			rename( "./NinLegacy.old", "./NinLegacy.png");
+			UpdateScreen();
+			if (outbuf != NULL) free(outbuf);
+			net_deinit();
+			sleep(2);
+			return ret;		
+		}
+	else {
+	if (which_bg == BG_NONE)
+	{PrintFormat(37, 0x80000000, MENU_POS_X, MENU_POS_Y + 20*(line+15), "Applying The New Theme Now");}
+	else if (which_bg == BG_LEGACY)
+	{PrintFormat(37, WHITE, MENU_POS_X, MENU_POS_Y + 20*(line+15), "Applying The New Theme Now");}}
+	UpdateScreen();
+	if (outbuf != NULL) free(outbuf);
+	net_deinit();
+	sleep(2);
+	BackTheme();
+	return ret;
+}
+
+void UpdateLegacy(void) {
+	int selected = 0;
+	u64 delay = ticks_to_millisecs(gettime()) + 500;
+	while(true) {
+		ClearScreen();
+		BackTheme();
+		if (which_bg == BG_NONE)
+					{		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*2, "Dark Themes Download Menu");		
+		PrintFormat(15, BLACK, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");	
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Download Doomy Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Download Carbonix Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Download Orchid Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Download Oily Theme");		
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Download Stripes Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*9, "Download Dark Planet Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*10, "Download Rusty Hell Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*11, "Download Infinite Flower Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*12, "Download Cosmic Puzzle Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*13, "Download Chirpy Red Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*14, "Download Cloudy Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*15, "Download Nintendo Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*16, "Download Magical Cube Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*17, "Download GC Logo Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*18, "Download Alone in The Dark Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*19, "Download Dark Forest Theme");		
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+					else if (which_bg == BG_LEGACY)
+					{		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");		
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*2, "Dark Themes Download Menu");
+		PrintFormat(15, WHITE, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");	
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Download Doomy Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Download Carbonix Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Download Orchid Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Download Oily Theme");		
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Download Stripes Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*9, "Download Dark Planet Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*10, "Download Rusty Hell Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*11, "Download Infinite Flower Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*12, "Download Cosmic Puzzle Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*13, "Download Chirpy Red Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*14, "Download Cloudy Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*15, "Download Nintendo Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*16, "Download Magical Cube Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*17, "Download GC Logo Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*18, "Download Alone in The Dark Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*19, "Download Dark Forest Theme");			
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+
+		GRRLIB_Render();
+		FPAD_Update();
+		if (delay > ticks_to_millisecs(gettime())) continue;
+		if (FPAD_Start(1)) {
+			ClearScreen();
+			if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Returning to loader...");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, 212, 232, "Returning to loader...");}
+			ExitToLoader(0);
+		}
+			if (FPAD_OK(1)) {
+			if (selected <= (DOWNLOAD_CCC))
+			{
+			rename( "./NinBack.png", "./NinBack.old");
+			rename( "./NinBlack.png", "./NinBlack.old");
+			rename( "./NinLegacy.png", "./NinLegacy.old");
+			Download(selected);
+			remove( "./NinBack.old" );
+			remove( "./NinBlack.old" );
+			remove( "./NinLegacy.old" );
+			GRRLIB_FreeTexture(background);
+			which_bg = BG_LEGACY;
+			background = GRRLIB_LoadTextureFromFile("NinLegacy.png");	
+			if (background == NULL)
+			background = GRRLIB_LoadTexturePNG(background_png);
+			FadeIt();}
+			else
+				break;
+		}
+		if (FPAD_Down(1)) {
+			delay = ticks_to_millisecs(gettime()) + 150;
+			selected++;
+			if (selected > 15) selected = 0;
+		}
+		if (FPAD_Up(1)) {
+			delay = ticks_to_millisecs(gettime()) + 150;
+			selected--;
+			if (selected < 0) selected = 15;
+		}
+		if(FPAD_Y(0)) {
+				Credits();
+		}
+		if (FPAD_Cancel(1)) {
+			break;
+		}
+	}
+	ClearScreen();
+	UpdateNintendont();
+}
Index: loader/source/update-grad.c
===================================================================
--- loader/source/update-grad.c	(revision 0)
+++ loader/source/update-grad.c	(working copy)
@@ -0,0 +1,744 @@
+/*
+
+Nintendont (Loader) - Playing Gamecubes in Wii mode on a Wii U
+
+Copyright (C) 2014  JoostinOnline
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation version 2.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+
+*/
+
+#include <gccore.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <malloc.h>
+#include <network.h>
+#include <fat.h>
+#include <dirent.h>
+#include <zlib.h>
+#include <ogc/lwp_watchdog.h>
+
+#include "exi.h"
+#include "FPad.h"
+#include "font.h"
+#include "global.h"
+#include "http.h"
+#include "menu.h"
+#include "update.h"
+#include "unzip/miniunz.h"
+#include "../../common/include/NintendontVersion.h"
+
+extern char launch_dir[MAXPATHLEN];
+
+typedef struct {
+	const char url[96];
+	const char text[30];
+	const char filename[30];
+	const u32 max_size;
+} downloads_t;
+
+typedef enum {
+	DOWNLOAD_THEMES,
+	DOWNLOAD_CLASSIC,
+	DOWNLOAD_CLASSICWII,
+	DOWNLOAD_DISCS,
+	DOWNLOAD_GCNS,
+	DOWNLOAD_MMBLUE,
+	DOWNLOAD_MMCLASSIC,
+	DOWNLOAD_MMDARK1,
+	DOWNLOAD_MMDARK2,
+	DOWNLOAD_ORANGE,
+	DOWNLOAD_PURPLE,
+	DOWNLOAD_SMASH,
+	DOWNLOAD_BARS,
+	DOWNLOAD_AAA,
+	DOWNLOAD_BBB,
+	DOWNLOAD_CCC	
+} DOWNLOADS;
+
+static const downloads_t Downloads[] = {
+	{"http://178.33.61.6/putstorage/DownloadFileHash/193634E03A5A4A5QQWE2740219EWQS/grad00.zip", "Downloading Theme", "grad00.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/A7AE1A963A5A4A5QQWE2740220EWQS/grad01.zip", "Downloading Theme", "grad01.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/812C7A673A5A4A5QQWE2740221EWQS/grad02.zip", "Downloading Theme", "grad02.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/6D11114C3A5A4A5QQWE2740223EWQS/grad03.zip", "Downloading Theme", "grad03.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/7BEA424C3A5A4A5QQWE2740224EWQS/grad04.zip", "Downloading Theme", "grad04.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/0B323F5A3A5A4A5QQWE2740225EWQS/grad05.zip", "Downloading Theme", "grad05.zip", 0x80000}, // 512KB	
+	{"http://178.33.61.6/putstorage/DownloadFileHash/1571CC323A5A4A5QQWE2740226EWQS/grad06.zip", "Downloading Theme", "grad06.zip", 0x80000}, // 512KB
+	{"http://178.33.232.54/putstorage/DownloadFileHash/63ABC2BC3A5A4A5QQWE492293EWQS/grad07.zip", "Downloading Theme", "grad07.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/0772FDBC3A5A4A5QQWE2740228EWQS/grad08.zip", "Downloading Theme", "grad08.zip", 0x80000}, // 512KB	
+	{"http://178.33.61.6/putstorage/DownloadFileHash/B92B92953A5A4A5QQWE2740229EWQS/grad09.zip", "Downloading Theme", "grad09.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/3E8D94F33A5A4A5QQWE2740230EWQS/grad10.zip", "Downloading Theme", "grad10.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/21D1A8E23A5A4A5QQWE2740231EWQS/grad11.zip", "Downloading Theme", "grad11.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/04B48E393A5A4A5QQWE2740232EWQS/grad12.zip", "Downloading Theme", "grad12.zip", 0x80000}, // 512KB	
+	{"http://178.33.236.29/putstorage/DownloadFileHash/060B26923A5A4A5QQWE1341372EWQS/grad13.zip", "Downloading Theme", "grad13.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/F7EF65BE3A5A4A5QQWE2740234EWQS/grad14.zip", "Downloading Theme", "grad14.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/F27802293A5A4A5QQWE2740235EWQS/grad15.zip", "Downloading Theme", "grad15.zip", 0x80000}, // 512KB		
+};
+
+static int UnzipThemes(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_THEMES].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_THEMES].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_THEMES].filename);
+	return 1;
+}
+
+static int UnzipClassic(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_CLASSIC].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_CLASSIC].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_CLASSIC].filename);
+	return 1;
+}
+
+static int UnzipClassicwii(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_CLASSICWII].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_CLASSICWII].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_CLASSICWII].filename);
+	return 1;
+}
+
+static int UnzipDiscs(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_DISCS].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_DISCS].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_DISCS].filename);
+	return 1;
+}
+
+static int UnzipGcns(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_GCNS].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_GCNS].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_GCNS].filename);
+	return 1;
+}
+
+static int UnzipMmblue(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_MMBLUE].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_MMBLUE].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_MMBLUE].filename);
+	return 1;
+}
+
+static int UnzipMmclassic(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_MMCLASSIC].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_MMCLASSIC].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_MMCLASSIC].filename);
+	return 1;
+}
+
+static int UnzipMmdark1(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_MMDARK1].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_MMDARK1].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_MMDARK1].filename);
+	return 1;
+}
+
+static int UnzipMmdark2(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_MMDARK2].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_MMDARK2].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_MMDARK2].filename);
+	return 1;
+}
+
+static int UnzipOrange(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_ORANGE].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_ORANGE].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_ORANGE].filename);
+	return 1;
+}
+
+static int UnzipPurple(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_PURPLE].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_PURPLE].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_PURPLE].filename);
+	return 1;
+}
+
+static int UnzipSmash(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_SMASH].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_SMASH].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_SMASH].filename);
+	return 1;
+}
+
+static int UnzipBars(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_BARS].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_BARS].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_BARS].filename);
+	return 1;
+}
+
+static int UnzipAaa(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_AAA].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_AAA].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_AAA].filename);
+	return 1;
+}
+
+static int UnzipBbb(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_BBB].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_BBB].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_BBB].filename);
+	return 1;
+}
+
+static int UnzipCcc(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_CCC].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_CCC].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_CCC].filename);
+	return 1;
+}
+
+static s32 Download(DOWNLOADS download_number)  {
+	ClearScreen();
+	
+	int line = 1;
+	int ret;
+	u32 http_status = 0;
+	u8* outbuf = NULL;
+	u32 filesize;
+	char filepath[MAXPATHLEN];
+	FILE *file;
+	bool dir_argument_exists = strlen(launch_dir);
+	snprintf(filepath, sizeof(filepath), "%s%s", dir_argument_exists ? launch_dir : "/apps/Nintendont/", Downloads[download_number].filename);
+	if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[download_number].text);}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[download_number].text);}
+	UpdateScreen();
+	
+	line++;
+	gprintf("Downloading %s to %s\r\n", Downloads[download_number].url, filepath);
+	ret = net_init();
+	if(ret < 0) {
+		gprintf("Failed to init network\r\n");
+		goto end;
+	}
+	gprintf("Network Initialized\r\n");
+	if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Network Initialized");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Network Initialized");}
+	UpdateScreen();
+	
+	int i;
+	for (i = 0; i <= 10; i++) {
+		ret = http_request(Downloads[download_number].url, Downloads[download_number].max_size);
+		if (ret) break;
+		if (i == 10) {
+			gprintf("Error making http request\r\n");
+			ret = -1;
+			goto end;
+		}
+	}
+
+	ret = http_get_result(&http_status, &outbuf, &filesize); 
+	if(((int)*outbuf & 0xF0000000) == 0xF0000000) 
+	{
+		ret = -2;
+		goto end;
+	}
+
+	UpdateScreen();
+	line++;
+	if (!dir_argument_exists) {
+		gprintf("Creating new directory\r\n");
+		mkdir("/apps/Nintendont", S_IWRITE|S_IREAD);
+	}
+	file = fopen(filepath, "wb");
+	if(!file)
+	{
+		gprintf("File Error\r\n");
+		ret = -3;
+		goto end;
+	} else {
+		fwrite(outbuf, filesize, 1, file);
+		fclose(file);
+		if (download_number == DOWNLOAD_THEMES) ret = UnzipThemes(filepath);
+		if (download_number == DOWNLOAD_CLASSIC) ret = UnzipClassic(filepath);
+		if (download_number == DOWNLOAD_CLASSICWII) ret = UnzipClassicwii(filepath);
+		if (download_number == DOWNLOAD_DISCS) ret = UnzipDiscs(filepath);
+		if (download_number == DOWNLOAD_GCNS) ret = UnzipGcns(filepath);
+		if (download_number == DOWNLOAD_MMBLUE) ret = UnzipMmblue(filepath);
+		if (download_number == DOWNLOAD_MMCLASSIC) ret = UnzipMmclassic(filepath);
+		if (download_number == DOWNLOAD_MMDARK1) ret = UnzipMmdark1(filepath);
+		if (download_number == DOWNLOAD_MMDARK2) ret = UnzipMmdark2(filepath);
+		if (download_number == DOWNLOAD_ORANGE) ret = UnzipOrange(filepath);
+		if (download_number == DOWNLOAD_PURPLE) ret = UnzipPurple(filepath);
+		if (download_number == DOWNLOAD_SMASH) ret = UnzipSmash(filepath);
+		if (download_number == DOWNLOAD_BARS) ret = UnzipBars(filepath);
+		if (download_number == DOWNLOAD_AAA) ret = UnzipAaa(filepath);
+		if (download_number == DOWNLOAD_BBB) ret = UnzipBbb(filepath);
+		if (download_number == DOWNLOAD_CCC) ret = UnzipCcc(filepath);		
+		if (ret == 1) {
+		if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*(line), "Update Complete");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*(line), "Update Complete");}
+			UpdateScreen();
+			line++;
+		}
+	}
+
+end:
+	if (ret != 1)
+		{
+			if (which_bg == BG_NONE)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*(line+1), "Update Error: %i", ret);
+			else if (which_bg == BG_LEGACY)
+			PrintFormat(DEFAULT_SIZE, YELLOW, MENU_POS_X, MENU_POS_Y + 20*(line+1), "Update Error: %i", ret);
+			rename( "./NinBack.old", "./NinBack.png");
+			rename( "./NinBlack.old", "./NinBlack.png");
+			rename( "./NinLegacy.old", "./NinLegacy.png");
+			UpdateScreen();
+			if (outbuf != NULL) free(outbuf);
+			net_deinit();
+			sleep(2);
+			return ret;
+		}
+	else {
+	if (which_bg == BG_NONE)
+	{PrintFormat(37, 0x80000000, MENU_POS_X, MENU_POS_Y + 20*(line+15), "Applying The New Theme Now");}
+	else if (which_bg == BG_LEGACY)
+	{PrintFormat(37, WHITE, MENU_POS_X, MENU_POS_Y + 20*(line+15), "Applying The New Theme Now");}}
+	UpdateScreen();
+	if (outbuf != NULL) free(outbuf);
+	net_deinit();
+	sleep(2);
+	BackTheme();
+	return ret;
+}
+
+void UpdateGrad(void) {
+	int selected = 0;
+	u64 delay = ticks_to_millisecs(gettime()) + 500;
+	while(true) {
+		ClearScreen();
+		BackTheme();
+		if (which_bg == BG_NONE)
+					{		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");	
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*2, "Gradient Themes Download Menu");	
+		PrintFormat(15, BLACK, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");	
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Download Amazon Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Download Forest Sun Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Download Blue Dream Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Download Rainbow Theme");		
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Download Sandy Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*9, "Download Golden Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*10, "Download Paradise Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*11, "Download Pharao Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*12, "Download No Fear Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*13, "Download Magic Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*14, "Download Mighty Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*15, "Download Greenies Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*16, "Download Focus Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*17, "Download Highlight Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*18, "Download No return Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*19, "Download Zombie Theme");		
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+					else if (which_bg == BG_LEGACY)
+					{		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");	
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*2, "Gradient Themes Download Menu");	
+		PrintFormat(15, WHITE, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");	
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Download Amazon Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Download Forest Sun Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Download Blue Dream Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Download Rainbow Theme");		
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Download Sandy Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*9, "Download Golden Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*10, "Download Paradise Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*11, "Download Pharao Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*12, "Download No Fear Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*13, "Download Magic Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*14, "Download Mighty Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*15, "Download Greenies Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*16, "Download Focus Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*17, "Download Highlight Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*18, "Download No return Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*19, "Download Zombie Theme");		
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+
+		GRRLIB_Render();
+		FPAD_Update();
+		if (delay > ticks_to_millisecs(gettime())) continue;
+		if (FPAD_Start(1)) {
+			ClearScreen();
+			if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Returning to loader...");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, 212, 232, "Returning to loader...");}
+			ExitToLoader(0);
+		}
+			if (FPAD_OK(1)) {
+			if (selected <= (DOWNLOAD_CCC))
+			{
+			rename( "./NinBack.png", "./NinBack.old");
+			rename( "./NinBlack.png", "./NinBlack.old");
+			rename( "./NinLegacy.png", "./NinLegacy.old");
+			Download(selected);
+			remove( "./NinBack.old" );
+			remove( "./NinBlack.old" );
+			remove( "./NinLegacy.old" );
+			BackTheme();
+			FadeIt();
+			}
+			else
+				break;
+		}
+		if (FPAD_Down(1)) {
+			delay = ticks_to_millisecs(gettime()) + 150;
+			selected++;
+			if (selected > 15) selected = 0;
+		}
+		if (FPAD_Up(1)) {
+			delay = ticks_to_millisecs(gettime()) + 150;
+			selected--;
+			if (selected < 0) selected = 15;
+		}
+		if(FPAD_Y(0)) {
+				Credits();
+		}
+		if (FPAD_Cancel(1)) {
+			break;
+		}
+	}
+	ClearScreen();
+	UpdateNintendont();
+}
Index: loader/source/update-light.c
===================================================================
--- loader/source/update-light.c	(revision 0)
+++ loader/source/update-light.c	(working copy)
@@ -0,0 +1,748 @@
+/*
+
+Nintendont (Loader) - Playing Gamecubes in Wii mode on a Wii U
+
+Copyright (C) 2014  JoostinOnline
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation version 2.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+
+*/
+
+#include <gccore.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <malloc.h>
+#include <network.h>
+#include <fat.h>
+#include <dirent.h>
+#include <zlib.h>
+#include <ogc/lwp_watchdog.h>
+
+#include "exi.h"
+#include "FPad.h"
+#include "font.h"
+#include "global.h"
+#include "http.h"
+#include "menu.h"
+#include "update.h"
+#include "unzip/miniunz.h"
+#include "../../common/include/NintendontVersion.h"
+
+extern char launch_dir[MAXPATHLEN];
+
+typedef struct {
+	const char url[96];
+	const char text[30];
+	const char filename[30];
+	const u32 max_size;
+} downloads_t;
+
+typedef enum {
+	DOWNLOAD_THEMES,
+	DOWNLOAD_CLASSIC,
+	DOWNLOAD_CLASSICWII,
+	DOWNLOAD_DISCS,
+	DOWNLOAD_GCNS,
+	DOWNLOAD_MMBLUE,
+	DOWNLOAD_MMCLASSIC,
+	DOWNLOAD_MMDARK1,
+	DOWNLOAD_MMDARK2,
+	DOWNLOAD_ORANGE,
+	DOWNLOAD_PURPLE,
+	DOWNLOAD_SMASH,
+	DOWNLOAD_BARS,
+	DOWNLOAD_AAA,
+	DOWNLOAD_BBB,
+	DOWNLOAD_CCC	
+} DOWNLOADS;
+
+static const downloads_t Downloads[] = {
+	{"http://178.33.61.6/putstorage/DownloadFileHash/AC7A305B3A5A4A5QQWE2739716EWQS/back00.zip", "Downloading Theme", "back00.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/677751093A5A4A5QQWE2739719EWQS/back01.zip", "Downloading Theme", "back01.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/0456E14A3A5A4A5QQWE2739718EWQS/back02.zip", "Downloading Theme", "back02.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/1EF5221C3A5A4A5QQWE2739723EWQS/back03.zip", "Downloading Theme", "back03.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/A8A5D4143A5A4A5QQWE2739724EWQS/back04.zip", "Downloading Theme", "back04.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/99A846AA3A5A4A5QQWE2739726EWQS/back05.zip", "Downloading Theme", "back05.zip", 0x80000}, // 512KB	
+	{"http://178.33.61.6/putstorage/DownloadFileHash/6D060A3D3A5A4A5QQWE2739727EWQS/back06.zip", "Downloading Theme", "back06.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/6F9EA46C3A5A4A5QQWE2739728EWQS/back07.zip", "Downloading Theme", "back07.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/73C45A193A5A4A5QQWE2739729EWQS/back08.zip", "Downloading Theme", "back08.zip", 0x80000}, // 512KB	
+	{"http://178.33.61.6/putstorage/DownloadFileHash/9BCEC21C3A5A4A5QQWE2740201EWQS/back09.zip", "Downloading Theme", "back09.zip", 0x80000}, // 512KB
+	{"http://37.59.32.139/putstorage/DownloadFileHash/6EE9B1493A5A4A5QQWE453028EWQS/back10.zip", "Downloading Theme", "back10.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/6AE4DC013A5A4A5QQWE2740203EWQS/back11.zip", "Downloading Theme", "back11.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/4C86F75A3A5A4A5QQWE2740204EWQS/back12.zip", "Downloading Theme", "back12.zip", 0x80000}, // 512KB	
+	{"http://178.33.61.6/putstorage/DownloadFileHash/B49B9BD53A5A4A5QQWE2740205EWQS/back13.zip", "Downloading Theme", "back13.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/F45054213A5A4A5QQWE2740206EWQS/back14.zip", "Downloading Theme", "back14.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/1428ABDC3A5A4A5QQWE2740207EWQS/back15.zip", "Downloading Theme", "back15.zip", 0x80000}, // 512KB		
+};
+
+static int UnzipThemes(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_THEMES].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_THEMES].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_THEMES].filename);
+	return 1;
+}
+
+static int UnzipClassic(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_CLASSIC].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_CLASSIC].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_CLASSIC].filename);
+	return 1;
+}
+
+static int UnzipClassicwii(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_CLASSICWII].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_CLASSICWII].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_CLASSICWII].filename);
+	return 1;
+}
+
+static int UnzipDiscs(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_DISCS].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_DISCS].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_DISCS].filename);
+	return 1;
+}
+
+static int UnzipGcns(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_GCNS].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_GCNS].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_GCNS].filename);
+	return 1;
+}
+
+static int UnzipMmblue(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_MMBLUE].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_MMBLUE].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_MMBLUE].filename);
+	return 1;
+}
+
+static int UnzipMmclassic(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_MMCLASSIC].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_MMCLASSIC].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_MMCLASSIC].filename);
+	return 1;
+}
+
+static int UnzipMmdark1(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_MMDARK1].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_MMDARK1].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_MMDARK1].filename);
+	return 1;
+}
+
+static int UnzipMmdark2(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_MMDARK2].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_MMDARK2].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_MMDARK2].filename);
+	return 1;
+}
+
+static int UnzipOrange(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_ORANGE].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_ORANGE].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_ORANGE].filename);
+	return 1;
+}
+
+static int UnzipPurple(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_PURPLE].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_PURPLE].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_PURPLE].filename);
+	return 1;
+}
+
+static int UnzipSmash(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_SMASH].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_SMASH].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_SMASH].filename);
+	return 1;
+}
+
+static int UnzipBars(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_BARS].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_BARS].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_BARS].filename);
+	return 1;
+}
+
+static int UnzipAaa(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_AAA].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_AAA].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_AAA].filename);
+	return 1;
+}
+
+static int UnzipBbb(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_BBB].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_BBB].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_BBB].filename);
+	return 1;
+}
+
+static int UnzipCcc(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_CCC].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_CCC].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_CCC].filename);
+	return 1;
+}
+
+static s32 Download(DOWNLOADS download_number)  {
+	ClearScreen();
+	
+	int line = 1;
+	int ret;
+	u32 http_status = 0;
+	u8* outbuf = NULL;
+	u32 filesize;
+	char filepath[MAXPATHLEN];
+	FILE *file;
+	bool dir_argument_exists = strlen(launch_dir);
+	snprintf(filepath, sizeof(filepath), "%s%s", dir_argument_exists ? launch_dir : "/apps/Nintendont/", Downloads[download_number].filename);
+	if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[download_number].text);}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[download_number].text);}
+	UpdateScreen();
+	
+	line++;
+	gprintf("Downloading %s to %s\r\n", Downloads[download_number].url, filepath);
+	ret = net_init();
+	if(ret < 0) {
+		gprintf("Failed to init network\r\n");
+		goto end;
+	}
+	gprintf("Network Initialized\r\n");
+	if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Network Initialized");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Network Initialized");}
+	UpdateScreen();
+	
+	int i;
+	for (i = 0; i <= 10; i++) {
+		ret = http_request(Downloads[download_number].url, Downloads[download_number].max_size);
+		if (ret) break;
+		if (i == 10) {
+			gprintf("Error making http request\r\n");
+			ret = -1;
+			goto end;
+		}
+	}
+
+	ret = http_get_result(&http_status, &outbuf, &filesize); 
+	if(((int)*outbuf & 0xF0000000) == 0xF0000000) 
+	{
+		ret = -2;
+		goto end;
+	}
+
+	UpdateScreen();
+	line++;
+	if (!dir_argument_exists) {
+		gprintf("Creating new directory\r\n");
+		mkdir("/apps/Nintendont", S_IWRITE|S_IREAD);
+	}
+	file = fopen(filepath, "wb");
+	if(!file)
+	{
+		gprintf("File Error\r\n");
+		ret = -3;
+		goto end;
+	} else {
+		fwrite(outbuf, filesize, 1, file);
+		fclose(file);
+		if (download_number == DOWNLOAD_THEMES) ret = UnzipThemes(filepath);
+		if (download_number == DOWNLOAD_CLASSIC) ret = UnzipClassic(filepath);
+		if (download_number == DOWNLOAD_CLASSICWII) ret = UnzipClassicwii(filepath);
+		if (download_number == DOWNLOAD_DISCS) ret = UnzipDiscs(filepath);
+		if (download_number == DOWNLOAD_GCNS) ret = UnzipGcns(filepath);
+		if (download_number == DOWNLOAD_MMBLUE) ret = UnzipMmblue(filepath);
+		if (download_number == DOWNLOAD_MMCLASSIC) ret = UnzipMmclassic(filepath);
+		if (download_number == DOWNLOAD_MMDARK1) ret = UnzipMmdark1(filepath);
+		if (download_number == DOWNLOAD_MMDARK2) ret = UnzipMmdark2(filepath);
+		if (download_number == DOWNLOAD_ORANGE) ret = UnzipOrange(filepath);
+		if (download_number == DOWNLOAD_PURPLE) ret = UnzipPurple(filepath);
+		if (download_number == DOWNLOAD_SMASH) ret = UnzipSmash(filepath);
+		if (download_number == DOWNLOAD_BARS) ret = UnzipBars(filepath);
+		if (download_number == DOWNLOAD_AAA) ret = UnzipAaa(filepath);
+		if (download_number == DOWNLOAD_BBB) ret = UnzipBbb(filepath);
+		if (download_number == DOWNLOAD_CCC) ret = UnzipCcc(filepath);		
+		if (ret == 1) {
+		if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*(line), "Update Complete");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*(line), "Update Complete");}
+			UpdateScreen();
+			line++;
+		}
+	}
+
+end:
+	if (ret != 1)
+		{
+			if (which_bg == BG_NONE)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*(line+1), "Update Error: %i", ret);
+			else if (which_bg == BG_LEGACY)
+			PrintFormat(DEFAULT_SIZE, YELLOW, MENU_POS_X, MENU_POS_Y + 20*(line+1), "Update Error: %i", ret);
+			rename( "./NinBack.old", "./NinBack.png");
+			rename( "./NinBlack.old", "./NinBlack.png");
+			rename( "./NinLegacy.old", "./NinLegacy.png");
+			UpdateScreen();
+			if (outbuf != NULL) free(outbuf);
+			net_deinit();
+			sleep(2);
+			return ret;
+		}
+	else {
+	if (which_bg == BG_NONE)
+	{PrintFormat(37, 0x80000000, MENU_POS_X, MENU_POS_Y + 20*(line+15), "Applying The New Theme Now");}
+	else if (which_bg == BG_LEGACY)
+	{PrintFormat(37, WHITE, MENU_POS_X, MENU_POS_Y + 20*(line+15), "Applying The New Theme Now");}}
+	UpdateScreen();
+	if (outbuf != NULL) free(outbuf);
+	net_deinit();
+	sleep(2);
+	BackTheme();
+	return ret;
+}
+
+void UpdateThemes(void) {
+	int selected = 0;
+	u64 delay = ticks_to_millisecs(gettime()) + 500;
+	while(true) {
+		ClearScreen();
+		BackTheme();
+		if (which_bg == BG_NONE)
+					{		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");	
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*2, "Light Themes Download Menu");	
+		PrintFormat(15, BLACK, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");	
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Download Orchid Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Download Aqua Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Download Sunshine Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Download Shroom Theme");		
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Download Triforce Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*9, "Download GC Logo Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*10, "Download Rays Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*11, "Download Carbonix Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*12, "Download Arcadia Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*13, "Download Zelda OoT Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*14, "Download Double-Dash Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*15, "Download Bright Sky Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*16, "Download Wii Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*17, "Download Kirby Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*18, "Download Controller Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*19, "Download Luigi Theme");		
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+					else if (which_bg == BG_LEGACY)
+					{		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");	
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*2, "Light Themes Download Menu");	
+		PrintFormat(15, WHITE, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");	
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Download Orchid Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Download Aqua Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Download Sunshine Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Download Shroom Theme");		
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Download Triforce Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*9, "Download GC Logo Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*10, "Download Rays Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*11, "Download Carbonix Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*12, "Download Arcadia Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*13, "Download Zelda OoT Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*14, "Download Double-Dash Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*15, "Download Bright Sky Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*16, "Download Wii Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*17, "Download Kirby Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*18, "Download Controller Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*19, "Download Luigi Theme");		
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+
+		GRRLIB_Render();
+		FPAD_Update();
+		if (delay > ticks_to_millisecs(gettime())) continue;
+		if (FPAD_Start(1)) {
+			ClearScreen();
+			if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Returning to loader...");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, 212, 232, "Returning to loader...");}
+			ExitToLoader(0);
+		}
+			if (FPAD_OK(1)) {
+			if (selected <= (DOWNLOAD_CCC))
+			{
+			rename( "./NinBack.png", "./NinBack.old");
+			rename( "./NinBlack.png", "./NinBlack.old");
+			rename( "./NinLegacy.png", "./NinLegacy.old");
+			Download(selected);
+			remove( "./NinBack.old" );
+			remove( "./NinBlack.old" );
+			remove( "./NinLegacy.old" );
+			GRRLIB_FreeTexture(background);
+			which_bg = BG_NONE;
+			background = GRRLIB_LoadTextureFromFile("NinBack.png");	
+			if (background == NULL)
+			background = GRRLIB_LoadTexturePNG(background_png);
+			FadeIt();
+			}
+			else
+				break;
+		}
+		if (FPAD_Down(1)) {
+			delay = ticks_to_millisecs(gettime()) + 150;
+			selected++;
+			if (selected > 15) selected = 0;
+		}
+		if (FPAD_Up(1)) {
+			delay = ticks_to_millisecs(gettime()) + 150;
+			selected--;
+			if (selected < 0) selected = 15;
+		}
+		if(FPAD_Y(0)) {
+				Credits();
+		}
+		if (FPAD_Cancel(1)) {
+			break;
+		}
+	}
+	ClearScreen();
+	UpdateNintendont();
+}
Index: loader/source/update-loader.c
===================================================================
--- loader/source/update-loader.c	(revision 0)
+++ loader/source/update-loader.c	(working copy)
@@ -0,0 +1,800 @@
+/*
+
+Nintendont (Loader) - Playing Gamecubes in Wii mode on a Wii U
+
+Copyright (C) 2014  JoostinOnline
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation version 2.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+
+*/
+
+#include <gccore.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <malloc.h>
+#include <network.h>
+#include <fat.h>
+#include <dirent.h>
+#include <zlib.h>
+#include <ogc/lwp_watchdog.h>
+
+#include "exi.h"
+#include "FPad.h"
+#include "font.h"
+#include "global.h"
+#include "http.h"
+#include "menu.h"
+#include "update.h"
+#include "unzip/miniunz.h"
+#include "../../common/include/NintendontVersion.h"
+
+extern char launch_dir[MAXPATHLEN];
+typedef struct {
+	const char url[96];
+	const char text[30];
+	const char filename[30];
+	const u32 max_size;
+} downloads_t;
+
+typedef enum {
+	DOWNLOAD_THEMES,
+	DOWNLOAD_CLASSIC,
+	DOWNLOAD_CLASSICWII,
+	DOWNLOAD_DISCS,
+	DOWNLOAD_GCNS,
+	DOWNLOAD_MMBLUE,
+	DOWNLOAD_MMCLASSIC,
+	DOWNLOAD_MMDARK1,
+	DOWNLOAD_MMDARK2,
+	DOWNLOAD_ORANGE,
+	DOWNLOAD_PURPLE,
+	DOWNLOAD_SMASH,
+	DOWNLOAD_AAA,
+	DOWNLOAD_BBB,
+	DOWNLOAD_CCC,
+	DOWNLOAD_BARS	
+} DOWNLOADS;
+
+static const downloads_t Downloads[] = {
+	{"http://178.33.238.21/putstorage/DownloadFileHash/E950E3623A5A4A5QQWE865806EWQS/theme0.zip", "Downloading Theme", "theme0.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/FF27AAE53A5A4A5QQWE2740213EWQS/classic.zip", "Downloading Theme", "classic.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/81BD53833A5A4A5QQWE2740214EWQS/classicwii.zip", "Downloading Theme", "classicwii.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/18CD57D63A5A4A5QQWE2740217EWQS/discs.zip", "Downloading Theme", "discs.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/66C1CF1F3A5A4A5QQWE2740218EWQS/gcns.zip", "Downloading Theme", "gcns.zip", 0x80000}, // 512KB
+	{"http://37.59.32.140/putstorage/DownloadFileHash/2D5CCDDE3A5A4A5QQWE432955EWQS/mmblue.zip", "Downloading Theme", "mmblue.zip", 0x80000}, // 512KB	
+	{"http://178.33.61.6/putstorage/DownloadFileHash/0A71C2DB3A5A4A5QQWE2740285EWQS/mmclassic.zip", "Downloading Theme", "mmclassic.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/0CE7A0C23A5A4A5QQWE2740286EWQS/mmdark1.zip", "Downloading Theme", "mmdark1.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/1B28B6643A5A4A5QQWE2740287EWQS/mmdark2.zip", "Downloading Theme", "mmdark2.zip", 0x80000}, // 512KB	
+	{"http://5.39.65.102/putstorage/DownloadFileHash/323155353A5A4A5QQWE774715EWQS/orange.zip", "Downloading Theme", "orange.zip", 0x80000}, // 512KB
+	{"http://178.33.232.54/putstorage/DownloadFileHash/4FD5A0B03A5A4A5QQWE492298EWQS/purple.zip", "Downloading Theme", "purple.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/099D84233A5A4A5QQWE2740312EWQS/smash.zip", "Downloading Theme", "smash.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/ED286C483A5A4A5QQWE2739715EWQS/aaa.zip", "Downloading Theme", "aaa.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/C7EC23A73A5A4A5QQWE2740210EWQS/bbb.zip", "Downloading Theme", "bbb.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/8480B5633A5A4A5QQWE2740212EWQS/ccc.zip", "Downloading Theme", "ccc.zip", 0x80000}, // 512KB
+	{"http://178.33.61.6/putstorage/DownloadFileHash/7C50C2913A5A4A5QQWE2740209EWQS/bars.zip", "Downloading Theme", "bars.zip", 0x80000}, // 512KB	
+};
+
+static int UnzipThemes(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_THEMES].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_THEMES].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_THEMES].filename);
+	return 1;
+}
+
+static int UnzipClassic(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_CLASSIC].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_CLASSIC].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_CLASSIC].filename);
+	return 1;
+}
+
+static int UnzipClassicwii(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_CLASSICWII].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_CLASSICWII].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_CLASSICWII].filename);
+	return 1;
+}
+
+static int UnzipDiscs(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_DISCS].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_DISCS].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_DISCS].filename);
+	return 1;
+}
+
+static int UnzipGcns(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_GCNS].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_GCNS].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_GCNS].filename);
+	return 1;
+}
+
+static int UnzipMmblue(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_MMBLUE].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_MMBLUE].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_MMBLUE].filename);
+	return 1;
+}
+
+static int UnzipMmclassic(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_MMCLASSIC].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_MMCLASSIC].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_MMCLASSIC].filename);
+	return 1;
+}
+
+static int UnzipMmdark1(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_MMDARK1].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_MMDARK1].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_MMDARK1].filename);
+	return 1;
+}
+
+static int UnzipMmdark2(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_MMDARK2].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_MMDARK2].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_MMDARK2].filename);
+	return 1;
+}
+
+static int UnzipOrange(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_ORANGE].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_ORANGE].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_ORANGE].filename);
+	return 1;
+}
+
+static int UnzipPurple(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_PURPLE].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_PURPLE].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_PURPLE].filename);
+	return 1;
+}
+
+static int UnzipSmash(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_SMASH].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_SMASH].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_SMASH].filename);
+	return 1;
+}
+
+static int UnzipAaa(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_AAA].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_AAA].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_AAA].filename);
+	return 1;
+}
+
+static int UnzipBbb(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_BBB].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_BBB].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_BBB].filename);
+	return 1;
+}
+
+static int UnzipCcc(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_CCC].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_CCC].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_CCC].filename);
+	return 1;
+}
+
+static int UnzipBars(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_BARS].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_BARS].filename);
+	
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_BARS].filename);
+	return 1;
+}
+
+static s32 Download(DOWNLOADS download_number)  {
+	ClearScreen();
+	
+	int line = 1;
+	int ret;
+	u32 http_status = 0;
+	u8* outbuf = NULL;
+	u32 filesize;
+	char filepath[MAXPATHLEN];
+	FILE *file;
+	bool dir_argument_exists = strlen(launch_dir);
+	snprintf(filepath, sizeof(filepath), "%s%s", dir_argument_exists ? launch_dir : "/apps/Nintendont/", Downloads[download_number].filename);
+						if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[download_number].text);}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[download_number].text);}
+	UpdateScreen();
+	
+	line++;
+	gprintf("Downloading %s to %s\r\n", Downloads[download_number].url, filepath);
+	ret = net_init();
+	if(ret < 0) {
+		gprintf("Failed to init network\r\n");
+		goto end;
+	}
+	gprintf("Network Initialized\r\n");
+	if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Network Initialized");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Network Initialized");}
+	UpdateScreen();
+	
+	int i;
+	for (i = 0; i <= 10; i++) {
+		ret = http_request(Downloads[download_number].url, Downloads[download_number].max_size);
+		if (ret) break;
+		if (i == 10) {
+			gprintf("Error making http request\r\n");
+			ret = -1;
+			goto end;
+		}
+	}
+
+	ret = http_get_result(&http_status, &outbuf, &filesize); 
+	if(((int)*outbuf & 0xF0000000) == 0xF0000000) 
+	{
+		ret = -2;
+		goto end;
+	}
+	UpdateScreen();
+	line++;
+	if (!dir_argument_exists) {
+		gprintf("Creating new directory\r\n");
+		mkdir("/apps/Nintendont", S_IWRITE|S_IREAD);
+	}
+	file = fopen(filepath, "wb");
+	if(!file)
+	{
+		gprintf("File Error\r\n");
+		ret = -3;
+		goto end;
+	} else {
+		fwrite(outbuf, filesize, 1, file);
+		fclose(file);
+		if (download_number == DOWNLOAD_THEMES) ret = UnzipThemes(filepath);
+		if (download_number == DOWNLOAD_CLASSIC) ret = UnzipClassic(filepath);
+		if (download_number == DOWNLOAD_CLASSICWII) ret = UnzipClassicwii(filepath);
+		if (download_number == DOWNLOAD_DISCS) ret = UnzipDiscs(filepath);
+		if (download_number == DOWNLOAD_GCNS) ret = UnzipGcns(filepath);
+		if (download_number == DOWNLOAD_MMBLUE) ret = UnzipMmblue(filepath);
+		if (download_number == DOWNLOAD_MMCLASSIC) ret = UnzipMmclassic(filepath);
+		if (download_number == DOWNLOAD_MMDARK1) ret = UnzipMmdark1(filepath);
+		if (download_number == DOWNLOAD_MMDARK2) ret = UnzipMmdark2(filepath);
+		if (download_number == DOWNLOAD_ORANGE) ret = UnzipOrange(filepath);
+		if (download_number == DOWNLOAD_PURPLE) ret = UnzipPurple(filepath);
+		if (download_number == DOWNLOAD_SMASH) ret = UnzipSmash(filepath);
+		if (download_number == DOWNLOAD_AAA) ret = UnzipAaa(filepath);
+		if (download_number == DOWNLOAD_BBB) ret = UnzipBbb(filepath);
+		if (download_number == DOWNLOAD_CCC) ret = UnzipCcc(filepath);
+		if (download_number == DOWNLOAD_BARS) ret = UnzipBars(filepath);
+		if (ret == 1) {
+	if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Update Complete");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Update Complete");}		
+			UpdateScreen();
+			line++;
+		}
+	}
+end:
+	if (ret != 1)
+		{
+			if (which_bg == BG_NONE)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*(line+1), "Update Error: %i", ret);
+			else if (which_bg == BG_LEGACY)
+			PrintFormat(DEFAULT_SIZE, YELLOW, MENU_POS_X, MENU_POS_Y + 20*(line+1), "Update Error: %i", ret);
+			rename( "./NinBackLight.old", "./NinBackLight.png");
+			rename( "./NinBackDark.old", "./NinBackDark.png");
+			rename( "./NinBackBars.old", "./NinBackBars.png");
+			rename( "./NinBackNoBar.old", "./NinBackNoBar.png");
+			rename( "./NinBlack.old", "./NinBlack.png");
+			UpdateScreen();
+			if (outbuf != NULL) free(outbuf);
+			net_deinit();
+			sleep (2);	
+			return ret;
+		}
+	else
+		if (which_bg == BG_NONE)
+					{		PrintFormat(27, 0x80000000, MENU_POS_X + 130, MENU_POS_Y + 20*(line+4), "Autoboot Nintendont ");
+		PrintFormat(27, 0x80000000, MENU_POS_X + 135, MENU_POS_Y + 20*(line+6), "Using a USB Loader");	
+		PrintFormat(27, 0x80000000, MENU_POS_X + 125, MENU_POS_Y + 20*(line+8), "To Use The New Theme");			
+		PrintFormat(27, 0x80000000, MENU_POS_X, MENU_POS_Y + 20*(line+15), "You'll Watch a 3 Seconds Preview Now");}
+					else if (which_bg == BG_LEGACY)
+					{		PrintFormat(27, WHITE, MENU_POS_X + 130, MENU_POS_Y + 20*(line+4), "Autoboot Nintendont ");
+		PrintFormat(27, WHITE, MENU_POS_X + 135, MENU_POS_Y + 20*(line+6), "Using a USB Loader");	
+		PrintFormat(27, WHITE, MENU_POS_X + 125, MENU_POS_Y + 20*(line+8), "To Use The New Theme");			
+		PrintFormat(27, WHITE, MENU_POS_X, MENU_POS_Y + 20*(line+15), "You'll Watch a 3 Seconds Preview Now");}		
+	UpdateScreen();
+	if (outbuf != NULL) free(outbuf);
+	net_deinit();
+	sleep (3);		
+		background = GRRLIB_LoadTextureFromFile("NinBackLight.png");
+		if (background != NULL)
+		{
+		ClearScreen();
+		PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 50*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88 ");
+		PrintFormat(DEFAULT_SIZE, 0x45587C00, MENU_POS_X + 50*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88 ");
+		UpdateScreen();
+		sleep(3);
+		background = GRRLIB_LoadTextureFromFile("NinBack.png");	
+		if (background == NULL)
+		background = GRRLIB_LoadTexturePNG(background_png);
+			goto endy;		
+		}
+		else background = GRRLIB_LoadTextureFromFile("NinBackDark.png");
+		if (background != NULL)
+		{
+		ClearScreen();
+		PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 50*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88 ");
+		PrintFormat(DEFAULT_SIZE, 0xC0C0C000, MENU_POS_X + 50*1, MENU_POS_Y + 20*19, "\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88 ");
+		UpdateScreen();
+		sleep(3);
+		background = GRRLIB_LoadTextureFromFile("NinBack.png");	
+		if (background == NULL)
+		background = GRRLIB_LoadTexturePNG(background_png);			
+			goto endy;		
+		}
+		else background = GRRLIB_LoadTextureFromFile("NinBackBars.png");
+		if (background != NULL)
+		{
+		ClearScreen();
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83 ");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50*1, MENU_POS_Y + 20*19, "\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83\xe2\x95\x83 ");
+		UpdateScreen();
+		sleep(3);
+		background = GRRLIB_LoadTextureFromFile("NinBack.png");	
+		if (background == NULL)
+		background = GRRLIB_LoadTexturePNG(background_png);
+			goto endy;		
+		}
+		else background = GRRLIB_LoadTextureFromFile("NinBackNoBar.png");
+		if (background != NULL)
+		{
+		ClearScreen();
+		UpdateScreen();
+		sleep(3);
+		background = GRRLIB_LoadTextureFromFile("NinBack.png");	
+		if (background == NULL)
+		background = GRRLIB_LoadTexturePNG(background_png);
+			goto endy;		
+		}
+		endy:
+			return ret;}
+
+void UpdateLoader(void) {
+	int selected = 0;
+	u64 delay = ticks_to_millisecs(gettime()) + 500;
+	while(true) {
+		ClearScreen();
+		BackTheme();
+			if (which_bg == BG_NONE)
+					{		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*2, "Loader Themes Download Menu");		
+		PrintFormat(15, BLACK, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");		
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Download Controller Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Download Classic Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Download Wanna-Play Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Download Warning Theme");		
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Download GameCubes Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*9, "Download MasterMod Blue Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*10, "Download MasterMod Classic Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*11, "Download MasterMod Dark Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*12, "Download Mario Link Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*13, "Download Kids Power Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*14, "Download Purple Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*15, "Download Carbonix Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*16, "Download Sexy Black Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*17, "Download GC Controller Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*18, "Download Rainbow Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*19, "Download Mr Luigi Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+					else if (which_bg == BG_LEGACY)
+					{		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*2, "Loader Themes Download Menu");
+		PrintFormat(15, WHITE, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");	
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Download Controller Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Download Classic Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Download Wanna-Play Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Download Warning Theme");		
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Download GameCubes Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*9, "Download MasterMod Blue Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*10, "Download MasterMod Classic Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*11, "Download MasterMod Dark Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*12, "Download Mario Link Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*13, "Download Kids Power Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*14, "Download Purple Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*15, "Download Carbonix Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*16, "Download Sexy Black Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*17, "Download GC Controller Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*18, "Download Rainbow Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*19, "Download Mr Luigi Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+		GRRLIB_Render();
+		FPAD_Update();
+		if (delay > ticks_to_millisecs(gettime())) continue;
+		if (FPAD_Start(1)) {
+			ClearScreen();
+				if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Returning to loader...");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, 212, 232, "Returning to loader...");}
+			ExitToLoader(0);
+		}
+			if (FPAD_OK(1)) {
+			if (selected <= (DOWNLOAD_BARS))
+		{
+			rename( "./NinBackLight.png", "./NinBackLight.old");
+			rename( "./NinBackDark.png", "./NinBackDark.old");
+			rename( "./NinBackBars.png", "./NinBackBars.old");
+			rename( "./NinBackNoBar.png", "./NinBackNoBar.old");
+			rename( "./NinBlack.png", "./NinBlack.old");
+			Download(selected);
+			remove( "./NinBackLight.old" );
+			remove( "./NinBackDark.old" );
+			remove( "./NinBackBars.old" );
+			remove( "./NinBackNoBar.old" );
+			remove( "./NinBlack.old" );		
+			BackTheme();
+			FadeIt();}
+		else
+			break;
+		}
+		if (FPAD_Down(1)) {
+			delay = ticks_to_millisecs(gettime()) + 150;
+			selected++;
+			if (selected > 15) selected = 0;
+		}
+		if (FPAD_Up(1)) {
+			delay = ticks_to_millisecs(gettime()) + 150;
+			selected--;
+			if (selected < 0) selected = 15;
+		}
+		if(FPAD_Y(0)) {
+				Credits();
+		}
+		if (FPAD_Cancel(1)) {
+			break;
+		}
+	}
+	ClearScreen();
+	UpdateNintendont();
+}
\ No newline at end of file
Index: loader/source/update-old.c
===================================================================
--- loader/source/update-old.c	(revision 0)
+++ loader/source/update-old.c	(working copy)
@@ -0,0 +1,400 @@
+/*
+
+Nintendont (Loader) - Playing Gamecubes in Wii mode on a Wii U
+
+Copyright (C) 2014  JoostinOnline
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation version 2.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+
+*/
+
+#include <gccore.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <malloc.h>
+#include <network.h>
+#include <fat.h>
+#include <dirent.h>
+#include <zlib.h>
+#include <ogc/lwp_watchdog.h>
+
+#include "exi.h"
+#include "FPad.h"
+#include "font.h"
+#include "global.h"
+#include "http.h"
+#include "menu.h"
+#include "update.h"
+#include "unzip/miniunz.h"
+#include "../../common/include/NintendontVersion.h"
+
+extern char launch_dir[MAXPATHLEN];
+
+typedef struct {
+	const char url[96];
+	const char text[30];
+	const char filename[30];
+	const u32 max_size;
+} downloads_t;
+
+typedef enum {
+	DOWNLOAD_DS2,
+	DOWNLOAD_DS4,
+	DOWNLOAD_DSS,
+	DOWNLOAD_DS3,
+	DOWNLOAD_STABLE,
+	DOWNLOAD_INITDI	
+} DOWNLOADS;
+
+static const downloads_t Downloads[] = {
+	{"http://178.33.63.68/putstorage/DownloadFileHash/3814BE6D3A5A4A5QQWE1488600EWQS/353.zip", "Downloading Nintendont v3.353", "353.zip", 0x400000}, // 4MB	
+	{"http://178.33.61.6/putstorage/DownloadFileHash/E2EC0F813A5A4A5QQWE2739446EWQS/321.zip", "Downloading Nintendont v3.321", "321.zip", 0x400000}, // 4MB	
+	{"http://178.33.61.6/putstorage/DownloadFileHash/16DBEC413A5A4A5QQWE2739365EWQS/319.zip", "Downloading Nintendont v3.319", "319.zip", 0x400000}, // 4MB		
+	{"http://178.33.61.6/putstorage/DownloadFileHash/80CCC36C3A5A4A5QQWE2739362EWQS/296.zip", "Downloading Nintendont v2.296", "296.zip", 0x400000}, // 4MB	
+	{"http://178.33.239.175/putstorage/DownloadFileHash/F4084A233A5A4A5QQWE426537EWQS/stable.zip", "Downloading Nintendont v2.275", "stable.zip", 0x400000}, // 4MB	
+	{"http://178.33.61.6/putstorage/DownloadFileHash/6A36D81B3A5A4A5QQWE2739352EWQS/229.zip", "Downloading Nintendont v2.229", "229.zip", 0x400000}, // 4MB	
+};
+
+static int UnzipDs2(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_DS2].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_DS2].filename);
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_DS2].filename);
+	return 1;
+}
+
+static int UnzipDs4(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_DS4].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_DS4].filename);
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_DS4].filename);
+	return 1;
+}
+
+static int UnzipDss(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_DSS].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_DSS].filename);
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_DSS].filename);
+	return 1;
+}
+
+static int UnzipDs3(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_DS3].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_DS3].filename);
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_DS3].filename);
+	return 1;
+}
+
+static int UnzipStable(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_STABLE].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_STABLE].filename);
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_STABLE].filename);
+	return 1;
+}
+
+static int UnzipInitdi(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_INITDI].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_INITDI].filename);
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_INITDI].filename);
+	return 1;
+}
+
+static s32 Download(DOWNLOADS download_number)  {
+	ClearScreen();
+	
+	int line = 1;
+	int ret;
+	u32 http_status = 0;
+	u8* outbuf = NULL;
+	u32 filesize;
+	char filepath[MAXPATHLEN];
+	FILE *file;
+	bool dir_argument_exists = strlen(launch_dir);
+	snprintf(filepath, sizeof(filepath), "%s%s", dir_argument_exists ? launch_dir : "/apps/Nintendont/", Downloads[download_number].filename);
+				if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[download_number].text);}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[download_number].text);}
+	UpdateScreen();
+	
+	line++;
+	gprintf("Downloading %s to %s\r\n", Downloads[download_number].url, filepath);
+	ret = net_init();
+	if(ret < 0) {
+		gprintf("Failed to init network\r\n");
+		goto end;
+	}
+	gprintf("Network Initialized\r\n");
+				if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Network Initialized");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Network Initialized");}
+	UpdateScreen();
+	
+	int i;
+	for (i = 0; i <= 10; i++) {
+		ret = http_request(Downloads[download_number].url, Downloads[download_number].max_size);
+		if (ret) break;
+		if (i == 10) {
+			gprintf("Error making http request\r\n");
+			ret = -1;
+			goto end;
+		}
+	}
+
+	ret = http_get_result(&http_status, &outbuf, &filesize); 
+	if(((int)*outbuf & 0xF0000000) == 0xF0000000) 
+	{
+		ret = -2;
+		goto end;
+	}
+	UpdateScreen();
+	line++;
+	if (!dir_argument_exists) {
+		gprintf("Creating new directory\r\n");
+		mkdir("/apps/Nintendont", S_IWRITE|S_IREAD);
+	}
+	file = fopen(filepath, "wb");
+	if(!file)
+	{
+		gprintf("File Error\r\n");
+		ret = -3;
+		goto end;
+	} else {
+		fwrite(outbuf, filesize, 1, file);
+		fclose(file);
+		if (download_number == DOWNLOAD_DS2) ret = UnzipDs2(filepath);
+		if (download_number == DOWNLOAD_DS4) ret = UnzipDs4(filepath);
+		if (download_number == DOWNLOAD_DSS) ret = UnzipDss(filepath);		
+		if (download_number == DOWNLOAD_DS3) ret = UnzipDs3(filepath);
+		if (download_number == DOWNLOAD_STABLE) ret = UnzipStable(filepath);
+		if (download_number == DOWNLOAD_INITDI) ret = UnzipInitdi(filepath);	
+		if (ret == 1) {
+					if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*(line), "Update Complete");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*(line), "Update Complete");}
+			UpdateScreen();
+			line++;
+		}
+	}
+
+end:
+	if (ret != 1)
+		{
+			if (which_bg == BG_NONE)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*(line+1), "Update Error: %i", ret);
+			else if (which_bg == BG_LEGACY)
+			PrintFormat(DEFAULT_SIZE, YELLOW, MENU_POS_X, MENU_POS_Y + 20*(line+1), "Update Error: %i", ret);
+
+		}
+	else
+	{									if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Restart Nintendont to complete update");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Restart Nintendont to complete update");}}
+	UpdateScreen();
+	if (outbuf != NULL) free(outbuf);
+	net_deinit();
+	sleep(3);
+	BackTheme();
+	return ret;
+}
+
+void UpdateOld(void) {
+	int selected = 0;
+	u64 delay = ticks_to_millisecs(gettime()) + 500;
+	while(true) {
+		ClearScreen();
+					if (which_bg == BG_NONE)
+					{		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*2, "Older Nintendont Download Menu");	
+		PrintFormat(15, BLACK, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");			
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Download Nintendont MasterMod (v3.353)");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Download Nintendont MasterMod (v3.321)");	
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Download Nintendont MasterMod (v3.319)");			
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Download Nintendont MasterMod (v2.296)");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Download Nintendont MasterMod (v2.275)");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*9, "Download Nintendont MasterMod (v2.229)");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*10, "Return to Update Menu");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+					else if (which_bg == BG_LEGACY)
+					{		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");	
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*2, "Older Nintendont Download Menu");	
+		PrintFormat(15, WHITE, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");	
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Download Nintendont MasterMod (v3.353)");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Download Nintendont MasterMod (v3.321)");	
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Download Nintendont MasterMod (v3.319)");			
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Download Nintendont MasterMod (v2.296)");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Download Nintendont MasterMod (v2.275)");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*9, "Download Nintendont MasterMod (v2.229)");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*10, "Return to Update Menu");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+		GRRLIB_Render();
+		FPAD_Update();
+		if (delay > ticks_to_millisecs(gettime())) continue;
+		if (FPAD_Start(1)) {
+			ClearScreen();
+						if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Returning to loader...");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, 212, 232, "Returning to loader...");}
+			ExitToLoader(0);
+		}
+			if (FPAD_OK(1)) {
+			if (selected <= (DOWNLOAD_INITDI))
+			Download(selected);
+			else
+				break;
+		}
+		if (FPAD_Down(1)) {
+			delay = ticks_to_millisecs(gettime()) + 150;
+			selected++;
+			if (selected > 6) selected = 0;
+		}
+		if (FPAD_Up(1)) {
+			delay = ticks_to_millisecs(gettime()) + 150;
+			selected--;
+			if (selected < 0) selected = 6;
+		}
+		if(FPAD_Y(0)) {
+				Credits();
+		}	
+		if (FPAD_Cancel(1)) {
+			break;
+		}
+	}
+	ClearScreen();
+	UpdateNintendont();
+}
Index: loader/source/update-simple.c
===================================================================
--- loader/source/update-simple.c	(revision 0)
+++ loader/source/update-simple.c	(working copy)
@@ -0,0 +1,355 @@
+/*
+
+Nintendont (Loader) - Playing Gamecubes in Wii mode on a Wii U
+
+Copyright (C) 2014  JoostinOnline
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation version 2.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+
+*/
+
+#include <gccore.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <malloc.h>
+#include <network.h>
+#include <fat.h>
+#include <dirent.h>
+#include <zlib.h>
+#include <ogc/lwp_watchdog.h>
+
+#include "exi.h"
+#include "FPad.h"
+#include "font.h"
+#include "global.h"
+#include "http.h"
+#include "menu.h"
+#include "update.h"
+#include "unzip/miniunz.h"
+#include "../../common/include/NintendontVersion.h"
+
+extern char launch_dir[MAXPATHLEN];
+
+typedef struct {
+	const char url[96];
+	const char text[30];
+	const char filename[30];
+	const u32 max_size;
+} downloads_t;
+
+typedef enum {
+	DOWNLOAD_01,
+	DOWNLOAD_02,
+	DOWNLOAD_03,
+	DOWNLOAD_04,
+	DOWNLOAD_05,
+	DOWNLOAD_06,
+	DOWNLOAD_07,
+	DOWNLOAD_08,
+	DOWNLOAD_09,
+	DOWNLOAD_10,
+	DOWNLOAD_11,
+	DOWNLOAD_12,
+	DOWNLOAD_13,
+	DOWNLOAD_14,
+	DOWNLOAD_15,
+	DOWNLOAD_16
+} DOWNLOADS;
+
+static const downloads_t Downloads[] = {
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB	
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB	
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB	
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB	
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"http://nintendont.gxarena.com/themes/NintendontVersion.h", "Checking Latest Version", "", 0x400} // 1KB
+};
+
+void SimpleBack(void) {
+	int selected = 0;
+	u64 delay = ticks_to_millisecs(gettime()) + 500;
+	while(true) {
+	end:
+		ClearScreen();
+		if (which_bg == BG_NONE)
+					{		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");	
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*2, "Simple Themes Menu");	
+		PrintFormat(15, BLACK, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");	
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Black Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Earth Blue Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Dark Forest Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Fire Brick Theme");		
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Dark Purple Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*9, "Midnight Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*10, "Greenish Blue Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*11, "Golden Dirt Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*12, "Blue Diamond Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*13, "Frog Green Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*14, "Bean Red Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*15, "Vanilla Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*16, "Mint Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*17, "Corn Yellow Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*18, "Silver Theme");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*19, "White Theme");		
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+					else if (which_bg == BG_LEGACY)
+					{		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");	
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*2, "Simple Themes Menu");		
+		PrintFormat(15, WHITE, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");	
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Black Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Earth Blue Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Dark Forest Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Fire Brick Theme");		
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Dark Purple Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*9, "Midnight Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*10, "Greenish Blue Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*11, "Golden Dirt Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*12, "Blue Diamond Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*13, "Frog Green Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*14, "Bean Red Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*15, "Vanilla Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*16, "Mint Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*17, "Corn Yellow Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*18, "Silver Theme");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*19, "White Theme");		
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+
+		GRRLIB_Render();
+		FPAD_Update();
+		if (delay > ticks_to_millisecs(gettime())) continue;
+		if (FPAD_Start(1)) {
+			ClearScreen();
+					if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Returning to loader...");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, 212, 232, "Returning to loader...");}
+			ExitToLoader(0);
+		}
+		if (FPAD_OK(1)) {
+			if (selected == (DOWNLOAD_01))
+			{remove( "./NinBack.png" );
+			remove( "./NinBlack.png" );
+			remove( "./NinLegacy.png" );
+			ClearScreen();	
+			GRRLIB_FillScreen (BLACK);
+			GRRLIB_FillScreen (BLACK);			
+			GRRLIB_ScrShot("./NinLegacy.png");
+			sleep (1);
+			BackTheme();
+			FadeIt();  goto end;}
+			if (selected == (DOWNLOAD_02))
+			{remove( "./NinBack.png" );
+			remove( "./NinBlack.png" );
+			remove( "./NinLegacy.png" );
+			ClearScreen();	
+			GRRLIB_FillScreen (BLUED);
+			GRRLIB_FillScreen (BLUED);			
+			GRRLIB_ScrShot("./NinLegacy.png");
+			sleep (1);
+			BackTheme();
+			FadeIt();  goto end;}
+			if (selected == (DOWNLOAD_03))
+			{remove( "./NinBack.png" );
+			remove( "./NinBlack.png" );
+			remove( "./NinLegacy.png" );
+			ClearScreen();	
+			GRRLIB_FillScreen (GREEND);
+			GRRLIB_FillScreen (GREEND);			
+			GRRLIB_ScrShot("./NinLegacy.png");
+			sleep (1);
+			BackTheme();
+			FadeIt();  goto end;}
+			if (selected == (DOWNLOAD_04)) 
+			{remove( "./NinBack.png" );
+			remove( "./NinBlack.png" );
+			remove( "./NinLegacy.png" );
+			ClearScreen();	
+			GRRLIB_FillScreen (REDD);
+			GRRLIB_FillScreen (REDD);			
+			GRRLIB_ScrShot("./NinLegacy.png");
+			sleep (1);
+			BackTheme();
+			FadeIt();  goto end;}
+			if (selected == (DOWNLOAD_05)) 
+			{remove( "./NinBack.png" );
+			remove( "./NinBlack.png" );
+			remove( "./NinLegacy.png" );
+			ClearScreen();	
+			GRRLIB_FillScreen (PURPLED);
+			GRRLIB_FillScreen (PURPLED);			
+			GRRLIB_ScrShot("./NinLegacy.png");
+			sleep (1);
+			BackTheme();
+			FadeIt();  goto end;}
+			if (selected == (DOWNLOAD_06)) 
+			{remove( "./NinBack.png" );
+			remove( "./NinBlack.png" );
+			remove( "./NinLegacy.png" );
+			ClearScreen();	
+			GRRLIB_FillScreen (BROWND);
+			GRRLIB_FillScreen (BROWND);			
+			GRRLIB_ScrShot("./NinLegacy.png");
+			sleep (1);
+			BackTheme();
+			FadeIt();  goto end;}
+			if (selected == (DOWNLOAD_07)) 
+			{remove( "./NinBack.png" );
+			remove( "./NinBlack.png" );
+			remove( "./NinLegacy.png" );
+			ClearScreen();	
+			GRRLIB_FillScreen (ROSED);
+			GRRLIB_FillScreen (ROSED);			
+			GRRLIB_ScrShot("./NinLegacy.png");
+			sleep (1);
+			BackTheme();
+			FadeIt();  goto end;}
+			if (selected == (DOWNLOAD_08)) 
+			{remove( "./NinBack.png" );
+			remove( "./NinBlack.png" );
+			remove( "./NinLegacy.png" );
+			ClearScreen();	
+			GRRLIB_FillScreen (GOLDEN);
+			GRRLIB_FillScreen (GOLDEN);		
+			GRRLIB_ScrShot("./NinLegacy.png");
+			sleep (1);
+			BackTheme();
+			FadeIt();  goto end;}
+			if (selected == (DOWNLOAD_09)) 
+			{remove( "./NinBack.png" );
+			remove( "./NinBlack.png" );
+			remove( "./NinLegacy.png" );
+			ClearScreen();	
+			GRRLIB_FillScreen (BLUEL);
+			GRRLIB_FillScreen (BLUEL);			
+			GRRLIB_ScrShot("./NinBack.png");
+			sleep (1);
+			BackTheme();
+			FadeIt();  goto end;}
+			if (selected == (DOWNLOAD_10)) 
+			{remove( "./NinBack.png" );
+			remove( "./NinBlack.png" );
+			remove( "./NinLegacy.png" );
+			ClearScreen();	
+			GRRLIB_FillScreen (GREENL);
+			GRRLIB_FillScreen (GREENL);			
+			GRRLIB_ScrShot("./NinBack.png");
+			sleep (1);
+			BackTheme();
+			FadeIt();  goto end;}
+			if (selected == (DOWNLOAD_11)) 
+			{remove( "./NinBack.png" );
+			remove( "./NinBlack.png" );
+			remove( "./NinLegacy.png" );
+			ClearScreen();	
+			GRRLIB_FillScreen (REDL);
+			GRRLIB_FillScreen (REDL);			
+			GRRLIB_ScrShot("./NinBack.png");
+			sleep (1);
+			BackTheme();
+			FadeIt();  goto end;}
+			if (selected == (DOWNLOAD_12)) 
+			{remove( "./NinBack.png" );
+			remove( "./NinBlack.png" );
+			remove( "./NinLegacy.png" );
+			ClearScreen();	
+			GRRLIB_FillScreen (PURPLEL);
+			GRRLIB_FillScreen (PURPLEL);
+			GRRLIB_ScrShot("./NinBack.png");
+			sleep (1);
+			BackTheme();
+			FadeIt();  goto end;}
+			if (selected == (DOWNLOAD_13)) 
+			{remove( "./NinBack.png" );
+			remove( "./NinBlack.png" );
+			remove( "./NinLegacy.png" );
+			ClearScreen();	
+			GRRLIB_FillScreen (BROWNL);
+			GRRLIB_FillScreen (BROWNL);	
+			GRRLIB_ScrShot("./NinBack.png");
+			sleep (1);
+			BackTheme();
+			FadeIt();  goto end;}
+			if (selected == (DOWNLOAD_14))
+			{remove( "./NinBack.png" );
+			remove( "./NinBlack.png" );
+			remove( "./NinLegacy.png" );
+			ClearScreen();	
+			GRRLIB_FillScreen (YELLOW);
+			GRRLIB_FillScreen (YELLOW);			
+			GRRLIB_ScrShot("./NinBack.png");
+			sleep (1);
+			BackTheme();
+			FadeIt();  goto end;}
+			if (selected == (DOWNLOAD_15))
+			{remove( "./NinBack.png" );
+			remove( "./NinBlack.png" );
+			remove( "./NinLegacy.png" );
+			ClearScreen();	
+			GRRLIB_FillScreen (SILVER);
+			GRRLIB_FillScreen (SILVER);			
+			GRRLIB_ScrShot("./NinBack.png");
+			sleep (1);
+			BackTheme();
+			FadeIt();  goto end;}
+			if (selected == (DOWNLOAD_16))
+			{remove( "./NinBack.png" );
+			remove( "./NinBlack.png" );
+			remove( "./NinLegacy.png" );
+			ClearScreen();	
+			GRRLIB_FillScreen (WHITE);
+			GRRLIB_FillScreen (WHITE);			
+			GRRLIB_ScrShot("./NinBack.png");
+			sleep (1);
+			BackTheme();
+			FadeIt();  goto end;}
+			else
+				break;}
+		if (FPAD_Down(1)) {
+			delay = ticks_to_millisecs(gettime()) + 150;
+			selected++;
+			if (selected > 15) selected = 0;
+		}
+		if (FPAD_Up(1)) {
+			delay = ticks_to_millisecs(gettime()) + 150;
+			selected--;
+			if (selected < 0) selected = 15;
+		}
+		if(FPAD_Y(0)) {
+				Credits();
+		}				
+		if (FPAD_Cancel(1)) {
+			break;
+		}
+	}
+	ClearScreen();
+	UpdateNintendont();
+}
\ No newline at end of file
Index: loader/source/update.c
===================================================================
--- loader/source/update.c	(revision 334)
+++ loader/source/update.c	(working copy)
@@ -30,13 +30,12 @@
 #include <dirent.h>
 #include <zlib.h>
 #include <ogc/lwp_watchdog.h>
-
+#include "ssl.h"
 #include "exi.h"
 #include "FPad.h"
 #include "font.h"
 #include "global.h"
 #include "http.h"
-#include "ssl.h"
 #include "menu.h"
 #include "update.h"
 #include "unzip/miniunz.h"
@@ -53,16 +52,38 @@
 
 typedef enum {
 	DOWNLOAD_NINTENDONT = 0,
+	DOWNLOAD_OLD,
+	DOWNLOAD_OTHER,	
 	DOWNLOAD_TITLES,
 	DOWNLOAD_CONTROLLERS,
+	DOWNLOAD_BIOS,
+	DOWNLOAD_GAME,		
+	DOWNLOAD_LOADERTHEME,
+	DOWNLOAD_LEGACYTHEME,		
+	DOWNLOAD_APPTHEME,
+	DOWNLOAD_GRAD,
+	DOWNLOAD_SIMPLE,
+	DOWNLOAD_BLACK,		
+	DOWNLOAD_DEFAULTTHEME,
 	DOWNLOAD_VERSION
 } DOWNLOADS;
 
 static const downloads_t Downloads[] = {
-	{"https://raw.githubusercontent.com/FIX94/Nintendont/master/loader/loader.dol", "Updating Nintendont", "boot.dol", 0x400000}, // 4MB
-	{"https://raw.githubusercontent.com/FIX94/Nintendont/master/nintendont/titles.txt", "Updating titles.txt", "titles.txt", 0x80000}, // 512KB
-	{"https://raw.githubusercontent.com/FIX94/Nintendont/master/controllerconfigs/controllers.zip", "Updating controllers.zip", "controllers.zip", 0x8000}, // 32KB
-	{"https://raw.githubusercontent.com/FIX94/Nintendont/master/common/include/NintendontVersion.h", "Checking Latest Version", "", 0x400} // 1KB
+	{"http://send0r.de/Nintendont/MasterMod/boot.dol", "Updating Nintendont", "boot.dol", 0x400000}, // 4MB
+	{"https://dl.dropboxusercontent.com/u/101209384/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB	
+	{"https://dl.dropboxusercontent.com/u/101209384/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB	
+	{"http://nintendont.gxarena.com/themes/titles.txt", "Updating titles.txt", "titles.txt", 0x80000}, // 512KB
+	{"http://nintendont.gxarena.com/themes/controllers.zip", "Updating controllers.zip", "controllers.zip", 0x8000}, // 32KB
+	{"https://dl.dropboxusercontent.com/u/101209384/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"https://dl.dropboxusercontent.com/u/101209384/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"https://dl.dropboxusercontent.com/u/101209384/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"https://dl.dropboxusercontent.com/u/101209384/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"https://dl.dropboxusercontent.com/u/101209384/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"https://dl.dropboxusercontent.com/u/101209384/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"https://dl.dropboxusercontent.com/u/101209384/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"https://dl.dropboxusercontent.com/u/101209384/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"https://dl.dropboxusercontent.com/u/101209384/NintendontVersion.h", "Checking Latest Version", "", 0x400}, // 1KB
+	{"https://dl.dropboxusercontent.com/u/101209384/NintendontVersion.h", "Checking Latest Version", "", 0x400} // 1KB
 };
 
 static int UnzipControllers(const char* filepath) {
@@ -92,22 +113,52 @@
 	return 1;
 }
 
+static int UnzipBlack(const char* filepath) {
+	char unzip_directory[20];
+	unzFile uf = unzOpen(filepath);
+	if (uf==NULL)
+	{
+		gprintf("Cannot open %s, aborting\r\n", Downloads[DOWNLOAD_BLACK].filename);
+		return -1;
+	}
+	gprintf("%s opened\n", Downloads[DOWNLOAD_BLACK].filename);
+	sprintf(unzip_directory, "./");
+	mkdir(unzip_directory,S_IWRITE|S_IREAD); // attempt to make dir
+	if(chdir(unzip_directory)) {
+		gprintf("Error changing into %s, aborting\r\n", unzip_directory);
+		return -2;
+	}
+
+	if (extractZip(uf,0,1,0)) {
+		gprintf("Failed to extract %s\r\n", filepath);
+		return -3;
+	}
+
+	unzCloseCurrentFile(uf);
+	remove(Downloads[DOWNLOAD_BLACK].filename);
+	return 1;
+}
+
 static inline bool LatestVersion(int *major, int *minor, int *current_line) {
 	u32 http_status = 0;
 	u8* outbuf = NULL;
 	u32 filesize;
 	int line = *current_line;
-
-	PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[DOWNLOAD_VERSION].text);
+					if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[DOWNLOAD_VERSION].text);}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[DOWNLOAD_VERSION].text);}
 	UpdateScreen();
 	line++;
 	if(!http_request(Downloads[DOWNLOAD_VERSION].url, Downloads[DOWNLOAD_VERSION].max_size)) {
-		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Failed to retrieve version");
+						if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Failed to retrieve version");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Failed to retrieve version");}
 		UpdateScreen();
 		*current_line = line;
-		return false;
+		return true; //false;
 	}
-	
 
 	http_get_result(&http_status, &outbuf, &filesize);
 	
@@ -117,14 +168,22 @@
 		*current_line = line;
 		return false;
 	}
-	sscanf((char*)outbuf, " #ifndef %*s #define %*s #define NIN_MAJOR_VERSION %i #define NIN_MINOR_VERSION %i", major, minor);
-	gprintf("major = %i, minor = %i\r\n", *major, *minor);
+//	sscanf((char*)outbuf, " #ifndef %*s #define %*s #define NIN_MAJOR_VERSION %i #define NIN_MINOR_VERSION %i", major, minor);
+//	gprintf("major = %i, minor = %i\r\n", *major, *minor);
+	*major=3;
+	*minor=999;
 	if (outbuf != NULL) free(outbuf);
-	if ((*major <= NIN_MAJOR_VERSION) && (*minor <= NIN_MINOR_VERSION)) {
+	/*if ((*major <= NIN_MAJOR_VERSION) && (*minor <= NIN_MINOR_VERSION)) {
 		bool still_download = true;
-		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "You already have the latest version");
+								if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "You already have the latest version");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "You already have the latest version");}
 		line++;
-		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Download anyway? (A: Yes, B: No)");
+								if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Download anyway? (A: Yes, B: No)");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Download anyway? (A: Yes, B: No)");}
 		line++;
 		UpdateScreen();
 		while(true) {
@@ -145,7 +204,7 @@
 			*current_line = line;
 			return false;
 		}
-	}
+	} */
 	*current_line = line;
 	return (*major + *minor) > 0;
 
@@ -162,8 +221,15 @@
 	char filepath[MAXPATHLEN];
 	FILE *file;
 	bool dir_argument_exists = strlen(launch_dir);
+	if (download_number == 0)
 	snprintf(filepath, sizeof(filepath), "%s%s", dir_argument_exists ? launch_dir : "/apps/Nintendont/", Downloads[download_number].filename);
-	PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[download_number].text);
+	else
+	snprintf(filepath, sizeof(filepath), "%s%s", dir_argument_exists ? launch_dir : "./", Downloads[download_number].filename);
+	
+								if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[download_number].text);}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, Downloads[download_number].text);}
 	UpdateScreen();
 	
 	line++;
@@ -174,7 +240,10 @@
 		goto end;
 	}
 	gprintf("Network Initialized\r\n");
-	PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Network Initialized");
+									if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Network Initialized");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Network Initialized");}
 	UpdateScreen();
 	ssl_init(); //only once needed
 	line++;
@@ -181,7 +250,10 @@
 	if (download_number == DOWNLOAD_NINTENDONT) {
 		ret = LatestVersion(&major, &minor, &line);
 		if (!ret) {
-			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Download Cancelled");
+										if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*(line+1), "Download Cancelled");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*(line+1), "Download Cancelled");}
 			UpdateScreen();
 			if (outbuf != NULL) free(outbuf);
 			net_deinit();
@@ -188,8 +260,10 @@
 			sleep(4);
 			return 0;
 		}
-
-		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Downloading Nintendont v%i.%i", major, minor);
+								if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Downloading MasterMod");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Downloading MasterMod");}
 		UpdateScreen();
 		line++;
 	}
@@ -210,7 +284,10 @@
 		ret = -2;
 		goto end;
 	}
-	PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Download Complete");
+									if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Download Complete");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Download Complete");}
 	UpdateScreen();
 	line++;
 	if (!dir_argument_exists) {
@@ -227,9 +304,13 @@
 	} else {
 		fwrite(outbuf, filesize, 1, file);
 		fclose(file);
-		if (download_number == DOWNLOAD_CONTROLLERS) ret = UnzipControllers(filepath);
+		if (download_number == DOWNLOAD_CONTROLLERS) ret = UnzipControllers(filepath);	
+		if (download_number == DOWNLOAD_BLACK) ret = UnzipBlack(filepath);					
 		if (ret == 1) {
-			PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Update Complete");
+										if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Update Complete");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Update Complete");}
 			UpdateScreen();
 			line++;
 		}
@@ -237,13 +318,23 @@
 
 end:
 	if (ret != 1)
-		PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*line, "Update Error: %i", ret);
+		{
+			if (which_bg == BG_NONE)
+			PrintFormat(DEFAULT_SIZE, MAROON, MENU_POS_X, MENU_POS_Y + 20*line, "Update Error: %i", ret);
+			else if (which_bg == BG_LEGACY)
+			PrintFormat(DEFAULT_SIZE, YELLOW, MENU_POS_X, MENU_POS_Y + 20*line, "Update Error: %i", ret);
+		}
 	else
-		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Restart Nintendont to complete update");
+	{									if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*line, "Restart Nintendont to complete update");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*line, "Restart Nintendont to complete update");}}
+		
 	UpdateScreen();
 	if (outbuf != NULL) free(outbuf);
 	net_deinit();
-	sleep(4);
+	sleep(3);
+	//BackTheme();
 	return ret;
 }
 
@@ -252,40 +343,143 @@
 	u64 delay = ticks_to_millisecs(gettime()) + 500;
 	while(true) {
 		ClearScreen();
+		if (which_bg == BG_NONE)
+					{		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");	
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");		
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X, MENU_POS_Y + 20*2, "Updates & Themes Menu");
+		PrintFormat(15, BLACK, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");		
 		PrintInfo();
-		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Download Nintendont");
-		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Download titles.txt");
-		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Download controllers.zip");
-		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Return to Settings");
-		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 35, MENU_POS_Y + 20*(5+selected), ARROW_RIGHT);
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Download Nintendont MasterMod (Latest Revision)");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Download Nintendont MasterMod (Stable Revisions)");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Download Nintendont (Official & Other Mods)");				
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Download Game Titles File");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Download HID Controllers Pack");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*9, "Download/Delete Bios Files");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*10, "Download/Delete Custom Game Loader Themes");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*11, "Download Nintendont Loader Themes");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*12, "Download Nintendont Dark Themes");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*13, "Download Nintendont Light Themes");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*14, "Download Nintendont Gradient Themes");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*15, "Generate Nintendont Simple Themes");								
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*16, "Generate Nintendont Black Boot Theme");				
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*17, "Restore Default Theme");	
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 50, MENU_POS_Y + 20*18, "Exit Updates & Themes Menu");
+		PrintFormat(DEFAULT_SIZE, BLACK, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+					else if (which_bg == BG_LEGACY)
+					{		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y, "  Home: Exit");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*1, "  A   : Select");	
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 430, MENU_POS_Y + 20*2, "  B   : Back");		
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X, MENU_POS_Y + 20*2, "Updates & Themes Menu");
+		PrintFormat(15, WHITE, MENU_POS_X + 235, MENU_POS_Y + 20*21, "Y/2: Credits");		
+		PrintInfo();
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*4, "Download Nintendont MasterMod (Latest Revision)");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*5, "Download Nintendont MasterMod (Stable Revisions)");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*6, "Download Nintendont (Official & Other Mods)");				
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*7, "Download Game Titles File");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*8, "Download HID Controllers Pack");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*9, "Download/Delete Bios Files");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*10, "Download/Delete Custom Game Loader Themes");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*11, "Download Nintendont Loader Themes");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*12, "Download Nintendont Dark Themes");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*13, "Download Nintendont Light Themes");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*14, "Download Nintendont Gradient Themes");
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*15, "Generate Nintendont Simple Themes");								
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*16, "Generate Nintendont Black Boot Theme");				
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*17, "Restore Default Theme");	
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 50, MENU_POS_Y + 20*18, "Exit Updates & Themes Menu");
+
+		PrintFormat(DEFAULT_SIZE, WHITE, MENU_POS_X + 35, MENU_POS_Y + 20*(4+selected), ARROW_RIGHT);}
+
 		GRRLIB_Render();
 		FPAD_Update();
 		if (delay > ticks_to_millisecs(gettime())) continue;
 		if (FPAD_Start(1)) {
 			ClearScreen();
-			PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Returning to loader...");
+					if (which_bg == BG_NONE)
+					{PrintFormat(DEFAULT_SIZE, BLACK, 212, 232, "Returning to loader...");}
+					else if (which_bg == BG_LEGACY)
+					{PrintFormat(DEFAULT_SIZE, WHITE, 212, 232, "Returning to loader...");}
 			ExitToLoader(0);
 		}
 		if (FPAD_OK(1)) {
-			if (selected <= DOWNLOAD_CONTROLLERS)
-				Download(selected);
+			if (selected == (DOWNLOAD_APPTHEME))
+				UpdateThemes();
+			if (selected == (DOWNLOAD_LOADERTHEME))
+				UpdateLoader();	
+			if (selected == (DOWNLOAD_LEGACYTHEME))
+				UpdateLegacy();	
+			if (selected == (DOWNLOAD_DEFAULTTHEME))
+				{remove( "./NinBackLight.png" );
+				remove( "./NinBackDark.png" );
+				remove( "./NinBackBars.png" );
+				remove( "./NinBackNoBar.png" );
+				remove( "./NinLegacy.png" );				
+				remove( "./NinBack.png" );
+				remove( "./NinBlack.png" );
+				background = GRRLIB_LoadTexturePNG(background_png);
+				which_bg = BG_NONE;
+				UpdateNintendont();}	
+			if (selected == (DOWNLOAD_BIOS))
+				UpdateBios();
+			if (selected == (DOWNLOAD_OLD))
+				UpdateOld();
+			if (selected == (DOWNLOAD_OTHER))
+				UpdateOther();	
+			if (selected == (DOWNLOAD_SIMPLE))
+				SimpleBack();	
+			if (selected == (DOWNLOAD_GRAD))
+				UpdateGrad();
+			if (selected == (DOWNLOAD_GAME))
+				GDMenu();
+			if (selected == (DOWNLOAD_BLACK))
+			{remove( "./NinBackLight.png" );
+			remove( "./NinBackDark.png" );
+			remove( "./NinBackBars.png" );
+			remove( "./NinBackNoBar.png" );
+			remove( "./NinBlack.png" );	
+			ClearScreen();	
+			GRRLIB_FillScreen (BLACK);
+			GRRLIB_FillScreen (BLACK);
+			GRRLIB_ScrShot("./NinBlack.png");
+			sleep (1);
+			BackTheme();
+			ClearScreen();		
+			if (which_bg == BG_NONE)
+			{
+			PrintFormat(25, BLACK, MENU_POS_X, MENU_POS_Y + 20*9, "Games Will Boot into a Black Screen Now");
+			PrintFormat(25, BLACK, MENU_POS_X, MENU_POS_Y + 20*11, "All Boot Messages & Info Will Be Hidden");
+			}
+			else if (which_bg == BG_LEGACY)
+			{
+			PrintFormat(25, WHITE, MENU_POS_X, MENU_POS_Y + 20*9, "Games Will Boot into a Black Screen Now");
+			PrintFormat(25, WHITE, MENU_POS_X, MENU_POS_Y + 20*11, "All Boot Messages & Info Will Be Hidden");
+			}
+			UpdateScreen();
+			sleep (5);
+			UpdateNintendont();}			
+			if ((selected <= (DOWNLOAD_CONTROLLERS)) && (selected != (DOWNLOAD_OTHER)) && (selected != (DOWNLOAD_OLD)))
+			{Download(selected);}
 			else
-				break;
-		}
+				break;}
 		if (FPAD_Down(1)) {
 			delay = ticks_to_millisecs(gettime()) + 150;
 			selected++;
-			if (selected > 3) selected = 0;
+			if (selected > 14) selected = 0;
 		}
 		if (FPAD_Up(1)) {
 			delay = ticks_to_millisecs(gettime()) + 150;
 			selected--;
-			if (selected < 0) selected = 3;
+			if (selected < 0) selected = 14;
 		}
+		if(FPAD_Y(0)) {
+				Credits();
+		}
 		if (FPAD_Cancel(1)) {
 			break;
 		}
 	}
 	ClearScreen();
+	//BackTheme();
 	return;
-}
+}
\ No newline at end of file
Index: Makeme.bat
===================================================================
--- Makeme.bat	(revision 0)
+++ Makeme.bat	(working copy)
@@ -0,0 +1,3 @@
+cd loader
+make
+pause
\ No newline at end of file
Index: mem_map.txt
===================================================================
--- mem_map.txt	(revision 334)
+++ mem_map.txt	(working copy)
@@ -54,6 +54,8 @@
 0x93005000-0x930050E8=hid controller positions
 0x930050F0-0x93005170=hid packet (may be bigger device dependent)
 
+0x93006000-0x93008000=cheats path
+
 0x93007420-0x93009000=old di thread stack
 0x93010000=old memory card buffer,old EXI Interrupt Handler Status
 0x93010010-0x93020010=loader and our reload stub
Index: resetstub/main.c
===================================================================
--- resetstub/main.c	(revision 334)
+++ resetstub/main.c	(working copy)
@@ -58,6 +58,10 @@
 	ret = ios_ioctlvreboot(es_fd, IOCTL_ES_LAUNCH, 2, 0, vecs);
 	return ret;
 }
+#define HBC_LULZ			0x000100014c554c5aULL
+#define HBC_108				0x00010001af1bf516ULL
+#define HBC_JODI			0x0001000148415858ULL
+#define HBC_HAXX			0x000100014a4f4449ULL
 #define SYSTEM_MENU			0x0000000100000002ULL
 void
 _main(void)
@@ -106,6 +110,10 @@
 #if DEBUG
 	usbgecko_printf("es_init()\n");
 #endif
+	es_launchtitle(HBC_LULZ);
+	es_launchtitle(HBC_108);
+	es_launchtitle(HBC_JODI);
+	es_launchtitle(HBC_HAXX);
 	es_launchtitle(SYSTEM_MENU);
 #if DEBUG
 	usbgecko_printf("es_launchtitle()\n");
Index: resetstub/openstub.ld
===================================================================
--- resetstub/openstub.ld	(revision 334)
+++ resetstub/openstub.ld	(working copy)
@@ -15,7 +15,7 @@
 }
 
 SECTIONS {
-	. = 0x81330000;
+	. = 0x80004000;
 
 	.text : { *(.text) *(.text.*) } :app
 
@@ -26,7 +26,6 @@
 	.bss : { *(.bss) *(.bss.*) }
 	__bss_end = .;
 
-	. = 0x81331800;
 	__stack_end = .;
 	.stack : {
 		. = . + 0x8000;
